              	; --------------------------------------
              	; zasm: assemble "cpm22.asm"
              	; date: 2023-02-26 02:03:41
              	; --------------------------------------


              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;*      Modified to build as single image from source
              	;*
              	;**************************************************************
              	;
              	;   Set memory base here. 
              	;
003A:         	mem	equ	58		;CP/M image starts at mem*1024
              	;
0003:         	iobyte	equ	3		;i/o definition byte.
0004:         	tdrive	equ	4		;current drive name and user number.
0005:         	entry	equ	5		;entry point for the cp/m bdos.
005C:         	tfcb	equ	5ch		;default file control block.
0080:         	tbuff	equ	80h		;i/o buffer and command line storage.
0100:         	tbase	equ	100h		;transiant program storage area.
              	;
              	;   set control character equates.
              	;
0003:         	cntrlc	equ	3		;control-c
0005:         	cntrle	equ	05h		;control-e
0008:         	bs	equ	08h		;backspace
0009:         	tab	equ	09h		;tab
000A:         	lf	equ	0ah		;line feed
000C:         	ff	equ	0ch		;form feed
000D:         	cr	equ	0dh		;carriage return
0010:         	cntrlp	equ	10h		;control-p
0012:         	cntrlr	equ	12h		;control-r
0013:         	cntrls	equ	13h		;control-s
0015:         	cntrlu	equ	15h		;control-u
0018:         	cntrlx	equ	18h		;control-x
001A:         	cntrlz	equ	1ah		;control-z (end-of-file mark)
007F:         	del	equ	7fh		;rubout
              	;
              	;   set origin for cp/m
              	;
E800:         		org	(mem)*1024
              	;
E800: C35CEB  	cbase:	jp	command		;execute command processor (ccp).
E803: C358EB  		jp	clearbuf	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   standard cp/m ccp input buffer. format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
E806: 7F      	inbuff:	defb	127		;length of input buffer.
E807: 00      		defb	0		;current length of contents.
E808: 436F7079		defb	'Copyright'
E80C: 72696768	
E810: 74      	
E811: 20313937		defb	' 1979 (c) by Digital Research      '
E815: 39202863	
E819: 29206279	
E81D: 20446967	
E821: 6974616C	
E825: 20526573	
E829: 65617263	
E82D: 68202020	
E831: 202020  	
E834: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E838: 00...   	
E84B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E84F: 00...   	
E862: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E866: 00...   	
E879: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E87D: 00...   	
E888: 08E8    	inpoint:defw	inbuff+2	;input line pointer
E88A: 0000    	namepnt:defw	0		;input line pointer used for error message. points to
              	;			;start of name in error.
              	;
              	;   routine to print (a) on the console. all registers used.
              	;
E88C: 5F      	print:	ld	e,a		;setup bdos call.
E88D: 0E02    		ld	c,2
E88F: C30500  		jp	entry
              	;
              	;   routine to print (a) on the console and to save (bc).
              	;
E892: C5      	printb:	push	bc
E893: CD8CE8  		call	print
E896: C1      		pop	bc
E897: C9      		ret	
              	;
              	;   routine to send a carriage return, line feed combination
              	; to the console.
              	;
E898: 3E0D    	crlf:	ld	a,cr
E89A: CD92E8  		call	printb
E89D: 3E0A    		ld	a,lf
E89F: C392E8  		jp	printb
              	;
              	;   routine to send one space to the console and save (bc).
              	;
E8A2: 3E20    	space:	ld	a,' '
E8A4: C392E8  		jp	printb
              	;
              	;   routine to print character string pointed to be (bc) on the
              	; console. it must terminate with a null byte.
              	;
E8A7: C5      	pline:	push	bc
E8A8: CD98E8  		call	crlf
E8AB: E1      		pop	hl
E8AC: 7E      	pline2:	ld	a,(hl)
E8AD: B7      		or	a
E8AE: C8      		ret	z
E8AF: 23      		inc	hl
E8B0: E5      		push	hl
E8B1: CD8CE8  		call	print
E8B4: E1      		pop	hl
E8B5: C3ACE8  		jp	pline2
              	;
              	;   routine to reset the disk system.
              	;
E8B8: 0E0D    	resdsk:	ld	c,13
E8BA: C30500  		jp	entry
              	;
              	;   routine to select disk (a).
              	;
E8BD: 5F      	dsksel:	ld	e,a
E8BE: 0E0E    		ld	c,14
E8C0: C30500  		jp	entry
              	;
              	;   routine to call bdos and save the return code. the zero
              	; flag is set on a return of 0ffh.
              	;
E8C3: CD0500  	entry1:	call	entry
E8C6: 32EEEF  		ld	(rtncode),a	;save return code.
E8C9: 3C      		inc	a		;set zero if 0ffh returned.
E8CA: C9      		ret	
              	;
              	;   routine to open a file. (de) must point to the fcb.
              	;
E8CB: 0E0F    	open:	ld	c,15
E8CD: C3C3E8  		jp	entry1
              	;
              	;   routine to open file at (fcb).
              	;
E8D0: AF      	openfcb:xor	a		;clear the record number byte at fcb+32
E8D1: 32EDEF  		ld	(fcb+32),a
E8D4: 11CDEF  		ld	de,fcb
E8D7: C3CBE8  		jp	open
              	;
              	;   routine to close a file. (de) points to fcb.
              	;
E8DA: 0E10    	close:	ld	c,16
E8DC: C3C3E8  		jp	entry1
              	;
              	;   routine to search for the first file with ambigueous name
              	; (de).
              	;
E8DF: 0E11    	srchfst:ld	c,17
E8E1: C3C3E8  		jp	entry1
              	;
              	;   search for the next ambigeous file name.
              	;
E8E4: 0E12    	srchnxt:ld	c,18
E8E6: C3C3E8  		jp	entry1
              	;
              	;   search for file at (fcb).
              	;
E8E9: 11CDEF  	srchfcb:ld	de,fcb
E8EC: C3DFE8  		jp	srchfst
              	;
              	;   routine to delete a file pointed to by (de).
              	;
E8EF: 0E13    	delete:	ld	c,19
E8F1: C30500  		jp	entry
              	;
              	;   routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
E8F4: CD0500  	entry2:	call	entry
E8F7: B7      		or	a		;set zero flag if appropriate.
E8F8: C9      		ret	
              	;
              	;   routine to read the next record from a sequential file.
              	; (de) points to the fcb.
              	;
E8F9: 0E14    	rdrec:	ld	c,20
E8FB: C3F4E8  		jp	entry2
              	;
              	;   routine to read file at (fcb).
              	;
E8FE: 11CDEF  	readfcb:ld	de,fcb
E901: C3F9E8  		jp	rdrec
              	;
              	;   routine to write the next record of a sequential file.
              	; (de) points to the fcb.
              	;
E904: 0E15    	wrtrec:	ld	c,21
E906: C3F4E8  		jp	entry2
              	;
              	;   routine to create the file pointed to by (de).
              	;
E909: 0E16    	create:	ld	c,22
E90B: C3C3E8  		jp	entry1
              	;
              	;   routine to rename the file pointed to by (de). note that
              	; the new name starts at (de+16).
              	;
E90E: 0E17    	renam:	ld	c,23
E910: C30500  		jp	entry
              	;
              	;   get the current user code.
              	;
E913: 1EFF    	getusr:	ld	e,0ffh
              	;
              	;   routne to get or set the current user code.
              	; if (e) is ff then this is a get, else it is a set.
              	;
E915: 0E20    	getsetuc: ld	c,32
E917: C30500  		jp	entry
              	;
              	;   routine to set the current drive byte at (tdrive).
              	;
E91A: CD13E9  	setcdrv:call	getusr		;get user number
E91D: 87      		add	a,a		;and shift into the upper 4 bits.
E91E: 87      		add	a,a
E91F: 87      		add	a,a
E920: 87      		add	a,a
E921: 21EFEF  		ld	hl,cdrive	;now add in the current drive number.
E924: B6      		or	(hl)
E925: 320400  		ld	(tdrive),a	;and save.
E928: C9      		ret	
              	;
              	;   move currently active drive down to (tdrive).
              	;
E929: 3AEFEF  	movecd:	ld	a,(cdrive)
E92C: 320400  		ld	(tdrive),a
E92F: C9      		ret	
              	;
              	;   routine to convert (a) into upper case ascii. only letters
              	; are affected.
              	;
E930: FE61    	upper:	cp	'a'		;check for letters in the range of 'a' to 'z'.
E932: D8      		ret	c
E933: FE7B    		cp	'{'
E935: D0      		ret	nc
E936: E65F    		and	5fh		;convert it if found.
E938: C9      		ret	
              	;
              	;   routine to get a line of input. we must check to see if the
              	; user is in (batch) mode. if so, then read the input from file
              	; ($$$.sub). at the end, reset to console input.
              	;
E939: 3AABEF  	getinp:	ld	a,(batch)	;if =0, then use console input.
E93C: B7      		or	a
E93D: CA96E9  		jp	z,getinp1
              	;
              	;   use the submit file ($$$.sub) which is prepared by a
              	; submit run. it must be on drive (a) and it will be deleted
              	; if and error occures (like eof).
              	;
E940: 3AEFEF  		ld	a,(cdrive)	;select drive 0 if need be.
E943: B7      		or	a
E944: 3E00    		ld	a,0		;always use drive a for submit.
E946: C4BDE8  		call	nz,dsksel	;select it if required.
E949: 11ACEF  		ld	de,batchfcb
E94C: CDCBE8  		call	open		;look for it.
E94F: CA96E9  		jp	z,getinp1	;if not there, use normal input.
E952: 3ABBEF  		ld	a,(batchfcb+15)	;get last record number+1.
E955: 3D      		dec	a
E956: 32CCEF  		ld	(batchfcb+32),a
E959: 11ACEF  		ld	de,batchfcb
E95C: CDF9E8  		call	rdrec		;read last record.
E95F: C296E9  		jp	nz,getinp1	;quit on end of file.
              	;
              	;   move this record into input buffer.
              	;
E962: 1107E8  		ld	de,inbuff+1
E965: 218000  		ld	hl,tbuff	;data was read into buffer here.
E968: 0680    		ld	b,128		;all 128 characters may be used.
E96A: CD42EC  		call	hl2de		;(hl) to (de), (b) bytes.
E96D: 21BAEF  		ld	hl,batchfcb+14
E970: 3600    		ld	(hl),0		;zero out the 's2' byte.
E972: 23      		inc	hl		;and decrement the record count.
E973: 35      		dec	(hl)
E974: 11ACEF  		ld	de,batchfcb	;close the batch file now.
E977: CDDAE8  		call	close
E97A: CA96E9  		jp	z,getinp1	;quit on an error.
E97D: 3AEFEF  		ld	a,(cdrive)	;re-select previous drive if need be.
E980: B7      		or	a
E981: C4BDE8  		call	nz,dsksel	;don't do needless selects.
              	;
              	;   print line just read on console.
              	;
E984: 2108E8  		ld	hl,inbuff+2
E987: CDACE8  		call	pline2
E98A: CDC2E9  		call	chkcon		;check console, quit on a key.
E98D: CAA7E9  		jp	z,getinp2	;jump if no key is pressed.
              	;
              	;   terminate the submit job on any keyboard input. delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
E990: CDDDE9  		call	delbatch	;delete the batch file.
E993: C382EB  		jp	cmmnd1		;and restart command input.
              	;
              	;   get here for normal keyboard input. delete the submit file
              	; incase there was one.
              	;
E996: CDDDE9  	getinp1:call	delbatch	;delete file ($$$.sub).
E999: CD1AE9  		call	setcdrv		;reset active disk.
E99C: 0E0A    		ld	c,10		;get line from console device.
E99E: 1106E8  		ld	de,inbuff
E9A1: CD0500  		call	entry
E9A4: CD29E9  		call	movecd		;reset current drive (again).
              	;
              	;   convert input line to upper case.
              	;
E9A7: 2107E8  	getinp2:ld	hl,inbuff+1
E9AA: 46      		ld	b,(hl)		;(b)=character counter.
E9AB: 23      	getinp3:inc	hl
E9AC: 78      		ld	a,b		;end of the line?
E9AD: B7      		or	a
E9AE: CABAE9  		jp	z,getinp4
E9B1: 7E      		ld	a,(hl)		;convert to upper case.
E9B2: CD30E9  		call	upper
E9B5: 77      		ld	(hl),a
E9B6: 05      		dec	b		;adjust character count.
E9B7: C3ABE9  		jp	getinp3
E9BA: 77      	getinp4:ld	(hl),a		;add trailing null.
E9BB: 2108E8  		ld	hl,inbuff+2
E9BE: 2288E8  		ld	(inpoint),hl	;reset input line pointer.
E9C1: C9      		ret	
              	;
              	;   routine to check the console for a key pressed. the zero
              	; flag is set is none, else the character is returned in (a).
              	;
E9C2: 0E0B    	chkcon:	ld	c,11		;check console.
E9C4: CD0500  		call	entry
E9C7: B7      		or	a
E9C8: C8      		ret	z		;return if nothing.
E9C9: 0E01    		ld	c,1		;else get character.
E9CB: CD0500  		call	entry
E9CE: B7      		or	a		;clear zero flag and return.
E9CF: C9      		ret	
              	;
              	;   routine to get the currently active drive number.
              	;
E9D0: 0E19    	getdsk:	ld	c,25
E9D2: C30500  		jp	entry
              	;
              	;   set the stabdard dma address.
              	;
E9D5: 118000  	stddma:	ld	de,tbuff
              	;
              	;   routine to set the dma address to (de).
              	;
E9D8: 0E1A    	dmaset:	ld	c,26
E9DA: C30500  		jp	entry
              	;
              	;  delete the batch file created by submit.
              	;
E9DD: 21ABEF  	delbatch: ld	hl,batch	;is batch active?
E9E0: 7E      		ld	a,(hl)
E9E1: B7      		or	a
E9E2: C8      		ret	z
E9E3: 3600    		ld	(hl),0		;yes, de-activate it.
E9E5: AF      		xor	a
E9E6: CDBDE8  		call	dsksel		;select drive 0 for sure.
E9E9: 11ACEF  		ld	de,batchfcb	;and delete this file.
E9EC: CDEFE8  		call	delete
E9EF: 3AEFEF  		ld	a,(cdrive)	;reset current drive.
E9F2: C3BDE8  		jp	dsksel
              	;
              	;   check to two strings at (pattrn1) and (pattrn2). they must be
              	; the same or we halt....
              	;
E9F5: 1128EB  	verify:	ld	de,pattrn1	;these are the serial number bytes.
E9F8: 2100F0  		ld	hl,pattrn2	;ditto, but how could they be different?
E9FB: 0606    		ld	b,6		;6 bytes each.
E9FD: 1A      	verify1:ld	a,(de)
E9FE: BE      		cp	(hl)
E9FF: C2CFEB  		jp	nz,halt		;jump to halt routine.
EA02: 13      		inc	de
EA03: 23      		inc	hl
EA04: 05      		dec	b
EA05: C2FDE9  		jp	nz,verify1
EA08: C9      		ret	
              	;
              	;   print back file name with a '?' to indicate a syntax error.
              	;
EA09: CD98E8  	synerr:	call	crlf		;end current line.
EA0C: 2A8AE8  		ld	hl,(namepnt)	;this points to name in error.
EA0F: 7E      	synerr1:ld	a,(hl)		;print it until a space or null is found.
EA10: FE20    		cp	' '
EA12: CA22EA  		jp	z,synerr2
EA15: B7      		or	a
EA16: CA22EA  		jp	z,synerr2
EA19: E5      		push	hl
EA1A: CD8CE8  		call	print
EA1D: E1      		pop	hl
EA1E: 23      		inc	hl
EA1F: C30FEA  		jp	synerr1
EA22: 3E3F    	synerr2:ld	a,'?'		;add trailing '?'.
EA24: CD8CE8  		call	print
EA27: CD98E8  		call	crlf
EA2A: CDDDE9  		call	delbatch	;delete any batch file.
EA2D: C382EB  		jp	cmmnd1		;and restart from console input.
              	;
              	;   check character at (de) for legal command input. note that the
              	; zero flag is set if the character is a delimiter.
              	;
EA30: 1A      	check:	ld	a,(de)
EA31: B7      		or	a
EA32: C8      		ret	z
EA33: FE20    		cp	' '		;control characters are not legal here.
EA35: DA09EA  		jp	c,synerr
EA38: C8      		ret	z		;check for valid delimiter.
EA39: FE3D    		cp	'='
EA3B: C8      		ret	z
EA3C: FE5F    		cp	'_'
EA3E: C8      		ret	z
EA3F: FE2E    		cp	'.'
EA41: C8      		ret	z
EA42: FE3A    		cp	':'
EA44: C8      		ret	z
EA45: FE3B    		cp	';'
EA47: C8      		ret	z
EA48: FE3C    		cp	'<'
EA4A: C8      		ret	z
EA4B: FE3E    		cp	'>'
EA4D: C8      		ret	z
EA4E: C9      		ret	
              	;
              	;   get the next non-blank character from (de).
              	;
EA4F: 1A      	nonblank: ld	a,(de)
EA50: B7      		or	a		;string ends with a null.
EA51: C8      		ret	z
EA52: FE20    		cp	' '
EA54: C0      		ret	nz
EA55: 13      		inc	de
EA56: C34FEA  		jp	nonblank
              	;
              	;   add (hl)=(hl)+(a)
              	;
EA59: 85      	addhl:	add	a,l
EA5A: 6F      		ld	l,a
EA5B: D0      		ret	nc		;take care of any carry.
EA5C: 24      		inc	h
EA5D: C9      		ret	
              	;
              	;   convert the first name in (fcb).
              	;
EA5E: 3E00    	convfst:ld	a,0
              	;
              	;   format a file name (convert * to '?', etc.). on return,
              	; (a)=0 is an unambigeous name was specified. enter with (a) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
EA60: 21CDEF  	convert:ld	hl,fcb
EA63: CD59EA  		call	addhl
EA66: E5      		push	hl
EA67: E5      		push	hl
EA68: AF      		xor	a
EA69: 32F0EF  		ld	(chgdrv),a	;initialize drive change flag.
EA6C: 2A88E8  		ld	hl,(inpoint)	;set (hl) as pointer into input line.
EA6F: EB      		ex	de,hl
EA70: CD4FEA  		call	nonblank	;get next non-blank character.
EA73: EB      		ex	de,hl
EA74: 228AE8  		ld	(namepnt),hl	;save pointer here for any error message.
EA77: EB      		ex	de,hl
EA78: E1      		pop	hl
EA79: 1A      		ld	a,(de)		;get first character.
EA7A: B7      		or	a
EA7B: CA89EA  		jp	z,convrt1
EA7E: DE40    		sbc	a,'A'-1		;might be a drive name, convert to binary.
EA80: 47      		ld	b,a		;and save.
EA81: 13      		inc	de		;check next character for a ':'.
EA82: 1A      		ld	a,(de)
EA83: FE3A    		cp	':'
EA85: CA90EA  		jp	z,convrt2
EA88: 1B      		dec	de		;nope, move pointer back to the start of the line.
EA89: 3AEFEF  	convrt1:ld	a,(cdrive)
EA8C: 77      		ld	(hl),a
EA8D: C396EA  		jp	convrt3
EA90: 78      	convrt2:ld	a,b
EA91: 32F0EF  		ld	(chgdrv),a	;set change in drives flag.
EA94: 70      		ld	(hl),b
EA95: 13      		inc	de
              	;
              	;   convert the basic file name.
              	;
EA96: 0608    	convrt3:ld	b,08h
EA98: CD30EA  	convrt4:call	check
EA9B: CAB9EA  		jp	z,convrt8
EA9E: 23      		inc	hl
EA9F: FE2A    		cp	'*'		;note that an '*' will fill the remaining
EAA1: C2A9EA  		jp	nz,convrt5	;field with '?'.
EAA4: 363F    		ld	(hl),'?'
EAA6: C3ABEA  		jp	convrt6
EAA9: 77      	convrt5:ld	(hl),a
EAAA: 13      		inc	de
EAAB: 05      	convrt6:dec	b
EAAC: C298EA  		jp	nz,convrt4
EAAF: CD30EA  	convrt7:call	check		;get next delimiter.
EAB2: CAC0EA  		jp	z,getext
EAB5: 13      		inc	de
EAB6: C3AFEA  		jp	convrt7
EAB9: 23      	convrt8:inc	hl		;blank fill the file name.
EABA: 3620    		ld	(hl),' '
EABC: 05      		dec	b
EABD: C2B9EA  		jp	nz,convrt8
              	;
              	;   get the extension and convert it.
              	;
EAC0: 0603    	getext:	ld	b,03h
EAC2: FE2E    		cp	'.'
EAC4: C2E9EA  		jp	nz,getext5
EAC7: 13      		inc	de
EAC8: CD30EA  	getext1:call	check
EACB: CAE9EA  		jp	z,getext5
EACE: 23      		inc	hl
EACF: FE2A    		cp	'*'
EAD1: C2D9EA  		jp	nz,getext2
EAD4: 363F    		ld	(hl),'?'
EAD6: C3DBEA  		jp	getext3
EAD9: 77      	getext2:ld	(hl),a
EADA: 13      		inc	de
EADB: 05      	getext3:dec	b
EADC: C2C8EA  		jp	nz,getext1
EADF: CD30EA  	getext4:call	check
EAE2: CAF0EA  		jp	z,getext6
EAE5: 13      		inc	de
EAE6: C3DFEA  		jp	getext4
EAE9: 23      	getext5:inc	hl
EAEA: 3620    		ld	(hl),' '
EAEC: 05      		dec	b
EAED: C2E9EA  		jp	nz,getext5
EAF0: 0603    	getext6:ld	b,3
EAF2: 23      	getext7:inc	hl
EAF3: 3600    		ld	(hl),0
EAF5: 05      		dec	b
EAF6: C2F2EA  		jp	nz,getext7
EAF9: EB      		ex	de,hl
EAFA: 2288E8  		ld	(inpoint),hl	;save input line pointer.
EAFD: E1      		pop	hl
              	;
              	;   check to see if this is an ambigeous file name specification.
              	; set the (a) register to non zero if it is.
              	;
EAFE: 010B00  		ld	bc,11		;set name length.
EB01: 23      	getext8:inc	hl
EB02: 7E      		ld	a,(hl)
EB03: FE3F    		cp	'?'		;any question marks?
EB05: C209EB  		jp	nz,getext9
EB08: 04      		inc	b		;count them.
EB09: 0D      	getext9:dec	c
EB0A: C201EB  		jp	nz,getext8
EB0D: 78      		ld	a,b
EB0E: B7      		or	a
EB0F: C9      		ret	
              	;
              	;   cp/m command table. note commands can be either 3 or 4 characters long.
              	;
0006:         	numcmds equ	6		;number of commands
EB10: 64697220	cmdtbl:	defb	'dir '
EB14: 65726120		defb	'era '
EB18: 74797065		defb	'type'
EB1C: 73617665		defb	'save'
EB20: 72656E20		defb	'ren '
EB24: 75736572		defb	'user'
              	;
              	;   the following six bytes must agree with those at (pattrn2)
              	; or cp/m will halt. why?
              	;
EB28: 00160000	pattrn1:defb	0,22,0,0,0,0	;(* serial number bytes *).
EB2C: 0000    	
              	;
              	;   search the command table for a match with what has just
              	; been entered. if a match is found, then we jump to the
              	; proper section. else jump to (unknown).
              	; on return, the (c) register is set to the command number
              	; that matched (or numcmds+1 if no match).
              	;
EB2E: 2110EB  	search:	ld	hl,cmdtbl
EB31: 0E00    		ld	c,0
EB33: 79      	search1:ld	a,c
EB34: FE06    		cp	numcmds		;this commands exists.
EB36: D0      		ret	nc
EB37: 11CEEF  		ld	de,fcb+1	;check this one.
EB3A: 0604    		ld	b,4		;max command length.
EB3C: 1A      	search2:ld	a,(de)
EB3D: BE      		cp	(hl)
EB3E: C24FEB  		jp	nz,search3	;not a match.
EB41: 13      		inc	de
EB42: 23      		inc	hl
EB43: 05      		dec	b
EB44: C23CEB  		jp	nz,search2
EB47: 1A      		ld	a,(de)		;allow a 3 character command to match.
EB48: FE20    		cp	' '
EB4A: C254EB  		jp	nz,search4
EB4D: 79      		ld	a,c		;set return register for this command.
EB4E: C9      		ret	
EB4F: 23      	search3:inc	hl
EB50: 05      		dec	b
EB51: C24FEB  		jp	nz,search3
EB54: 0C      	search4:inc	c
EB55: C333EB  		jp	search1
              	;
              	;   set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
EB58: AF      	clearbuf: xor	a
EB59: 3207E8  		ld	(inbuff+1),a	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
EB5C: 31ABEF  	command:ld	sp,ccpstack	;setup stack area.
EB5F: C5      		push	bc		;note that (c) should be equal to:
EB60: 79      		ld	a,c		;(uuuudddd) where 'uuuu' is the user number
EB61: 1F      		rra			;and 'dddd' is the drive number.
EB62: 1F      		rra	
EB63: 1F      		rra	
EB64: 1F      		rra	
EB65: E60F    		and	0fh		;isolate the user number.
EB67: 5F      		ld	e,a
EB68: CD15E9  		call	getsetuc	;and set it.
EB6B: CDB8E8  		call	resdsk		;reset the disk system.
EB6E: 32ABEF  		ld	(batch),a	;clear batch mode flag.
EB71: C1      		pop	bc
EB72: 79      		ld	a,c
EB73: E60F    		and	0fh		;isolate the drive number.
EB75: 32EFEF  		ld	(cdrive),a	;and save.
EB78: CDBDE8  		call	dsksel		;...and select.
EB7B: 3A07E8  		ld	a,(inbuff+1)
EB7E: B7      		or	a		;anything in input buffer already?
EB7F: C298EB  		jp	nz,cmmnd2	;yes, we just process it.
              	;
              	;   entry point to get a command line from the console.
              	;
EB82: 31ABEF  	cmmnd1:	ld	sp,ccpstack	;set stack straight.
EB85: CD98E8  		call	crlf		;start a new line on the screen.
EB88: CDD0E9  		call	getdsk		;get current drive.
EB8B: C641    		add	a,'A'
EB8D: CD8CE8  		call	print		;print current drive.
EB90: 3E3E    		ld	a,'>'
EB92: CD8CE8  		call	print		;and add prompt.
EB95: CD39E9  		call	getinp		;get line from user.
              	;
              	;   process command line here.
              	;
EB98: 118000  	cmmnd2:	ld	de,tbuff
EB9B: CDD8E9  		call	dmaset		;set standard dma address.
EB9E: CDD0E9  		call	getdsk
EBA1: 32EFEF  		ld	(cdrive),a	;set current drive.
EBA4: CD5EEA  		call	convfst		;convert name typed in.
EBA7: C409EA  		call	nz,synerr	;wild cards are not allowed.
EBAA: 3AF0EF  		ld	a,(chgdrv)	;if a change in drives was indicated,
EBAD: B7      		or	a		;then treat this as an unknown command
EBAE: C2A5EE  		jp	nz,unknown	;which gets executed.
EBB1: CD2EEB  		call	search		;else search command table for a match.
              	;
              	;   note that an unknown command returns
              	; with (a) pointing to the last address
              	; in our table which is (unknown).
              	;
EBB4: 21C1EB  		ld	hl,cmdadr	;now, look thru our address table for command (a).
EBB7: 5F      		ld	e,a		;set (de) to command number.
EBB8: 1600    		ld	d,0
EBBA: 19      		add	hl,de
EBBB: 19      		add	hl,de		;(hl)=(cmdadr)+2*(command number).
EBBC: 7E      		ld	a,(hl)		;now pick out this address.
EBBD: 23      		inc	hl
EBBE: 66      		ld	h,(hl)
EBBF: 6F      		ld	l,a
EBC0: E9      		jp	(hl)		;now execute it.
              	;
              	;   cp/m command address table.
              	;
EBC1: 77EC1FED	cmdadr:	defw	direct,erase,type,save
EBC5: 5DEDADED	
EBC9: 10EE8EEE		defw	rename,user,unknown
EBCD: A5EE    	
              	;
              	;   halt the system. reason for this is unknown at present.
              	;
EBCF: 21F376  	halt:	ld	hl,76f3h	;'di hlt' instructions.
EBD2: 2200E8  		ld	(cbase),hl
EBD5: 2100E8  		ld	hl,cbase
EBD8: E9      		jp	(hl)
              	;
              	;   read error while typeing a file.
              	;
EBD9: 01DFEB  	rderror:ld	bc,rderr
EBDC: C3A7E8  		jp	pline
EBDF: 72656164	rderr:	defb	'read error',0
EBE3: 20657272	
EBE7: 6F7200  	
              	;
              	;   required file was not located.
              	;
EBEA: 01F0EB  	none:	ld	bc,nofile
EBED: C3A7E8  		jp	pline
EBF0: 6E6F2066	nofile:	defb	'no file',0
EBF4: 696C6500	
              	;
              	;   decode a command of the form 'a>filename number{ filename}.
              	; note that a drive specifier is not allowed on the first file
              	; name. on return, the number is in register (a). any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
EBF8: CD5EEA  	decode:	call	convfst		;convert filename.
EBFB: 3AF0EF  		ld	a,(chgdrv)	;do not allow a drive to be specified.
EBFE: B7      		or	a
EBFF: C209EA  		jp	nz,synerr
EC02: 21CEEF  		ld	hl,fcb+1	;convert number now.
EC05: 010B00  		ld	bc,11		;(b)=sum register, (c)=max digit count.
EC08: 7E      	decode1:ld	a,(hl)
EC09: FE20    		cp	' '		;a space terminates the numeral.
EC0B: CA33EC  		jp	z,decode3
EC0E: 23      		inc	hl
EC0F: D630    		sub	'0'		;make binary from ascii.
EC11: FE0A    		cp	10		;legal digit?
EC13: D209EA  		jp	nc,synerr
EC16: 57      		ld	d,a		;yes, save it in (d).
EC17: 78      		ld	a,b		;compute (b)=(b)*10 and check for overflow.
EC18: E6E0    		and	0e0h
EC1A: C209EA  		jp	nz,synerr
EC1D: 78      		ld	a,b
EC1E: 07      		rlca	
EC1F: 07      		rlca	
EC20: 07      		rlca			;(a)=(b)*8
EC21: 80      		add	a,b		;.......*9
EC22: DA09EA  		jp	c,synerr
EC25: 80      		add	a,b		;.......*10
EC26: DA09EA  		jp	c,synerr
EC29: 82      		add	a,d		;add in new digit now.
EC2A: DA09EA  	decode2:jp	c,synerr
EC2D: 47      		ld	b,a		;and save result.
EC2E: 0D      		dec	c		;only look at 11 digits.
EC2F: C208EC  		jp	nz,decode1
EC32: C9      		ret	
EC33: 7E      	decode3:ld	a,(hl)		;spaces must follow (why?).
EC34: FE20    		cp	' '
EC36: C209EA  		jp	nz,synerr
EC39: 23      		inc	hl
EC3A: 0D      	decode4:dec	c
EC3B: C233EC  		jp	nz,decode3
EC3E: 78      		ld	a,b		;set (a)=the numeric value entered.
EC3F: C9      		ret	
              	;
              	;   move 3 bytes from (hl) to (de). note that there is only
              	; one reference to this at (a2d5h).
              	;
EC40: 0603    	move3:	ld	b,3
              	;
              	;   move (b) bytes from (hl) to (de).
              	;
EC42: 7E      	hl2de:	ld	a,(hl)
EC43: 12      		ld	(de),a
EC44: 23      		inc	hl
EC45: 13      		inc	de
EC46: 05      		dec	b
EC47: C242EC  		jp	nz,hl2de
EC4A: C9      		ret	
              	;
              	;   compute (hl)=(tbuff)+(a)+(c) and get the byte that's here.
              	;
EC4B: 218000  	extract:ld	hl,tbuff
EC4E: 81      		add	a,c
EC4F: CD59EA  		call	addhl
EC52: 7E      		ld	a,(hl)
EC53: C9      		ret	
              	;
              	;  check drive specified. if it means a change, then the new
              	; drive will be selected. in any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
EC54: AF      	dselect:xor	a		;null out first byte of fcb.
EC55: 32CDEF  		ld	(fcb),a
EC58: 3AF0EF  		ld	a,(chgdrv)	;a drive change indicated?
EC5B: B7      		or	a
EC5C: C8      		ret	z
EC5D: 3D      		dec	a		;yes, is it the same as the current drive?
EC5E: 21EFEF  		ld	hl,cdrive
EC61: BE      		cp	(hl)
EC62: C8      		ret	z
EC63: C3BDE8  		jp	dsksel		;no. select it then.
              	;
              	;   check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
EC66: 3AF0EF  	resetdr:ld	a,(chgdrv)	;drive change indicated?
EC69: B7      		or	a
EC6A: C8      		ret	z
EC6B: 3D      		dec	a		;yes, was it a different drive?
EC6C: 21EFEF  		ld	hl,cdrive
EC6F: BE      		cp	(hl)
EC70: C8      		ret	z
EC71: 3AEFEF  		ld	a,(cdrive)	;yes, re-select our old drive.
EC74: C3BDE8  		jp	dsksel
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
EC77: CD5EEA  	direct:	call	convfst		;convert file name.
EC7A: CD54EC  		call	dselect		;select indicated drive.
EC7D: 21CEEF  		ld	hl,fcb+1	;was any file indicated?
EC80: 7E      		ld	a,(hl)
EC81: FE20    		cp	' '
EC83: C28FEC  		jp	nz,direct2
EC86: 060B    		ld	b,11		;no. fill field with '?' - same as *.*.
EC88: 363F    	direct1:ld	(hl),'?'
EC8A: 23      		inc	hl
EC8B: 05      		dec	b
EC8C: C288EC  		jp	nz,direct1
EC8F: 1E00    	direct2:ld	e,0		;set initial cursor position.
EC91: D5      		push	de
EC92: CDE9E8  		call	srchfcb		;get first file name.
EC95: CCEAEB  		call	z,none		;none found at all?
EC98: CA1BED  	direct3:jp	z,direct9	;terminate if no more names.
EC9B: 3AEEEF  		ld	a,(rtncode)	;get file's position in segment (0-3).
EC9E: 0F      		rrca	
EC9F: 0F      		rrca	
ECA0: 0F      		rrca	
ECA1: E660    		and	60h		;(a)=position*32
ECA3: 4F      		ld	c,a
ECA4: 3E0A    		ld	a,10
ECA6: CD4BEC  		call	extract		;extract the tenth entry in fcb.
ECA9: 17      		rla			;check system file status bit.
ECAA: DA0FED  		jp	c,direct8	;we don't list them.
ECAD: D1      		pop	de
ECAE: 7B      		ld	a,e		;bump name count.
ECAF: 1C      		inc	e
ECB0: D5      		push	de
ECB1: E603    		and	03h		;at end of line?
ECB3: F5      		push	af
ECB4: C2CCEC  		jp	nz,direct4
ECB7: CD98E8  		call	crlf		;yes, end this line and start another.
ECBA: C5      		push	bc
ECBB: CDD0E9  		call	getdsk		;start line with ('a:').
ECBE: C1      		pop	bc
ECBF: C641    		add	a,'A'
ECC1: CD92E8  		call	printb
ECC4: 3E3A    		ld	a,':'
ECC6: CD92E8  		call	printb
ECC9: C3D4EC  		jp	direct5
ECCC: CDA2E8  	direct4:call	space		;add seperator between file names.
ECCF: 3E3A    		ld	a,':'
ECD1: CD92E8  		call	printb
ECD4: CDA2E8  	direct5:call	space
ECD7: 0601    		ld	b,1		;'extract' each file name character at a time.
ECD9: 78      	direct6:ld	a,b
ECDA: CD4BEC  		call	extract
ECDD: E67F    		and	7fh		;strip bit 7 (status bit).
ECDF: FE20    		cp	' '		;are we at the end of the name?
ECE1: C2F9EC  		jp	nz,drect65
ECE4: F1      		pop	af		;yes, don't print spaces at the end of a line.
ECE5: F5      		push	af
ECE6: FE03    		cp	3
ECE8: C2F7EC  		jp	nz,drect63
ECEB: 3E09    		ld	a,9		;first check for no extension.
ECED: CD4BEC  		call	extract
ECF0: E67F    		and	7fh
ECF2: FE20    		cp	' '
ECF4: CA0EED  		jp	z,direct7	;don't print spaces.
ECF7: 3E20    	drect63:ld	a,' '		;else print them.
ECF9: CD92E8  	drect65:call	printb
ECFC: 04      		inc	b		;bump to next character psoition.
ECFD: 78      		ld	a,b
ECFE: FE0C    		cp	12		;end of the name?
ED00: D20EED  		jp	nc,direct7
ED03: FE09    		cp	9		;nope, starting extension?
ED05: C2D9EC  		jp	nz,direct6
ED08: CDA2E8  		call	space		;yes, add seperating space.
ED0B: C3D9EC  		jp	direct6
ED0E: F1      	direct7:pop	af		;get the next file name.
ED0F: CDC2E9  	direct8:call	chkcon		;first check console, quit on anything.
ED12: C21BED  		jp	nz,direct9
ED15: CDE4E8  		call	srchnxt		;get next name.
ED18: C398EC  		jp	direct3		;and continue with our list.
ED1B: D1      	direct9:pop	de		;restore the stack and return to command level.
ED1C: C386EF  		jp	getback
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
ED1F: CD5EEA  	erase:	call	convfst		;convert file name.
ED22: FE0B    		cp	11		;was '*.*' entered?
ED24: C242ED  		jp	nz,erase1
ED27: 0152ED  		ld	bc,yesno	;yes, ask for confirmation.
ED2A: CDA7E8  		call	pline
ED2D: CD39E9  		call	getinp
ED30: 2107E8  		ld	hl,inbuff+1
ED33: 35      		dec	(hl)		;must be exactly 'y'.
ED34: C282EB  		jp	nz,cmmnd1
ED37: 23      		inc	hl
ED38: 7E      		ld	a,(hl)
ED39: FE79    		cp	'y'
ED3B: C282EB  		jp	nz,cmmnd1
ED3E: 23      		inc	hl
ED3F: 2288E8  		ld	(inpoint),hl	;save input line pointer.
ED42: CD54EC  	erase1:	call	dselect		;select desired disk.
ED45: 11CDEF  		ld	de,fcb
ED48: CDEFE8  		call	delete		;delete the file.
ED4B: 3C      		inc	a
ED4C: CCEAEB  		call	z,none		;not there?
ED4F: C386EF  		jp	getback		;return to command level now.
ED52: 616C6C20	yesno:	defb	'all (y/n)?',0
ED56: 28792F6E	
ED5A: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
ED5D: CD5EEA  	type:	call	convfst		;convert file name.
ED60: C209EA  		jp	nz,synerr	;wild cards not allowed.
ED63: CD54EC  		call	dselect		;select indicated drive.
ED66: CDD0E8  		call	openfcb		;open the file.
ED69: CAA7ED  		jp	z,type5		;not there?
ED6C: CD98E8  		call	crlf		;ok, start a new line on the screen.
ED6F: 21F1EF  		ld	hl,nbytes	;initialize byte counter.
ED72: 36FF    		ld	(hl),0ffh	;set to read first sector.
ED74: 21F1EF  	type1:	ld	hl,nbytes
ED77: 7E      	type2:	ld	a,(hl)		;have we written the entire sector?
ED78: FE80    		cp	128
ED7A: DA87ED  		jp	c,type3
ED7D: E5      		push	hl		;yes, read in the next one.
ED7E: CDFEE8  		call	readfcb
ED81: E1      		pop	hl
ED82: C2A0ED  		jp	nz,type4	;end or error?
ED85: AF      		xor	a		;ok, clear byte counter.
ED86: 77      		ld	(hl),a
ED87: 34      	type3:	inc	(hl)		;count this byte.
ED88: 218000  		ld	hl,tbuff	;and get the (a)th one from the buffer (tbuff).
ED8B: CD59EA  		call	addhl
ED8E: 7E      		ld	a,(hl)
ED8F: FE1A    		cp	cntrlz		;end of file mark?
ED91: CA86EF  		jp	z,getback
ED94: CD8CE8  		call	print		;no, print it.
ED97: CDC2E9  		call	chkcon		;check console, quit if anything ready.
ED9A: C286EF  		jp	nz,getback
ED9D: C374ED  		jp	type1
              	;
              	;   get here on an end of file or read error.
              	;
EDA0: 3D      	type4:	dec	a		;read error?
EDA1: CA86EF  		jp	z,getback
EDA4: CDD9EB  		call	rderror		;yes, print message.
EDA7: CD66EC  	type5:	call	resetdr		;and reset proper drive
EDAA: C309EA  		jp	synerr		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
EDAD: CDF8EB  	save:	call	decode		;get numeric number that follows save.
EDB0: F5      		push	af		;save number of pages to write.
EDB1: CD5EEA  		call	convfst		;convert file name.
EDB4: C209EA  		jp	nz,synerr	;wild cards not allowed.
EDB7: CD54EC  		call	dselect		;select specified drive.
EDBA: 11CDEF  		ld	de,fcb		;now delete this file.
EDBD: D5      		push	de
EDBE: CDEFE8  		call	delete
EDC1: D1      		pop	de
EDC2: CD09E9  		call	create		;and create it again.
EDC5: CAFBED  		jp	z,save3		;can't create?
EDC8: AF      		xor	a		;clear record number byte.
EDC9: 32EDEF  		ld	(fcb+32),a
EDCC: F1      		pop	af		;convert pages to sectors.
EDCD: 6F      		ld	l,a
EDCE: 2600    		ld	h,0
EDD0: 29      		add	hl,hl		;(hl)=number of sectors to write.
EDD1: 110001  		ld	de,tbase	;and we start from here.
EDD4: 7C      	save1:	ld	a,h		;done yet?
EDD5: B5      		or	l
EDD6: CAF1ED  		jp	z,save2
EDD9: 2B      		dec	hl		;nope, count this and compute the start
EDDA: E5      		push	hl		;of the next 128 byte sector.
EDDB: 218000  		ld	hl,128
EDDE: 19      		add	hl,de
EDDF: E5      		push	hl		;save it and set the transfer address.
EDE0: CDD8E9  		call	dmaset
EDE3: 11CDEF  		ld	de,fcb		;write out this sector now.
EDE6: CD04E9  		call	wrtrec
EDE9: D1      		pop	de		;reset (de) to the start of the last sector.
EDEA: E1      		pop	hl		;restore sector count.
EDEB: C2FBED  		jp	nz,save3	;write error?
EDEE: C3D4ED  		jp	save1
              	;
              	;   get here after writing all of the file.
              	;
EDF1: 11CDEF  	save2:	ld	de,fcb		;now close the file.
EDF4: CDDAE8  		call	close
EDF7: 3C      		inc	a		;did it close ok?
EDF8: C201EE  		jp	nz,save4
              	;
              	;   print out error message (no space).
              	;
EDFB: 0107EE  	save3:	ld	bc,nospace
EDFE: CDA7E8  		call	pline
EE01: CDD5E9  	save4:	call	stddma		;reset the standard dma address.
EE04: C386EF  		jp	getback
EE07: 6E6F2073	nospace:defb	'no space',0
EE0B: 70616365	
EE0F: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
EE10: CD5EEA  	rename:	call	convfst		;convert first file name.
EE13: C209EA  		jp	nz,synerr	;wild cards not allowed.
EE16: 3AF0EF  		ld	a,(chgdrv)	;remember any change in drives specified.
EE19: F5      		push	af
EE1A: CD54EC  		call	dselect		;and select this drive.
EE1D: CDE9E8  		call	srchfcb		;is this file present?
EE20: C279EE  		jp	nz,rename6	;yes, print error message.
EE23: 21CDEF  		ld	hl,fcb		;yes, move this name into second slot.
EE26: 11DDEF  		ld	de,fcb+16
EE29: 0610    		ld	b,16
EE2B: CD42EC  		call	hl2de
EE2E: 2A88E8  		ld	hl,(inpoint)	;get input pointer.
EE31: EB      		ex	de,hl
EE32: CD4FEA  		call	nonblank	;get next non blank character.
EE35: FE3D    		cp	'='		;only allow an '=' or '_' seperator.
EE37: CA3FEE  		jp	z,rename1
EE3A: FE5F    		cp	'_'
EE3C: C273EE  		jp	nz,rename5
EE3F: EB      	rename1:ex	de,hl
EE40: 23      		inc	hl		;ok, skip seperator.
EE41: 2288E8  		ld	(inpoint),hl	;save input line pointer.
EE44: CD5EEA  		call	convfst		;convert this second file name now.
EE47: C273EE  		jp	nz,rename5	;again, no wild cards.
EE4A: F1      		pop	af		;if a drive was specified, then it
EE4B: 47      		ld	b,a		;must be the same as before.
EE4C: 21F0EF  		ld	hl,chgdrv
EE4F: 7E      		ld	a,(hl)
EE50: B7      		or	a
EE51: CA59EE  		jp	z,rename2
EE54: B8      		cp	b
EE55: 70      		ld	(hl),b
EE56: C273EE  		jp	nz,rename5	;they were different, error.
EE59: 70      	rename2:ld	(hl),b		;	reset as per the first file specification.
EE5A: AF      		xor	a
EE5B: 32CDEF  		ld	(fcb),a		;clear the drive byte of the fcb.
EE5E: CDE9E8  	rename3:call	srchfcb		;and go look for second file.
EE61: CA6DEE  		jp	z,rename4	;doesn't exist?
EE64: 11CDEF  		ld	de,fcb
EE67: CD0EE9  		call	renam		;ok, rename the file.
EE6A: C386EF  		jp	getback
              	;
              	;   process rename errors here.
              	;
EE6D: CDEAEB  	rename4:call	none		;file not there.
EE70: C386EF  		jp	getback
EE73: CD66EC  	rename5:call	resetdr		;bad command format.
EE76: C309EA  		jp	synerr
EE79: 0182EE  	rename6:ld	bc,exists	;destination file already exists.
EE7C: CDA7E8  		call	pline
EE7F: C386EF  		jp	getback
EE82: 66696C65	exists:	defb	'file exists',0
EE86: 20657869	
EE8A: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
EE8E: CDF8EB  	user:	call	decode		;get numeric value following command.
EE91: FE10    		cp	16		;legal user number?
EE93: D209EA  		jp	nc,synerr
EE96: 5F      		ld	e,a		;yes but is there anything else?
EE97: 3ACEEF  		ld	a,(fcb+1)
EE9A: FE20    		cp	' '
EE9C: CA09EA  		jp	z,synerr	;yes, that is not allowed.
EE9F: CD15E9  		call	getsetuc	;ok, set user code.
EEA2: C389EF  		jp	getback1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
EEA5: CDF5E9  	unknown:call	verify		;check for valid system (why?).
EEA8: 3ACEEF  		ld	a,(fcb+1)	;anything to execute?
EEAB: FE20    		cp	' '
EEAD: C2C4EE  		jp	nz,unkwn1
EEB0: 3AF0EF  		ld	a,(chgdrv)	;nope, only a drive change?
EEB3: B7      		or	a
EEB4: CA89EF  		jp	z,getback1	;neither???
EEB7: 3D      		dec	a
EEB8: 32EFEF  		ld	(cdrive),a	;ok, store new drive.
EEBB: CD29E9  		call	movecd		;set (tdrive) also.
EEBE: CDBDE8  		call	dsksel		;and select this drive.
EEC1: C389EF  		jp	getback1	;then return.
              	;
              	;   here a file name was typed. prepare to execute it.
              	;
EEC4: 11D6EF  	unkwn1:	ld	de,fcb+9	;an extension specified?
EEC7: 1A      		ld	a,(de)
EEC8: FE20    		cp	' '
EECA: C209EA  		jp	nz,synerr	;yes, not allowed.
EECD: D5      	unkwn2:	push	de
EECE: CD54EC  		call	dselect		;select specified drive.
EED1: D1      		pop	de
EED2: 2183EF  		ld	hl,comfile	;set the extension to 'com'.
EED5: CD40EC  		call	move3
EED8: CDD0E8  		call	openfcb		;and open this file.
EEDB: CA6BEF  		jp	z,unkwn9	;not present?
              	;
              	;   load in the program.
              	;
EEDE: 210001  		ld	hl,tbase	;store the program starting here.
EEE1: E5      	unkwn3:	push	hl
EEE2: EB      		ex	de,hl
EEE3: CDD8E9  		call	dmaset		;set transfer address.
EEE6: 11CDEF  		ld	de,fcb		;and read the next record.
EEE9: CDF9E8  		call	rdrec
EEEC: C201EF  		jp	nz,unkwn4	;end of file or read error?
EEEF: E1      		pop	hl		;nope, bump pointer for next sector.
EEF0: 118000  		ld	de,128
EEF3: 19      		add	hl,de
EEF4: 1100E8  		ld	de,cbase	;enough room for the whole file?
EEF7: 7D      		ld	a,l
EEF8: 93      		sub	e
EEF9: 7C      		ld	a,h
EEFA: 9A      		sbc	a,d
EEFB: D271EF  		jp	nc,unkwn0	;no, it can't fit.
EEFE: C3E1EE  		jp	unkwn3
              	;
              	;   get here after finished reading.
              	;
EF01: E1      	unkwn4:	pop	hl
EF02: 3D      		dec	a		;normal end of file?
EF03: C271EF  		jp	nz,unkwn0
EF06: CD66EC  		call	resetdr		;yes, reset previous drive.
EF09: CD5EEA  		call	convfst		;convert the first file name that follows
EF0C: 21F0EF  		ld	hl,chgdrv	;command name.
EF0F: E5      		push	hl
EF10: 7E      		ld	a,(hl)		;set drive code in default fcb.
EF11: 32CDEF  		ld	(fcb),a
EF14: 3E10    		ld	a,16		;put second name 16 bytes later.
EF16: CD60EA  		call	convert		;convert second file name.
EF19: E1      		pop	hl
EF1A: 7E      		ld	a,(hl)		;and set the drive for this second file.
EF1B: 32DDEF  		ld	(fcb+16),a
EF1E: AF      		xor	a		;clear record byte in fcb.
EF1F: 32EDEF  		ld	(fcb+32),a
EF22: 115C00  		ld	de,tfcb		;move it into place at(005ch).
EF25: 21CDEF  		ld	hl,fcb
EF28: 0621    		ld	b,33
EF2A: CD42EC  		call	hl2de
EF2D: 2108E8  		ld	hl,inbuff+2	;now move the remainder of the input
EF30: 7E      	unkwn5:	ld	a,(hl)		;line down to (0080h). look for a non blank.
EF31: B7      		or	a		;or a null.
EF32: CA3EEF  		jp	z,unkwn6
EF35: FE20    		cp	' '
EF37: CA3EEF  		jp	z,unkwn6
EF3A: 23      		inc	hl
EF3B: C330EF  		jp	unkwn5
              	;
              	;   do the line move now. it ends in a null byte.
              	;
EF3E: 0600    	unkwn6:	ld	b,0		;keep a character count.
EF40: 118100  		ld	de,tbuff+1	;data gets put here.
EF43: 7E      	unkwn7:	ld	a,(hl)		;move it now.
EF44: 12      		ld	(de),a
EF45: B7      		or	a
EF46: CA4FEF  		jp	z,unkwn8
EF49: 04      		inc	b
EF4A: 23      		inc	hl
EF4B: 13      		inc	de
EF4C: C343EF  		jp	unkwn7
EF4F: 78      	unkwn8:	ld	a,b		;now store the character count.
EF50: 328000  		ld	(tbuff),a
EF53: CD98E8  		call	crlf		;clean up the screen.
EF56: CDD5E9  		call	stddma		;set standard transfer address.
EF59: CD1AE9  		call	setcdrv		;reset current drive.
EF5C: CD0001  		call	tbase		;and execute the program.
              	;
              	;   transiant programs return here (or reboot).
              	;
EF5F: 31ABEF  		ld	sp,batch	;set stack first off.
EF62: CD29E9  		call	movecd		;move current drive into place (tdrive).
EF65: CDBDE8  		call	dsksel		;and reselect it.
EF68: C382EB  		jp	cmmnd1		;back to comand mode.
              	;
              	;   get here if some error occured.
              	;
EF6B: CD66EC  	unkwn9:	call	resetdr		;inproper format.
EF6E: C309EA  		jp	synerr
EF71: 017AEF  	unkwn0:	ld	bc,badload	;read error or won't fit.
EF74: CDA7E8  		call	pline
EF77: C386EF  		jp	getback
EF7A: 62616420	badload:defb	'bad load',0
EF7E: 6C6F6164	
EF82: 00      	
EF83: 636F6D  	comfile:defb	'com'		;command file extension.
              	;
              	;   get here to return to command level. we will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
EF86: CD66EC  	getback:call	resetdr		;reset previous drive.
EF89: CD5EEA  	getback1: call	convfst		;convert first name in (fcb).
EF8C: 3ACEEF  		ld	a,(fcb+1)	;if this was just a drive change request,
EF8F: D620    		sub	' '		;make sure it was valid.
EF91: 21F0EF  		ld	hl,chgdrv
EF94: B6      		or	(hl)
EF95: C209EA  		jp	nz,synerr
EF98: C382EB  		jp	cmmnd1		;ok, return to command level.
              	;
              	;   ccp stack area.
              	;
EF9B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EF9F: 00...   	
EFAB:         	ccpstack equ	$	;end of ccp stack area.
              	;
              	;   batch (or submit) processing information storage.
              	;
EFAB: 00      	batch:	defb	0		;batch mode flag (0=not active).
EFAC: 00242424	batchfcb: defb	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EFB0: 20202020	
EFB4: 20535542	
EFB8: 00000000	
EFBC: 00...   	
              	;
              	;   file control block setup by the ccp.
              	;
EFCD: 00202020	fcb:	defb	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
EFD1: 20202020	
EFD5: 20202020	
EFD9: 00000000	
EFDD: 00202020	
EFE1: 20202020	
EFE5: 20202020	
EFE9: 00000000	
EFED: 00      	
EFEE: 00      	rtncode:defb	0		;status returned from bdos call.
EFEF: 00      	cdrive:	defb	0		;currently active drive.
EFF0: 00      	chgdrv:	defb	0		;change in drives flag (0=no change).
EFF1: 0000    	nbytes:	defw	0		;byte counter used by type.
              	;
              	;   room for expansion?
              	;
EFF3: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0
EFF7: 00...   	
              	;
              	;   note that the following six bytes must match those at
              	; (pattrn1) or cp/m will halt. why?
              	;
F000: 00160000	pattrn2:defb	0,22,0,0,0,0	;(* serial number bytes *).
F004: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
F006: C314F0  	fbase:	jp	fbase1
F009: C300FE  		jp	boot
              	;
              	;   bdos error table.
              	;
F00C: 9CF0    	badsctr:defw	error1		;bad sector on read or write.
F00E: A8F0    	badslct:defw	error2		;bad disk select.
F010: AEF0    	rodisk:	defw	error3		;disk is read only.
F012: B4F0    	rofile:	defw	error4		;file is read only.
              	;
              	;   entry into bdos. (de) or (e) are the parameters passed. the
              	; function number desired is in register (c).
              	;
F014: EB      	fbase1:	ex	de,hl		;save the (de) parameters.
F015: 2246F3  		ld	(params),hl
F018: EB      		ex	de,hl
F019: 7B      		ld	a,e		;and save register (e) in particular.
F01A: 32D9FD  		ld	(eparam),a
F01D: 210000  		ld	hl,0
F020: 2248F3  		ld	(status),hl	;clear return status.
F023: 39      		add	hl,sp
F024: 2212F3  		ld	(usrstack),hl	;save users stack pointer.
F027: 3144F3  		ld	sp,stkarea	;and set our own.
F02A: AF      		xor	a		;clear auto select storage space.
F02B: 32E3FD  		ld	(autoflag),a
F02E: 32E1FD  		ld	(auto),a
F031: 2177FD  		ld	hl,goback	;set return address.
F034: E5      		push	hl
F035: 79      		ld	a,c		;get function number.
F036: FE29    		cp	nfuncts		;valid function number?
F038: D0      		ret	nc
F039: 4B      		ld	c,e		;keep single register function here.
F03A: 214AF0  		ld	hl,functns	;now look thru the function table.
F03D: 5F      		ld	e,a
F03E: 1600    		ld	d,0		;(de)=function number.
F040: 19      		add	hl,de
F041: 19      		add	hl,de		;(hl)=(start of table)+2*(function number).
F042: 5E      		ld	e,(hl)
F043: 23      		inc	hl
F044: 56      		ld	d,(hl)		;now (de)=address for this function.
F045: 2A46F3  		ld	hl,(params)	;retrieve parameters.
F048: EB      		ex	de,hl		;now (de) has the original parameters.
F049: E9      		jp	(hl)		;execute desired function.
              	;
              	;   bdos function jump table.
              	;
0029:         	nfuncts equ	41		;number of functions in followin table.
              	;
F04A: 04FECBF2	functns:defw	wboot,getcon,outcon,getrdr,punch,list,dircio,getiob
F04E: 93F1D1F2	
F052: 13FE10FE	
F056: D7F2F0F2	
F05A: F6F2FBF2		defw	setiob,prtstr,rdbuff,getcsts,getver,rstdsk,setdsk,openfil
F05E: E4F101F3	
F062: 81FC86FC	
F066: 48FC9FFC	
F06A: A8FCAEFC		defw	closefil,getfst,getnxt,delfile,readseq,wrtseq,fcreate
F06E: CBFCDAFC	
F072: E3FCE9FC	
F076: EFFC    	
F078: F8FC01FD		defw	renfile,getlog,getcrnt,putdma,getaloc,wrtprtd,getrov,setattr
F07C: 07FD0DFD	
F080: 14FD2FF5	
F084: 1AFD20FD	
F088: 29FD30FD		defw	getparm,getuser,rdrandom,wtrandom,filesize,setran,logoff,rtn
F08C: 44FD4AFD	
F090: 50FD11FC	
F094: 56FD07F3	
F098: 07F39EFD		defw	rtn,wtspecl
              	;
              	;   bdos error message section.
              	;
F09C: 21CDF0  	error1:	ld	hl,badsec	;bad sector message.
F09F: CDE8F0  		call	prterr		;print it and get a 1 char responce.
F0A2: FE03    		cp	cntrlc		;re-boot request (control-c)?
F0A4: CA0000  		jp	z,0		;yes.
F0A7: C9      		ret			;no, return to retry i/o function.
              	;
F0A8: 21D8F0  	error2:	ld	hl,badsel	;bad drive selected.
F0AB: C3B7F0  		jp	error5
              	;
F0AE: 21E4F0  	error3:	ld	hl,diskro	;disk is read only.
F0B1: C3B7F0  		jp	error5
              	;
F0B4: 21DFF0  	error4:	ld	hl,filero	;file is read only.
              	;
F0B7: CDE8F0  	error5:	call	prterr
F0BA: C30000  		jp	0		;always reboot on these errors.
              	;
F0BD: 42646F73	bdoserr:defb	'Bdos Err on '
F0C1: 20457272	
F0C5: 206F6E20	
F0C9: 203A2024	bdosdrv:defb	' : $'
F0CD: 42616420	badsec:	defb	'Bad Sector$'
F0D1: 53656374	
F0D5: 6F7224  	
F0D8: 53656C65	badsel:	defb	'Select$'
F0DC: 637424  	
F0DF: 46696C65	filero:	defb	'File '
F0E3: 20      	
F0E4: 522F4F24	diskro:	defb	'R/O$'
              	;
              	;   print bdos error message.
              	;
F0E8: E5      	prterr:	push	hl		;save second message pointer.
F0E9: CDCCF1  		call	outcrlf		;send (cr)(lf).
F0EC: 3A45F3  		ld	a,(active)	;get active drive.
F0EF: C641    		add	a,'A'		;make ascii.
F0F1: 32C9F0  		ld	(bdosdrv),a	;and put in message.
F0F4: 01BDF0  		ld	bc,bdoserr	;and print it.
F0F7: CDD6F1  		call	prtmesg
F0FA: C1      		pop	bc		;print second message line now.
F0FB: CDD6F1  		call	prtmesg
              	;
              	;   get an input character. we will check our 1 character
              	; buffer first. this may be set by the console status routine.
              	;
F0FE: 2111F3  	getchar:ld	hl,charbuf	;check character buffer.
F101: 7E      		ld	a,(hl)		;anything present already?
F102: 3600    		ld	(hl),0		;...either case clear it.
F104: B7      		or	a
F105: C0      		ret	nz		;yes, use it.
F106: C30AFE  		jp	conin		;nope, go get a character responce.
              	;
              	;   input and echo a character.
              	;
F109: CDFEF0  	getecho:call	getchar		;input a character.
F10C: CD17F1  		call	chkchar		;carriage control?
F10F: D8      		ret	c		;no, a regular control char so don't echo.
F110: F5      		push	af		;ok, save character now.
F111: 4F      		ld	c,a
F112: CD93F1  		call	outcon		;and echo it.
F115: F1      		pop	af		;get character and return.
F116: C9      		ret	
              	;
              	;   check character in (a). set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
F117: FE0D    	chkchar:cp	cr		;check for carriage return, line feed, backspace,
F119: C8      		ret	z		;or a tab.
F11A: FE0A    		cp	lf
F11C: C8      		ret	z
F11D: FE09    		cp	tab
F11F: C8      		ret	z
F120: FE08    		cp	bs
F122: C8      		ret	z
F123: FE20    		cp	' '		;other control char? set carry flag.
F125: C9      		ret	
              	;
              	;   check the console during output. halt on a control-s, then
              	; reboot on a control-c. if anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
F126: 3A11F3  	ckconsol: ld	a,(charbuf)	;check buffer.
F129: B7      		or	a		;if anything, just return without checking.
F12A: C248F1  		jp	nz,ckcon2
F12D: CD07FE  		call	const		;nothing in buffer. check console.
F130: E601    		and	01h		;look at bit 0.
F132: C8      		ret	z		;return if nothing.
F133: CD0AFE  		call	conin		;ok, get it.
F136: FE13    		cp	cntrls		;if not control-s, return with zero cleared.
F138: C245F1  		jp	nz,ckcon1
F13B: CD0AFE  		call	conin		;halt processing until another char
F13E: FE03    		cp	cntrlc		;is typed. control-c?
F140: CA0000  		jp	z,0		;yes, reboot now.
F143: AF      		xor	a		;no, just pretend nothing was ever ready.
F144: C9      		ret	
F145: 3211F3  	ckcon1:	ld	(charbuf),a	;save character in buffer for later processing.
F148: 3E01    	ckcon2:	ld	a,1		;set (a) to non zero to mean something is ready.
F14A: C9      		ret	
              	;
              	;   output (c) to the screen. if the printer flip-flop flag
              	; is set, we will send character to printer also. the console
              	; will be checked in the process.
              	;
F14B: 3A0DF3  	outchar:ld	a,(outflag)	;check output flag.
F14E: B7      		or	a		;anything and we won't generate output.
F14F: C265F1  		jp	nz,outchr1
F152: C5      		push	bc
F153: CD26F1  		call	ckconsol	;check console (we don't care whats there).
F156: C1      		pop	bc
F157: C5      		push	bc
F158: CD0DFE  		call	conout		;output (c) to the screen.
F15B: C1      		pop	bc
F15C: C5      		push	bc
F15D: 3A10F3  		ld	a,(prtflag)	;check printer flip-flop flag.
F160: B7      		or	a
F161: C410FE  		call	nz,list		;print it also if non-zero.
F164: C1      		pop	bc
F165: 79      	outchr1:ld	a,c		;update cursors position.
F166: 210FF3  		ld	hl,curpos
F169: FE7F    		cp	del		;rubouts don't do anything here.
F16B: C8      		ret	z
F16C: 34      		inc	(hl)		;bump line pointer.
F16D: FE20    		cp	' '		;and return if a normal character.
F16F: D0      		ret	nc
F170: 35      		dec	(hl)		;restore and check for the start of the line.
F171: 7E      		ld	a,(hl)
F172: B7      		or	a
F173: C8      		ret	z		;ingnore control characters at the start of the line.
F174: 79      		ld	a,c
F175: FE08    		cp	bs		;is it a backspace?
F177: C27CF1  		jp	nz,outchr2
F17A: 35      		dec	(hl)		;yes, backup pointer.
F17B: C9      		ret	
F17C: FE0A    	outchr2:cp	lf		;is it a line feed?
F17E: C0      		ret	nz		;ignore anything else.
F17F: 3600    		ld	(hl),0		;reset pointer to start of line.
F181: C9      		ret	
              	;
              	;   output (a) to the screen. if it is a control character
              	; (other than carriage control), use ^x format.
              	;
F182: 79      	showit:	ld	a,c
F183: CD17F1  		call	chkchar		;check character.
F186: D293F1  		jp	nc,outcon	;not a control, use normal output.
F189: F5      		push	af
F18A: 0E5E    		ld	c,'^'		;for a control character, preceed it with '^'.
F18C: CD4BF1  		call	outchar
F18F: F1      		pop	af
F190: F640    		or	'@'		;and then use the letter equivelant.
F192: 4F      		ld	c,a
              	;
              	;   function to output (c) to the console device and expand tabs
              	; if necessary.
              	;
F193: 79      	outcon:	ld	a,c
F194: FE09    		cp	tab		;is it a tab?
F196: C24BF1  		jp	nz,outchar	;use regular output.
F199: 0E20    	outcon1:ld	c,' '		;yes it is, use spaces instead.
F19B: CD4BF1  		call	outchar
F19E: 3A0FF3  		ld	a,(curpos)	;go until the cursor is at a multiple of 8
              	
F1A1: E607    		and	07h		;position.
F1A3: C299F1  		jp	nz,outcon1
F1A6: C9      		ret	
              	;
              	;   echo a backspace character. erase the prevoius character
              	; on the screen.
              	;
F1A7: CDAFF1  	backup:	call	backup1		;backup the screen 1 place.
F1AA: 0E20    		ld	c,' '		;then blank that character.
F1AC: CD0DFE  		call	conout
F1AF: 0E08    	backup1:ld	c,bs		;then back space once more.
F1B1: C30DFE  		jp	conout
              	;
              	;   signal a deleted line. print a '#' at the end and start
              	; over.
              	;
F1B4: 0E23    	newline:ld	c,'#'
F1B6: CD4BF1  		call	outchar		;print this.
F1B9: CDCCF1  		call	outcrlf		;start new line.
F1BC: 3A0FF3  	newln1:	ld	a,(curpos)	;move the cursor to the starting position.
F1BF: 210EF3  		ld	hl,starting
F1C2: BE      		cp	(hl)
F1C3: D0      		ret	nc		;there yet?
F1C4: 0E20    		ld	c,' '
F1C6: CD4BF1  		call	outchar		;nope, keep going.
F1C9: C3BCF1  		jp	newln1
              	;
              	;   output a (cr) (lf) to the console device (screen).
              	;
F1CC: 0E0D    	outcrlf:ld	c,cr
F1CE: CD4BF1  		call	outchar
F1D1: 0E0A    		ld	c,lf
F1D3: C34BF1  		jp	outchar
              	;
              	;   print message pointed to by (bc). it will end with a '$'.
              	;
F1D6: 0A      	prtmesg:ld	a,(bc)		;check for terminating character.
F1D7: FE24    		cp	'$'
F1D9: C8      		ret	z
F1DA: 03      		inc	bc
F1DB: C5      		push	bc		;otherwise, bump pointer and print it.
F1DC: 4F      		ld	c,a
F1DD: CD93F1  		call	outcon
F1E0: C1      		pop	bc
F1E1: C3D6F1  		jp	prtmesg
              	;
              	;   function to execute a buffered read.
              	;
F1E4: 3A0FF3  	rdbuff:	ld	a,(curpos)	;use present location as starting one.
F1E7: 320EF3  		ld	(starting),a
F1EA: 2A46F3  		ld	hl,(params)	;get the maximum buffer space.
F1ED: 4E      		ld	c,(hl)
F1EE: 23      		inc	hl		;point to first available space.
F1EF: E5      		push	hl		;and save.
F1F0: 0600    		ld	b,0		;keep a character count.
F1F2: C5      	rdbuf1:	push	bc
F1F3: E5      		push	hl
F1F4: CDFEF0  	rdbuf2:	call	getchar		;get the next input character.
F1F7: E67F    		and	7fh		;strip bit 7.
F1F9: E1      		pop	hl		;reset registers.
F1FA: C1      		pop	bc
F1FB: FE0D    		cp	cr		;en of the line?
F1FD: CAC4F2  		jp	z,rdbuf17
F200: FE0A    		cp	lf
F202: CAC4F2  		jp	z,rdbuf17
F205: FE08    		cp	bs		;how about a backspace?
F207: C219F2  		jp	nz,rdbuf3
F20A: 78      		ld	a,b		;yes, but ignore at the beginning of the line.
F20B: B7      		or	a
F20C: CAF2F1  		jp	z,rdbuf1
F20F: 05      		dec	b		;ok, update counter.
F210: 3A0FF3  		ld	a,(curpos)	;if we backspace to the start of the line,
F213: 320DF3  		ld	(outflag),a	;treat as a cancel (control-x).
F216: C373F2  		jp	rdbuf10
F219: FE7F    	rdbuf3:	cp	del		;user typed a rubout?
F21B: C229F2  		jp	nz,rdbuf4
F21E: 78      		ld	a,b		;ignore at the start of the line.
F21F: B7      		or	a
F220: CAF2F1  		jp	z,rdbuf1
F223: 7E      		ld	a,(hl)		;ok, echo the prevoius character.
F224: 05      		dec	b		;and reset pointers (counters).
F225: 2B      		dec	hl
F226: C3ACF2  		jp	rdbuf15
F229: FE05    	rdbuf4:	cp	cntrle		;physical end of line?
F22B: C23AF2  		jp	nz,rdbuf5
F22E: C5      		push	bc		;yes, do it.
F22F: E5      		push	hl
F230: CDCCF1  		call	outcrlf
F233: AF      		xor	a		;and update starting position.
F234: 320EF3  		ld	(starting),a
F237: C3F4F1  		jp	rdbuf2
F23A: FE10    	rdbuf5:	cp	cntrlp		;control-p?
F23C: C24BF2  		jp	nz,rdbuf6
F23F: E5      		push	hl		;yes, flip the print flag filp-flop byte.
F240: 2110F3  		ld	hl,prtflag
F243: 3E01    		ld	a,1		;prtflag=1-prtflag
F245: 96      		sub	(hl)
F246: 77      		ld	(hl),a
F247: E1      		pop	hl
F248: C3F2F1  		jp	rdbuf1
F24B: FE18    	rdbuf6:	cp	cntrlx		;control-x (cancel)?
F24D: C262F2  		jp	nz,rdbuf8
F250: E1      		pop	hl
F251: 3A0EF3  	rdbuf7:	ld	a,(starting)	;yes, backup the cursor to here.
F254: 210FF3  		ld	hl,curpos
F257: BE      		cp	(hl)
F258: D2E4F1  		jp	nc,rdbuff	;done yet?
F25B: 35      		dec	(hl)		;no, decrement pointer and output back up one space.
F25C: CDA7F1  		call	backup
F25F: C351F2  		jp	rdbuf7
F262: FE15    	rdbuf8:	cp	cntrlu		;cntrol-u (cancel line)?
F264: C26EF2  		jp	nz,rdbuf9
F267: CDB4F1  		call	newline		;start a new line.
F26A: E1      		pop	hl
F26B: C3E4F1  		jp	rdbuff
F26E: FE12    	rdbuf9:	cp	cntrlr		;control-r?
F270: C2A9F2  		jp	nz,rdbuf14
F273: C5      	rdbuf10:push	bc		;yes, start a new line and retype the old one.
F274: CDB4F1  		call	newline
F277: C1      		pop	bc
F278: E1      		pop	hl
F279: E5      		push	hl
F27A: C5      		push	bc
F27B: 78      	rdbuf11:ld	a,b		;done whole line yet?
F27C: B7      		or	a
F27D: CA8DF2  		jp	z,rdbuf12
F280: 23      		inc	hl		;nope, get next character.
F281: 4E      		ld	c,(hl)
F282: 05      		dec	b		;count it.
F283: C5      		push	bc
F284: E5      		push	hl
F285: CD82F1  		call	showit		;and display it.
F288: E1      		pop	hl
F289: C1      		pop	bc
F28A: C37BF2  		jp	rdbuf11
F28D: E5      	rdbuf12:push	hl		;done with line. if we were displaying
F28E: 3A0DF3  		ld	a,(outflag)	;then update cursor position.
F291: B7      		or	a
F292: CAF4F1  		jp	z,rdbuf2
F295: 210FF3  		ld	hl,curpos	;because this line is shorter, we must
F298: 96      		sub	(hl)		;back up the cursor (not the screen however)
F299: 320DF3  		ld	(outflag),a	;some number of positions.
F29C: CDA7F1  	rdbuf13:call	backup		;note that as long as (outflag) is non
F29F: 210DF3  		ld	hl,outflag	;zero, the screen will not be changed.
F2A2: 35      		dec	(hl)
F2A3: C29CF2  		jp	nz,rdbuf13
F2A6: C3F4F1  		jp	rdbuf2		;now just get the next character.
              	;
              	;   just a normal character, put this in our buffer and echo.
              	;
F2A9: 23      	rdbuf14:inc	hl
F2AA: 77      		ld	(hl),a		;store character.
F2AB: 04      		inc	b		;and count it.
F2AC: C5      	rdbuf15:push	bc
F2AD: E5      		push	hl
F2AE: 4F      		ld	c,a		;echo it now.
F2AF: CD82F1  		call	showit
F2B2: E1      		pop	hl
F2B3: C1      		pop	bc
F2B4: 7E      		ld	a,(hl)		;was it an abort request?
F2B5: FE03    		cp	cntrlc		;control-c abort?
F2B7: 78      		ld	a,b
F2B8: C2C0F2  		jp	nz,rdbuf16
F2BB: FE01    		cp	1		;only if at start of line.
F2BD: CA0000  		jp	z,0
F2C0: B9      	rdbuf16:cp	c		;nope, have we filled the buffer?
F2C1: DAF2F1  		jp	c,rdbuf1
F2C4: E1      	rdbuf17:pop	hl		;yes end the line and return.
F2C5: 70      		ld	(hl),b
F2C6: 0E0D    		ld	c,cr
F2C8: C34BF1  		jp	outchar		;output (cr) and return.
              	;
              	;   function to get a character from the console device.
              	;
F2CB: CD09F1  	getcon:	call	getecho		;get and echo.
F2CE: C304F3  		jp	setstat		;save status and return.
              	;
              	;   function to get a character from the tape reader device.
              	;
F2D1: CD16FE  	getrdr:	call	reader		;get a character from reader, set status and return.
F2D4: C304F3  		jp	setstat
              	;
              	;  function to perform direct console i/o. if (c) contains (ff)
              	; then this is an input request. if (c) contains (fe) then
              	; this is a status request. otherwise we are to output (c).
              	;
F2D7: 79      	dircio:	ld	a,c		;test for (ff).
F2D8: 3C      		inc	a
F2D9: CAE3F2  		jp	z,dirc1
F2DC: 3C      		inc	a		;test for (fe).
F2DD: CA07FE  		jp	z,const
F2E0: C30DFE  		jp	conout		;just output (c).
F2E3: CD07FE  	dirc1:	call	const		;this is an input request.
F2E6: B7      		or	a
F2E7: CA94FD  		jp	z,goback1	;not ready? just return (directly).
F2EA: CD0AFE  		call	conin		;yes, get character.
F2ED: C304F3  		jp	setstat		;set status and return.
              	;
              	;   function to return the i/o byte.
              	;
F2F0: 3A0300  	getiob:	ld	a,(iobyte)
F2F3: C304F3  		jp	setstat
              	;
              	;   function to set the i/o byte.
              	;
F2F6: 210300  	setiob:	ld	hl,iobyte
F2F9: 71      		ld	(hl),c
F2FA: C9      		ret	
              	;
              	;   function to print the character string pointed to by (de)
              	; on the console device. the string ends with a '$'.
              	;
F2FB: EB      	prtstr:	ex	de,hl
F2FC: 4D      		ld	c,l
F2FD: 44      		ld	b,h		;now (bc) points to it.
F2FE: C3D6F1  		jp	prtmesg
              	;
              	;   function to interigate the console device.
              	;
F301: CD26F1  	getcsts:call	ckconsol
              	;
              	;   get here to set the status and return to the cleanup
              	; section. then back to the user.
              	;
F304: 3248F3  	setstat:ld	(status),a
F307: C9      	rtn:	ret	
              	;
              	;   set the status to 1 (read or write error code).
              	;
F308: 3E01    	ioerr1:	ld	a,1
F30A: C304F3  		jp	setstat
              	;
F30D: 00      	outflag:defb	0		;output flag (non zero means no output).
F30E: 02      	starting: defb	2		;starting position for cursor.
F30F: 00      	curpos:	defb	0		;cursor position (0=start of line).
F310: 00      	prtflag:defb	0		;printer flag (control-p toggle). list if non zero.
F311: 00      	charbuf:defb	0		;single input character buffer.
              	;
              	;   stack area for bdos calls.
              	;
F312: 0000    	usrstack: defw	0		;save users stack pointer here.
              	;
F314: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F318: 00...   	
F32C: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F330: 00...   	
F344:         	stkarea equ	$		;end of stack area.
              	;
F344: 00      	userno:	defb	0		;current user number.
F345: 00      	active:	defb	0		;currently active drive.
F346: 0000    	params:	defw	0		;save (de) parameters here on entry.
F348: 0000    	status:	defw	0		;status returned from bdos function.
              	;
              	;   select error occured, jump to error routine.
              	;
F34A: 210EF0  	slcterr:ld	hl,badslct
              	;
              	;   jump to (hl) indirectly.
              	;
F34D: 5E      	jumphl:	ld	e,(hl)
F34E: 23      		inc	hl
F34F: 56      		ld	d,(hl)		;now (de) contain the desired address.
F350: EB      		ex	de,hl
F351: E9      		jp	(hl)
              	;
              	;   block move. (de) to (hl), (c) bytes total.
              	;
F352: 0C      	de2hl:	inc	c		;is count down to zero?
F353: 0D      	de2hl1:	dec	c
F354: C8      		ret	z		;yes, we are done.
F355: 1A      		ld	a,(de)		;no, move one more byte.
F356: 77      		ld	(hl),a
F357: 13      		inc	de
F358: 23      		inc	hl
F359: C353F3  		jp	de2hl1		;and repeat.
              	;
              	;   select the desired drive.
              	;
F35C: 3A45F3  	select:	ld	a,(active)	;get active disk.
F35F: 4F      		ld	c,a
F360: CD1CFE  		call	seldsk		;select it.
F363: 7C      		ld	a,h		;valid drive?
F364: B5      		or	l		;valid drive?
F365: C8      		ret	z		;return if not.
              	;
              	;   here, the bios returned the address of the parameter block
              	; in (hl). we will extract the necessary pointers and save them.
              	;
F366: 5E      		ld	e,(hl)		;yes, get address of translation table into (de).
F367: 23      		inc	hl
F368: 56      		ld	d,(hl)
F369: 23      		inc	hl
F36A: 22B6FD  		ld	(scratch1),hl	;save pointers to scratch areas.
F36D: 23      		inc	hl
F36E: 23      		inc	hl
F36F: 22B8FD  		ld	(scratch2),hl	;ditto.
F372: 23      		inc	hl
F373: 23      		inc	hl
F374: 22BAFD  		ld	(scratch3),hl	;ditto.
F377: 23      		inc	hl
F378: 23      		inc	hl
F379: EB      		ex	de,hl		;now save the translation table address.
F37A: 22D3FD  		ld	(xlate),hl
F37D: 21BCFD  		ld	hl,dirbuf	;put the next 8 bytes here.
F380: 0E08    		ld	c,8		;they consist of the directory buffer
F382: CD52F3  		call	de2hl		;pointer, parameter block pointer,
F385: 2ABEFD  		ld	hl,(diskpb)	;check and allocation vectors.
F388: EB      		ex	de,hl
F389: 21C4FD  		ld	hl,sectors	;move parameter block into our ram.
F38C: 0E0F    		ld	c,15		;it is 15 bytes long.
F38E: CD52F3  		call	de2hl
F391: 2AC9FD  		ld	hl,(dsksize)	;check disk size.
F394: 7C      		ld	a,h		;more than 256 blocks on this?
F395: 21E0FD  		ld	hl,bigdisk
F398: 36FF    		ld	(hl),0ffh	;set to samll.
F39A: B7      		or	a
F39B: CAA0F3  		jp	z,select1
F39E: 3600    		ld	(hl),0		;wrong, set to large.
F3A0: 3EFF    	select1:ld	a,0ffh		;clear the zero flag.
F3A2: B7      		or	a
F3A3: C9      		ret	
              	;
              	;   routine to home the disk track head and clear pointers.
              	;
F3A4: CD19FE  	homedrv:call	home		;home the head.
F3A7: AF      		xor	a
F3A8: 2AB8FD  		ld	hl,(scratch2)	;set our track pointer also.
F3AB: 77      		ld	(hl),a
F3AC: 23      		inc	hl
F3AD: 77      		ld	(hl),a
F3AE: 2ABAFD  		ld	hl,(scratch3)	;and our sector pointer.
F3B1: 77      		ld	(hl),a
F3B2: 23      		inc	hl
F3B3: 77      		ld	(hl),a
F3B4: C9      		ret	
              	;
              	;   do the actual disk read and check the error return status.
              	;
F3B5: CD28FE  	doread:	call	read
F3B8: C3BEF3  		jp	ioret
              	;
              	;   do the actual disk write and handle any bios error.
              	;
F3BB: CD2BFE  	dowrite:call	write
F3BE: B7      	ioret:	or	a
F3BF: C8      		ret	z		;return unless an error occured.
F3C0: 210CF0  		ld	hl,badsctr	;bad read/write on this sector.
F3C3: C34DF3  		jp	jumphl
              	;
              	;   routine to select the track and sector that the desired
              	; block number falls in.
              	;
F3C6: 2AEDFD  	trksec:	ld	hl,(filepos)	;get position of last accessed file
F3C9: 0E02    		ld	c,2		;in directory and compute sector #.
F3CB: CDEDF4  		call	shiftr		;sector #=file-position/4.
F3CE: 22E8FD  		ld	(blknmbr),hl	;save this as the block number of interest.
F3D1: 22EFFD  		ld	(cksumtbl),hl	;what's it doing here too?
              	;
              	;   if the sector number has already been set (blknmbr), enter
              	; at this point.
              	;
F3D4: 21E8FD  	trksec1:ld	hl,blknmbr
F3D7: 4E      		ld	c,(hl)		;move sector number into (bc).
F3D8: 23      		inc	hl
F3D9: 46      		ld	b,(hl)
F3DA: 2ABAFD  		ld	hl,(scratch3)	;get current sector number and
F3DD: 5E      		ld	e,(hl)		;move this into (de).
F3DE: 23      		inc	hl
F3DF: 56      		ld	d,(hl)
F3E0: 2AB8FD  		ld	hl,(scratch2)	;get current track number.
F3E3: 7E      		ld	a,(hl)		;and this into (hl).
F3E4: 23      		inc	hl
F3E5: 66      		ld	h,(hl)
F3E6: 6F      		ld	l,a
F3E7: 79      	trksec2:ld	a,c		;is desired sector before current one?
F3E8: 93      		sub	e
F3E9: 78      		ld	a,b
F3EA: 9A      		sbc	a,d
F3EB: D2FDF3  		jp	nc,trksec3
F3EE: E5      		push	hl		;yes, decrement sectors by one track.
F3EF: 2AC4FD  		ld	hl,(sectors)	;get sectors per track.
F3F2: 7B      		ld	a,e
F3F3: 95      		sub	l
F3F4: 5F      		ld	e,a
F3F5: 7A      		ld	a,d
F3F6: 9C      		sbc	a,h
F3F7: 57      		ld	d,a		;now we have backed up one full track.
F3F8: E1      		pop	hl
F3F9: 2B      		dec	hl		;adjust track counter.
F3FA: C3E7F3  		jp	trksec2
F3FD: E5      	trksec3:push	hl		;desired sector is after current one.
F3FE: 2AC4FD  		ld	hl,(sectors)	;get sectors per track.
F401: 19      		add	hl,de		;bump sector pointer to next track.
F402: DA12F4  		jp	c,trksec4
F405: 79      		ld	a,c		;is desired sector now before current one?
F406: 95      		sub	l
F407: 78      		ld	a,b
F408: 9C      		sbc	a,h
F409: DA12F4  		jp	c,trksec4
F40C: EB      		ex	de,hl		;not yes, increment track counter
F40D: E1      		pop	hl		;and continue until it is.
F40E: 23      		inc	hl
F40F: C3FDF3  		jp	trksec3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
F412: E1      	trksec4:pop	hl		;get track number (hl).
F413: C5      		push	bc
F414: D5      		push	de
F415: E5      		push	hl
F416: EB      		ex	de,hl
F417: 2AD1FD  		ld	hl,(offset)	;adjust for first track offset.
F41A: 19      		add	hl,de
F41B: 44      		ld	b,h
F41C: 4D      		ld	c,l
F41D: CD1FFE  		call	settrk		;select this track.
F420: D1      		pop	de		;reset current track pointer.
F421: 2AB8FD  		ld	hl,(scratch2)
F424: 73      		ld	(hl),e
F425: 23      		inc	hl
F426: 72      		ld	(hl),d
F427: D1      		pop	de
F428: 2ABAFD  		ld	hl,(scratch3)	;reset the first sector on this track.
F42B: 73      		ld	(hl),e
F42C: 23      		inc	hl
F42D: 72      		ld	(hl),d
F42E: C1      		pop	bc
F42F: 79      		ld	a,c		;now subtract the desired one.
F430: 93      		sub	e		;to make it relative (1-# sectors/track).
F431: 4F      		ld	c,a
F432: 78      		ld	a,b
F433: 9A      		sbc	a,d
F434: 47      		ld	b,a
F435: 2AD3FD  		ld	hl,(xlate)	;translate this sector according to this table.
F438: EB      		ex	de,hl
F439: CD31FE  		call	sectrn		;let the bios translate it.
F43C: 4D      		ld	c,l
F43D: 44      		ld	b,h
F43E: C322FE  		jp	setsec		;and select it.
              	;
              	;   compute block number from record number (savnrec) and
              	; extent number (savext).
              	;
F441: 21C6FD  	getblock: ld	hl,blkshft	;get logical to physical conversion.
F444: 4E      		ld	c,(hl)		;note that this is base 2 log of ratio.
F445: 3AE6FD  		ld	a,(savnrec)	;get record number.
F448: B7      	getblk1:or	a		;compute (a)=(a)/2^blkshft.
F449: 1F      		rra	
F44A: 0D      		dec	c
F44B: C248F4  		jp	nz,getblk1
F44E: 47      		ld	b,a		;save result in (b).
F44F: 3E08    		ld	a,8
F451: 96      		sub	(hl)
F452: 4F      		ld	c,a		;compute (c)=8-blkshft.
F453: 3AE5FD  		ld	a,(savext)
F456: 0D      	getblk2:dec	c		;compute (a)=savext*2^(8-blkshft).
F457: CA5FF4  		jp	z,getblk3
F45A: B7      		or	a
F45B: 17      		rla	
F45C: C356F4  		jp	getblk2
F45F: 80      	getblk3:add	a,b
F460: C9      		ret	
              	;
              	;   routine to extract the (bc) block byte from the fcb pointed
              	; to by (params). if this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; number is returned in (hl).
              	;
F461: 2A46F3  	extblk:	ld	hl,(params)	;get fcb address.
F464: 111000  		ld	de,16		;block numbers start 16 bytes into fcb.
F467: 19      		add	hl,de
F468: 09      		add	hl,bc
F469: 3AE0FD  		ld	a,(bigdisk)	;are we using a big-disk?
F46C: B7      		or	a
F46D: CA74F4  		jp	z,extblk1
F470: 6E      		ld	l,(hl)		;no, extract an 8 bit number from the fcb.
F471: 2600    		ld	h,0
F473: C9      		ret	
F474: 09      	extblk1:add	hl,bc		;yes, extract a 16 bit number.
F475: 5E      		ld	e,(hl)
F476: 23      		inc	hl
F477: 56      		ld	d,(hl)
F478: EB      		ex	de,hl		;return in (hl).
F479: C9      		ret	
              	;
              	;   compute block number.
              	;
F47A: CD41F4  	comblk:	call	getblock
F47D: 4F      		ld	c,a
F47E: 0600    		ld	b,0
F480: CD61F4  		call	extblk
F483: 22E8FD  		ld	(blknmbr),hl
F486: C9      		ret	
              	;
              	;   check for a zero block number (unused).
              	;
F487: 2AE8FD  	chkblk:	ld	hl,(blknmbr)
F48A: 7D      		ld	a,l		;is it zero?
F48B: B4      		or	h
F48C: C9      		ret	
              	;
              	;   adjust physical block (blknmbr) and convert to logical
              	; sector (logsect). this is the starting sector of this block.
              	; the actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (blknmbr). this
              	; will still have to be adjusted for the track number.
              	;
F48D: 3AC6FD  	logical:ld	a,(blkshft)	;get log2(physical/logical sectors).
F490: 2AE8FD  		ld	hl,(blknmbr)	;get physical sector desired.
F493: 29      	logicl1:add	hl,hl		;compute logical sector number.
F494: 3D      		dec	a		;note logical sectors are 128 bytes long.
F495: C293F4  		jp	nz,logicl1
F498: 22EAFD  		ld	(logsect),hl	;save logical sector.
F49B: 3AC7FD  		ld	a,(blkmask)	;get block mask.
F49E: 4F      		ld	c,a
F49F: 3AE6FD  		ld	a,(savnrec)	;get next sector to access.
F4A2: A1      		and	c		;extract the relative position within physical block.
F4A3: B5      		or	l		;and add it too logical sector.
F4A4: 6F      		ld	l,a
F4A5: 22E8FD  		ld	(blknmbr),hl	;and store.
F4A8: C9      		ret	
              	;
              	;   set (hl) to point to extent byte in fcb.
              	;
F4A9: 2A46F3  	setext:	ld	hl,(params)
F4AC: 110C00  		ld	de,12		;it is the twelth byte.
F4AF: 19      		add	hl,de
F4B0: C9      		ret	
              	;
              	;   set (hl) to point to record count byte in fcb and (de) to
              	; next record number byte.
              	;
F4B1: 2A46F3  	sethlde:ld	hl,(params)
F4B4: 110F00  		ld	de,15		;record count byte (#15).
F4B7: 19      		add	hl,de
F4B8: EB      		ex	de,hl
F4B9: 211100  		ld	hl,17		;next record number (#32).
F4BC: 19      		add	hl,de
F4BD: C9      		ret	
              	;
              	;   save current file data from fcb.
              	;
F4BE: CDB1F4  	strdata:call	sethlde
F4C1: 7E      		ld	a,(hl)		;get and store record count byte.
F4C2: 32E6FD  		ld	(savnrec),a
F4C5: EB      		ex	de,hl
F4C6: 7E      		ld	a,(hl)		;get and store next record number byte.
F4C7: 32E4FD  		ld	(savnxt),a
F4CA: CDA9F4  		call	setext		;point to extent byte.
F4CD: 3AC8FD  		ld	a,(extmask)	;get extent mask.
F4D0: A6      		and	(hl)
F4D1: 32E5FD  		ld	(savext),a	;and save extent here.
F4D4: C9      		ret	
              	;
              	;   set the next record to access. if (mode) is set to 2, then
              	; the last record byte (savnrec) has the correct number to access.
              	; for sequential access, (mode) will be equal to 1.
              	;
F4D5: CDB1F4  	setnrec:call	sethlde
F4D8: 3AD8FD  		ld	a,(mode)	;get sequential flag (=1).
F4DB: FE02    		cp	2		;a 2 indicates that no adder is needed.
F4DD: C2E1F4  		jp	nz,stnrec1
F4E0: AF      		xor	a		;clear adder (random access?).
F4E1: 4F      	stnrec1:ld	c,a
F4E2: 3AE6FD  		ld	a,(savnrec)	;get last record number.
F4E5: 81      		add	a,c		;increment record count.
F4E6: 77      		ld	(hl),a		;and set fcb's next record byte.
F4E7: EB      		ex	de,hl
F4E8: 3AE4FD  		ld	a,(savnxt)	;get next record byte from storage.
F4EB: 77      		ld	(hl),a		;and put this into fcb as number of records used.
F4EC: C9      		ret	
              	;
              	;   shift (hl) right (c) bits.
              	;
F4ED: 0C      	shiftr:	inc	c
F4EE: 0D      	shiftr1:dec	c
F4EF: C8      		ret	z
F4F0: 7C      		ld	a,h
F4F1: B7      		or	a
F4F2: 1F      		rra	
F4F3: 67      		ld	h,a
F4F4: 7D      		ld	a,l
F4F5: 1F      		rra	
F4F6: 6F      		ld	l,a
F4F7: C3EEF4  		jp	shiftr1
              	;
              	;   compute the check-sum for the directory buffer. return
              	; integer sum in (a).
              	;
F4FA: 0E80    	checksum: ld	c,128		;length of buffer.
F4FC: 2ABCFD  		ld	hl,(dirbuf)	;get its location.
F4FF: AF      		xor	a		;clear summation byte.
F500: 86      	chksum1:add	a,(hl)		;and compute sum ignoring carries.
F501: 23      		inc	hl
F502: 0D      		dec	c
F503: C200F5  		jp	nz,chksum1
F506: C9      		ret	
              	;
              	;   shift (hl) left (c) bits.
              	;
F507: 0C      	shiftl:	inc	c
F508: 0D      	shiftl1:dec	c
F509: C8      		ret	z
F50A: 29      		add	hl,hl		;shift left 1 bit.
F50B: C308F5  		jp	shiftl1
              	;
              	;   routine to set a bit in a 16 bit value contained in (bc).
              	; the bit set depends on the current drive selection.
              	;
F50E: C5      	setbit:	push	bc		;save 16 bit word.
F50F: 3A45F3  		ld	a,(active)	;get active drive.
F512: 4F      		ld	c,a
F513: 210100  		ld	hl,1
F516: CD07F5  		call	shiftl		;shift bit 0 into place.
F519: C1      		pop	bc		;now 'or' this with the original word.
F51A: 79      		ld	a,c
F51B: B5      		or	l
F51C: 6F      		ld	l,a		;low byte done, do high byte.
F51D: 78      		ld	a,b
F51E: B4      		or	h
F51F: 67      		ld	h,a
F520: C9      		ret	
              	;
              	;   extract the write protect status bit for the current drive.
              	; the result is returned in (a), bit 0.
              	;
F521: 2AB0FD  	getwprt:ld	hl,(wrtprt)	;get status bytes.
F524: 3A45F3  		ld	a,(active)	;which drive is current?
F527: 4F      		ld	c,a
F528: CDEDF4  		call	shiftr		;shift status such that bit 0 is the
F52B: 7D      		ld	a,l		;one of interest for this drive.
F52C: E601    		and	01h		;and isolate it.
F52E: C9      		ret	
              	;
              	;   function to write protect the current disk.
              	;
F52F: 21B0FD  	wrtprtd:ld	hl,wrtprt	;point to status word.
F532: 4E      		ld	c,(hl)		;set (bc) equal to the status.
F533: 23      		inc	hl
F534: 46      		ld	b,(hl)
F535: CD0EF5  		call	setbit		;and set this bit according to current drive.
F538: 22B0FD  		ld	(wrtprt),hl	;then save.
F53B: 2ACBFD  		ld	hl,(dirsize)	;now save directory size limit.
F53E: 23      		inc	hl		;remember the last one.
F53F: EB      		ex	de,hl
F540: 2AB6FD  		ld	hl,(scratch1)	;and store it here.
F543: 73      		ld	(hl),e		;put low byte.
F544: 23      		inc	hl
F545: 72      		ld	(hl),d		;then high byte.
F546: C9      		ret	
              	;
              	;   check for a read only file.
              	;
F547: CD61F5  	chkrofl:call	fcb2hl		;set (hl) to file entry in directory buffer.
F54A: 110900  	ckrof1:	ld	de,9		;look at bit 7 of the ninth byte.
F54D: 19      		add	hl,de
F54E: 7E      		ld	a,(hl)
F54F: 17      		rla	
F550: D0      		ret	nc		;return if ok.
F551: 2112F0  		ld	hl,rofile	;else, print error message and terminate.
F554: C34DF3  		jp	jumphl
              	;
              	;   check the write protect status of the active disk.
              	;
F557: CD21F5  	chkwprt:call	getwprt
F55A: C8      		ret	z		;return if ok.
F55B: 2110F0  		ld	hl,rodisk	;else print message and terminate.
F55E: C34DF3  		jp	jumphl
              	;
              	;   routine to set (hl) pointing to the proper entry in the
              	; directory buffer.
              	;
F561: 2ABCFD  	fcb2hl:	ld	hl,(dirbuf)	;get address of buffer.
F564: 3AECFD  		ld	a,(fcbpos)	;relative position of file.
              	;
              	;   routine to add (a) to (hl).
              	;
F567: 85      	adda2hl:add	a,l
F568: 6F      		ld	l,a
F569: D0      		ret	nc
F56A: 24      		inc	h		;take care of any carry.
F56B: C9      		ret	
              	;
              	;   routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
F56C: 2A46F3  	gets2:	ld	hl,(params)	;get address of fcb.
F56F: 110E00  		ld	de,14		;relative position of 's2'.
F572: 19      		add	hl,de
F573: 7E      		ld	a,(hl)		;extract this byte.
F574: C9      		ret	
              	;
              	;   clear the 's2' byte in the fcb.
              	;
F575: CD6CF5  	clears2:call	gets2		;this sets (hl) pointing to it.
F578: 3600    		ld	(hl),0		;now clear it.
F57A: C9      		ret	
              	;
              	;   set bit 7 in the 's2' byte of the fcb.
              	;
F57B: CD6CF5  	sets2b7:call	gets2		;get the byte.
F57E: F680    		or	80h		;and set bit 7.
F580: 77      		ld	(hl),a		;then store.
F581: C9      		ret	
              	;
              	;   compare (filepos) with (scratch1) and set flags based on
              	; the difference. this checks to see if there are more file
              	; names in the directory. we are at (filepos) and there are
              	; (scratch1) of them to check.
              	;
F582: 2AEDFD  	morefls:ld	hl,(filepos)	;we are here.
F585: EB      		ex	de,hl
F586: 2AB6FD  		ld	hl,(scratch1)	;and don't go past here.
F589: 7B      		ld	a,e		;compute difference but don't keep.
F58A: 96      		sub	(hl)
F58B: 23      		inc	hl
F58C: 7A      		ld	a,d
F58D: 9E      		sbc	a,(hl)		;set carry if no more names.
F58E: C9      		ret	
              	;
              	;   call this routine to prevent (scratch1) from being greater
              	; than (filepos).
              	;
F58F: CD82F5  	chknmbr:call	morefls		;scratch1 too big?
F592: D8      		ret	c
F593: 13      		inc	de		;yes, reset it to (filepos).
F594: 72      		ld	(hl),d
F595: 2B      		dec	hl
F596: 73      		ld	(hl),e
F597: C9      		ret	
              	;
              	;   compute (hl)=(de)-(hl)
              	;
F598: 7B      	subhl:	ld	a,e		;compute difference.
F599: 95      		sub	l
F59A: 6F      		ld	l,a		;store low byte.
F59B: 7A      		ld	a,d
F59C: 9C      		sbc	a,h
F59D: 67      		ld	h,a		;and then high byte.
F59E: C9      		ret	
              	;
              	;   set the directory checksum byte.
              	;
F59F: 0EFF    	setdir:	ld	c,0ffh
              	;
              	;   routine to set or compare the directory checksum byte. if
              	; (c)=0ffh, then this will set the checksum byte. else the byte
              	; will be checked. if the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
F5A1: 2AEFFD  	checkdir: ld	hl,(cksumtbl)
F5A4: EB      		ex	de,hl
F5A5: 2ACFFD  		ld	hl,(alloc1)
F5A8: CD98F5  		call	subhl
F5AB: D0      		ret	nc		;ok if (cksumtbl) > (alloc1), so return.
F5AC: C5      		push	bc
F5AD: CDFAF4  		call	checksum	;else compute checksum.
F5B0: 2AC0FD  		ld	hl,(chkvect)	;get address of checksum table.
F5B3: EB      		ex	de,hl
F5B4: 2AEFFD  		ld	hl,(cksumtbl)
F5B7: 19      		add	hl,de		;set (hl) to point to byte for this drive.
F5B8: C1      		pop	bc
F5B9: 0C      		inc	c		;set or check ?
F5BA: CAC7F5  		jp	z,chkdir1
F5BD: BE      		cp	(hl)		;check them.
F5BE: C8      		ret	z		;return if they are the same.
F5BF: CD82F5  		call	morefls		;not the same, do we care?
F5C2: D0      		ret	nc
F5C3: CD2FF5  		call	wrtprtd		;yes, mark this as write protected.
F5C6: C9      		ret	
F5C7: 77      	chkdir1:ld	(hl),a		;just set the byte.
F5C8: C9      		ret	
              	;
              	;   do a write to the directory of the current disk.
              	;
F5C9: CD9FF5  	dirwrite: call	setdir		;set checksum byte.
F5CC: CDE3F5  		call	dirdma		;set directory dma address.
F5CF: 0E01    		ld	c,1		;tell the bios to actually write.
F5D1: CDBBF3  		call	dowrite		;then do the write.
F5D4: C3DDF5  		jp	defdma
              	;
              	;   read from the directory.
              	;
F5D7: CDE3F5  	dirread:call	dirdma		;set the directory dma address.
F5DA: CDB5F3  		call	doread		;and read it.
              	;
              	;   routine to set the dma address to the users choice.
              	;
F5DD: 21B4FD  	defdma:	ld	hl,userdma	;reset the default dma address and return.
F5E0: C3E6F5  		jp	dirdma1
              	;
              	;   routine to set the dma address for directory work.
              	;
F5E3: 21BCFD  	dirdma:	ld	hl,dirbuf
              	;
              	;   set the dma address. on entry, (hl) points to
              	; word containing the desired dma address.
              	;
F5E6: 4E      	dirdma1:ld	c,(hl)
F5E7: 23      		inc	hl
F5E8: 46      		ld	b,(hl)		;setup (bc) and go to the bios to set it.
F5E9: C325FE  		jp	setdma
              	;
              	;   move the directory buffer into user's dma space.
              	;
F5EC: 2ABCFD  	movedir:ld	hl,(dirbuf)	;buffer is located here, and
F5EF: EB      		ex	de,hl
F5F0: 2AB4FD  		ld	hl,(userdma)	; put it here.
F5F3: 0E80    		ld	c,128		;this is its length.
F5F5: C352F3  		jp	de2hl		;move it now and return.
              	;
              	;   check (filepos) and set the zero flag if it equals 0ffffh.
              	;
F5F8: 21EDFD  	ckfilpos: ld	hl,filepos
F5FB: 7E      		ld	a,(hl)
F5FC: 23      		inc	hl
F5FD: BE      		cp	(hl)		;are both bytes the same?
F5FE: C0      		ret	nz
F5FF: 3C      		inc	a		;yes, but are they each 0ffh?
F600: C9      		ret	
              	;
              	;   set location (filepos) to 0ffffh.
              	;
F601: 21FFFF  	stfilpos: ld	hl,0ffffh
F604: 22EDFD  		ld	(filepos),hl
F607: C9      		ret	
              	;
              	;   move on to the next file position within the current
              	; directory buffer. if no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. enter with (c)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
F608: 2ACBFD  	nxentry:ld	hl,(dirsize)	;get directory entry size limit.
F60B: EB      		ex	de,hl
F60C: 2AEDFD  		ld	hl,(filepos)	;get current count.
F60F: 23      		inc	hl		;go on to the next one.
F610: 22EDFD  		ld	(filepos),hl
F613: CD98F5  		call	subhl		;(hl)=(dirsize)-(filepos)
F616: D21CF6  		jp	nc,nxent1	;is there more room left?
F619: C301F6  		jp	stfilpos	;no. set this flag and return.
F61C: 3AEDFD  	nxent1:	ld	a,(filepos)	;get file position within directory.
F61F: E603    		and	03h		;only look within this sector (only 4 entries fit).
F621: 0605    		ld	b,5		;convert to relative position (32 bytes each).
F623: 87      	nxent2:	add	a,a		;note that this is not efficient code.
F624: 05      		dec	b		;5 'add a's would be better.
F625: C223F6  		jp	nz,nxent2
F628: 32ECFD  		ld	(fcbpos),a	;save it as position of fcb.
F62B: B7      		or	a
F62C: C0      		ret	nz		;return if we are within buffer.
F62D: C5      		push	bc
F62E: CDC6F3  		call	trksec		;we need the next directory sector.
F631: CDD7F5  		call	dirread
F634: C1      		pop	bc
F635: C3A1F5  		jp	checkdir
              	;
              	;   routine to to get a bit from the disk space allocation
              	; map. it is returned in (a), bit position 0. on entry to here,
              	; set (bc) to the block number on the disk to check.
              	; on return, (d) will contain the original bit position for
              	; this block number and (hl) will point to the address for it.
              	;
F638: 79      	ckbitmap: ld	a,c		;determine bit number of interest.
F639: E607    		and	07h		;compute (d)=(e)=(c and 7)+1.
F63B: 3C      		inc	a
F63C: 5F      		ld	e,a		;save particular bit number.
F63D: 57      		ld	d,a
              	;
              	;   compute (bc)=(bc)/8.
              	;
F63E: 79      		ld	a,c
F63F: 0F      		rrca			;now shift right 3 bits.
F640: 0F      		rrca	
F641: 0F      		rrca	
F642: E61F    		and	1fh		;and clear bits 7,6,5.
F644: 4F      		ld	c,a
F645: 78      		ld	a,b
F646: 87      		add	a,a		;now shift (b) into bits 7,6,5.
F647: 87      		add	a,a
F648: 87      		add	a,a
F649: 87      		add	a,a
F64A: 87      		add	a,a
F64B: B1      		or	c		;and add in (c).
F64C: 4F      		ld	c,a		;ok, (c) ha been completed.
F64D: 78      		ld	a,b		;is there a better way of doing this?
F64E: 0F      		rrca	
F64F: 0F      		rrca	
F650: 0F      		rrca	
F651: E61F    		and	1fh
F653: 47      		ld	b,a		;and now (b) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
F654: 2AC2FD  		ld	hl,(alocvect)
F657: 09      		add	hl,bc
F658: 7E      		ld	a,(hl)		;now get correct byte.
F659: 07      	ckbmap1:rlca			;get correct bit into position 0.
F65A: 1D      		dec	e
F65B: C259F6  		jp	nz,ckbmap1
F65E: C9      		ret	
              	;
              	;   set or clear the bit map such that block number (bc) will be marked
              	; as used. on entry, if (e)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
F65F: D5      	stbitmap: push	de
F660: CD38F6  		call	ckbitmap	;get the byte of interest.
F663: E6FE    		and	0feh		;clear the affected bit.
F665: C1      		pop	bc
F666: B1      		or	c		;and now set it acording to (c).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (a) contains the value, (d) contains the bit
              	; position (1-8), and (hl) points to the address within the
              	; space allocation table for this byte.
              	;
F667: 0F      	stbmap1:rrca			;restore original bit position.
F668: 15      		dec	d
F669: C267F6  		jp	nz,stbmap1
F66C: 77      		ld	(hl),a		;and stor byte in table.
F66D: C9      		ret	
              	;
              	;   set/clear space used bits in allocation map for this file.
              	; on entry, (c)=1 to set the map and (c)=0 to clear it.
              	;
F66E: CD61F5  	setfile:call	fcb2hl		;get address of fcb
F671: 111000  		ld	de,16
F674: 19      		add	hl,de		;get to block number bytes.
F675: C5      		push	bc
F676: 0E11    		ld	c,17		;check all 17 bytes (max) of table.
F678: D1      	setfl1:	pop	de
F679: 0D      		dec	c		;done all bytes yet?
F67A: C8      		ret	z
F67B: D5      		push	de
F67C: 3AE0FD  		ld	a,(bigdisk)	;check disk size for 16 bit block numbers.
F67F: B7      		or	a
F680: CA8BF6  		jp	z,setfl2
F683: C5      		push	bc		;only 8 bit numbers. set (bc) to this one.
F684: E5      		push	hl
F685: 4E      		ld	c,(hl)		;get low byte from table, always
F686: 0600    		ld	b,0		;set high byte to zero.
F688: C391F6  		jp	setfl3
F68B: 0D      	setfl2:	dec	c		;for 16 bit block numbers, adjust counter.
F68C: C5      		push	bc
F68D: 4E      		ld	c,(hl)		;now get both the low and high bytes.
F68E: 23      		inc	hl
F68F: 46      		ld	b,(hl)
F690: E5      		push	hl
F691: 79      	setfl3:	ld	a,c		;block used?
F692: B0      		or	b
F693: CAA0F6  		jp	z,setfl4
F696: 2AC9FD  		ld	hl,(dsksize)	;is this block number within the
F699: 7D      		ld	a,l		;space on the disk?
F69A: 91      		sub	c
F69B: 7C      		ld	a,h
F69C: 98      		sbc	a,b
F69D: D45FF6  		call	nc,stbitmap	;yes, set the proper bit.
F6A0: E1      	setfl4:	pop	hl		;point to next block number in fcb.
F6A1: 23      		inc	hl
F6A2: C1      		pop	bc
F6A3: C378F6  		jp	setfl1
              	;
              	;   construct the space used allocation bit map for the active
              	; drive. if a file name starts with '$' and it is under the
              	; current user number, then (status) is set to minus 1. otherwise
              	; it is not set at all.
              	;
F6A6: 2AC9FD  	bitmap:	ld	hl,(dsksize)	;compute size of allocation table.
F6A9: 0E03    		ld	c,3
F6AB: CDEDF4  		call	shiftr		;(hl)=(hl)/8.
F6AE: 23      		inc	hl		;at lease 1 byte.
F6AF: 44      		ld	b,h
F6B0: 4D      		ld	c,l		;set (bc) to the allocation table length.
              	;
              	;   initialize the bitmap for this drive. right now, the first
              	; two bytes are specified by the disk parameter block. however
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. for example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
F6B1: 2AC2FD  		ld	hl,(alocvect)	;now zero out the table now.
F6B4: 3600    	bitmap1:ld	(hl),0
F6B6: 23      		inc	hl
F6B7: 0B      		dec	bc
F6B8: 78      		ld	a,b
F6B9: B1      		or	c
F6BA: C2B4F6  		jp	nz,bitmap1
F6BD: 2ACDFD  		ld	hl,(alloc0)	;get initial space used by directory.
F6C0: EB      		ex	de,hl
F6C1: 2AC2FD  		ld	hl,(alocvect)	;and put this into map.
F6C4: 73      		ld	(hl),e
F6C5: 23      		inc	hl
F6C6: 72      		ld	(hl),d
              	;
              	;   end of initialization portion.
              	;
F6C7: CDA4F3  		call	homedrv		;now home the drive.
F6CA: 2AB6FD  		ld	hl,(scratch1)
F6CD: 3603    		ld	(hl),3		;force next directory request to read
F6CF: 23      		inc	hl		;in a sector.
F6D0: 3600    		ld	(hl),0
F6D2: CD01F6  		call	stfilpos	;clear initial file position also.
F6D5: 0EFF    	bitmap2:ld	c,0ffh		;read next file name in directory
F6D7: CD08F6  		call	nxentry		;and set checksum byte.
F6DA: CDF8F5  		call	ckfilpos	;is there another file?
F6DD: C8      		ret	z
F6DE: CD61F5  		call	fcb2hl		;yes, get its address.
F6E1: 3EE5    		ld	a,0e5h
F6E3: BE      		cp	(hl)		;empty file entry?
F6E4: CAD5F6  		jp	z,bitmap2
F6E7: 3A44F3  		ld	a,(userno)	;no, correct user number?
F6EA: BE      		cp	(hl)
F6EB: C2F9F6  		jp	nz,bitmap3
F6EE: 23      		inc	hl
F6EF: 7E      		ld	a,(hl)		;yes, does name start with a '$'?
F6F0: D624    		sub	'$'
F6F2: C2F9F6  		jp	nz,bitmap3
F6F5: 3D      		dec	a		;yes, set atatus to minus one.
F6F6: 3248F3  		ld	(status),a
F6F9: 0E01    	bitmap3:ld	c,1		;now set this file's space as used in bit map.
F6FB: CD6EF6  		call	setfile
F6FE: CD8FF5  		call	chknmbr		;keep (scratch1) in bounds.
F701: C3D5F6  		jp	bitmap2
              	;
              	;   set the status (status) and return.
              	;
F704: 3AD7FD  	ststatus: ld	a,(fndstat)
F707: C304F3  		jp	setstat
              	;
              	;   check extents in (a) and (c). set the zero flag if they
              	; are the same. the number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (extmask+1).
              	; no registers are modified.
              	;
F70A: C5      	samext:	push	bc
F70B: F5      		push	af
F70C: 3AC8FD  		ld	a,(extmask)	;get extent mask and use it to
F70F: 2F      		cpl			;to compare both extent numbers.
F710: 47      		ld	b,a		;save resulting mask here.
F711: 79      		ld	a,c		;mask first extent and save in (c).
F712: A0      		and	b
F713: 4F      		ld	c,a
F714: F1      		pop	af		;now mask second extent and compare
F715: A0      		and	b		;with the first one.
F716: 91      		sub	c
F717: E61F    		and	1fh		;(* only check buts 0-4 *)
F719: C1      		pop	bc		;the zero flag is set if they are the same.
F71A: C9      		ret			;restore (bc) and return.
              	;
              	;   search for the first occurence of a file name. on entry,
              	; register (c) should contain the number of bytes of the fcb
              	; that must match.
              	;
F71B: 3EFF    	findfst:ld	a,0ffh
F71D: 32D7FD  		ld	(fndstat),a
F720: 21DBFD  		ld	hl,counter	;save character count.
F723: 71      		ld	(hl),c
F724: 2A46F3  		ld	hl,(params)	;get filename to match.
F727: 22DCFD  		ld	(savefcb),hl	;and save.
F72A: CD01F6  		call	stfilpos	;clear initial file position (set to 0ffffh).
F72D: CDA4F3  		call	homedrv		;home the drive.
              	;
              	;   entry to locate the next occurence of a filename within the
              	; directory. the disk is not expected to have been changed. if
              	; it was, then it will be write protected.
              	;
F730: 0E00    	findnxt:ld	c,0		;write protect the disk if changed.
F732: CD08F6  		call	nxentry		;get next filename entry in directory.
F735: CDF8F5  		call	ckfilpos	;is file position = 0ffffh?
F738: CA97F7  		jp	z,fndnxt6	;yes, exit now then.
F73B: 2ADCFD  		ld	hl,(savefcb)	;set (de) pointing to filename to match.
F73E: EB      		ex	de,hl
F73F: 1A      		ld	a,(de)
F740: FEE5    		cp	0e5h		;empty directory entry?
F742: CA4DF7  		jp	z,fndnxt1	;(* are we trying to reserect erased entries? *)
F745: D5      		push	de
F746: CD82F5  		call	morefls		;more files in directory?
F749: D1      		pop	de
F74A: D297F7  		jp	nc,fndnxt6	;no more. exit now.
F74D: CD61F5  	fndnxt1:call	fcb2hl		;get address of this fcb in directory.
F750: 3ADBFD  		ld	a,(counter)	;get number of bytes (characters) to check.
F753: 4F      		ld	c,a
F754: 0600    		ld	b,0		;initialize byte position counter.
F756: 79      	fndnxt2:ld	a,c		;are we done with the compare?
F757: B7      		or	a
F758: CA86F7  		jp	z,fndnxt5
F75B: 1A      		ld	a,(de)		;no, check next byte.
F75C: FE3F    		cp	'?'		;don't care about this character?
F75E: CA7FF7  		jp	z,fndnxt4
F761: 78      		ld	a,b		;get bytes position in fcb.
F762: FE0D    		cp	13		;don't care about the thirteenth byte either.
F764: CA7FF7  		jp	z,fndnxt4
F767: FE0C    		cp	12		;extent byte?
F769: 1A      		ld	a,(de)
F76A: CA76F7  		jp	z,fndnxt3
F76D: 96      		sub	(hl)		;otherwise compare characters.
F76E: E67F    		and	7fh
F770: C230F7  		jp	nz,findnxt	;not the same, check next entry.
F773: C37FF7  		jp	fndnxt4		;so far so good, keep checking.
F776: C5      	fndnxt3:push	bc		;check the extent byte here.
F777: 4E      		ld	c,(hl)
F778: CD0AF7  		call	samext
F77B: C1      		pop	bc
F77C: C230F7  		jp	nz,findnxt	;not the same, look some more.
              	;
              	;   so far the names compare. bump pointers to the next byte
              	; and continue until all (c) characters have been checked.
              	;
F77F: 13      	fndnxt4:inc	de		;bump pointers.
F780: 23      		inc	hl
F781: 04      		inc	b
F782: 0D      		dec	c		;adjust character counter.
F783: C356F7  		jp	fndnxt2
F786: 3AEDFD  	fndnxt5:ld	a,(filepos)	;return the position of this entry.
F789: E603    		and	03h
F78B: 3248F3  		ld	(status),a
F78E: 21D7FD  		ld	hl,fndstat
F791: 7E      		ld	a,(hl)
F792: 17      		rla	
F793: D0      		ret	nc
F794: AF      		xor	a
F795: 77      		ld	(hl),a
F796: C9      		ret	
              	;
              	;   filename was not found. set appropriate status.
              	;
F797: CD01F6  	fndnxt6:call	stfilpos	;set (filepos) to 0ffffh.
F79A: 3EFF    		ld	a,0ffh		;say not located.
F79C: C304F3  		jp	setstat
              	;
              	;   erase files from the directory. only the first byte of the
              	; fcb will be affected. it is set to (e5).
              	;
F79F: CD57F5  	erafile:call	chkwprt		;is disk write protected?
F7A2: 0E0C    		ld	c,12		;only compare file names.
F7A4: CD1BF7  		call	findfst		;get first file name.
F7A7: CDF8F5  	erafil1:call	ckfilpos	;any found?
F7AA: C8      		ret	z		;nope, we must be done.
F7AB: CD47F5  		call	chkrofl		;is file read only?
F7AE: CD61F5  		call	fcb2hl		;nope, get address of fcb and
F7B1: 36E5    		ld	(hl),0e5h	;set first byte to 'empty'.
F7B3: 0E00    		ld	c,0		;clear the space from the bit map.
F7B5: CD6EF6  		call	setfile
F7B8: CDC9F5  		call	dirwrite	;now write the directory sector back out.
F7BB: CD30F7  		call	findnxt		;find the next file name.
F7BE: C3A7F7  		jp	erafil1		;and repeat process.
              	;
              	;   look through the space allocation map (bit map) for the
              	; next available block. start searching at block number (bc-1).
              	; the search procedure is to look for an empty block that is
              	; before the starting block. if not empty, look at a later
              	; block number. in this way, we return the closest empty block
              	; on either side of the 'target' block number. this will speed
              	; access on random devices. for serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   on return, (de)= block number that is empty and (hl) =0
              	; if no empry block was found.
              	;
F7C1: 50      	fndspace: ld	d,b		;set (de) as the block that is checked.
F7C2: 59      		ld	e,c
              	;
              	;   look before target block. registers (bc) are used as the lower
              	; pointer and (de) as the upper pointer.
              	;
F7C3: 79      	fndspa1:ld	a,c		;is block 0 specified?
F7C4: B0      		or	b
F7C5: CAD4F7  		jp	z,fndspa2
F7C8: 0B      		dec	bc		;nope, check previous block.
F7C9: D5      		push	de
F7CA: C5      		push	bc
F7CB: CD38F6  		call	ckbitmap
F7CE: 1F      		rra			;is this block empty?
F7CF: D2EFF7  		jp	nc,fndspa3	;yes. use this.
              	;
              	;   note that the above logic gets the first block that it finds
              	; that is empty. thus a file could be written 'backward' making
              	; it very slow to access. this could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; this should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
F7D2: C1      		pop	bc		;nope, check some more.
F7D3: D1      		pop	de
              	;
              	;   now look after target block.
              	;
F7D4: 2AC9FD  	fndspa2:ld	hl,(dsksize)	;is block (de) within disk limits?
F7D7: 7B      		ld	a,e
F7D8: 95      		sub	l
F7D9: 7A      		ld	a,d
F7DA: 9C      		sbc	a,h
F7DB: D2F7F7  		jp	nc,fndspa4
F7DE: 13      		inc	de		;yes, move on to next one.
F7DF: C5      		push	bc
F7E0: D5      		push	de
F7E1: 42      		ld	b,d
F7E2: 4B      		ld	c,e
F7E3: CD38F6  		call	ckbitmap	;check it.
F7E6: 1F      		rra			;empty?
F7E7: D2EFF7  		jp	nc,fndspa3
F7EA: D1      		pop	de		;nope, continue searching.
F7EB: C1      		pop	bc
F7EC: C3C3F7  		jp	fndspa1
              	;
              	;   empty block found. set it as used and return with (hl)
              	; pointing to it (true?).
              	;
F7EF: 17      	fndspa3:rla			;reset byte.
F7F0: 3C      		inc	a		;and set bit 0.
F7F1: CD67F6  		call	stbmap1		;update bit map.
F7F4: E1      		pop	hl		;set return registers.
F7F5: D1      		pop	de
F7F6: C9      		ret	
              	;
              	;   free block was not found. if (bc) is not zero, then we have
              	; not checked all of the disk space.
              	;
F7F7: 79      	fndspa4:ld	a,c
F7F8: B0      		or	b
F7F9: C2C3F7  		jp	nz,fndspa1
F7FC: 210000  		ld	hl,0		;set 'not found' status.
F7FF: C9      		ret	
              	;
              	;   move a complete fcb entry into the directory and write it.
              	;
F800: 0E00    	fcbset:	ld	c,0
F802: 1E20    		ld	e,32		;length of each entry.
              	;
              	;   move (e) bytes from the fcb pointed to by (params) into
              	; fcb in directory starting at relative byte (c). this updated
              	; directory buffer is then written to the disk.
              	;
F804: D5      	update:	push	de
F805: 0600    		ld	b,0		;set (bc) to relative byte position.
F807: 2A46F3  		ld	hl,(params)	;get address of fcb.
F80A: 09      		add	hl,bc		;compute starting byte.
F80B: EB      		ex	de,hl
F80C: CD61F5  		call	fcb2hl		;get address of fcb to update in directory.
F80F: C1      		pop	bc		;set (c) to number of bytes to change.
F810: CD52F3  		call	de2hl
F813: CDC6F3  	update1:call	trksec		;determine the track and sector affected.
F816: C3C9F5  		jp	dirwrite	;then write this sector out.
              	;
              	;   routine to change the name of all files on the disk with a
              	; specified name. the fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
F819: CD57F5  	chgnames: call	chkwprt		;check for a write protected disk.
F81C: 0E0C    		ld	c,12		;match first 12 bytes of fcb only.
F81E: CD1BF7  		call	findfst		;get first name.
F821: 2A46F3  		ld	hl,(params)	;get address of fcb.
F824: 7E      		ld	a,(hl)		;get user number.
F825: 111000  		ld	de,16		;move over to desired name.
F828: 19      		add	hl,de
F829: 77      		ld	(hl),a		;keep same user number.
F82A: CDF8F5  	chgnam1:call	ckfilpos	;any matching file found?
F82D: C8      		ret	z		;no, we must be done.
F82E: CD47F5  		call	chkrofl		;check for read only file.
F831: 0E10    		ld	c,16		;start 16 bytes into fcb.
F833: 1E0C    		ld	e,12		;and update the first 12 bytes of directory.
F835: CD04F8  		call	update
F838: CD30F7  		call	findnxt		;get te next file name.
F83B: C32AF8  		jp	chgnam1		;and continue.
              	;
              	;   update a files attributes. the procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). no other changes
              	; are made.
              	;
F83E: 0E0C    	saveattr: ld	c,12		;match first 12 bytes.
F840: CD1BF7  		call	findfst		;look for first filename.
F843: CDF8F5  	savatr1:call	ckfilpos	;was one found?
F846: C8      		ret	z		;nope, we must be done.
F847: 0E00    		ld	c,0		;yes, update the first 12 bytes now.
F849: 1E0C    		ld	e,12
F84B: CD04F8  		call	update		;update filename and write directory.
F84E: CD30F7  		call	findnxt		;and get the next file.
F851: C343F8  		jp	savatr1		;then continue until done.
              	;
              	;  open a file (name specified in fcb).
              	;
F854: 0E0F    	openit:	ld	c,15		;compare the first 15 bytes.
F856: CD1BF7  		call	findfst		;get the first one in directory.
F859: CDF8F5  		call	ckfilpos	;any at all?
F85C: C8      		ret	z
F85D: CDA9F4  	openit1:call	setext		;point to extent byte within users fcb.
F860: 7E      		ld	a,(hl)		;and get it.
F861: F5      		push	af		;save it and address.
F862: E5      		push	hl
F863: CD61F5  		call	fcb2hl		;point to fcb in directory.
F866: EB      		ex	de,hl
F867: 2A46F3  		ld	hl,(params)	;this is the users copy.
F86A: 0E20    		ld	c,32		;move it into users space.
F86C: D5      		push	de
F86D: CD52F3  		call	de2hl
F870: CD7BF5  		call	sets2b7		;set bit 7 in 's2' byte (unmodified).
F873: D1      		pop	de		;now get the extent byte from this fcb.
F874: 210C00  		ld	hl,12
F877: 19      		add	hl,de
F878: 4E      		ld	c,(hl)		;into (c).
F879: 210F00  		ld	hl,15		;now get the record count byte into (b).
F87C: 19      		add	hl,de
F87D: 46      		ld	b,(hl)
F87E: E1      		pop	hl		;keep the same extent as the user had originally.
F87F: F1      		pop	af
F880: 77      		ld	(hl),a
F881: 79      		ld	a,c		;is it the same as in the directory fcb?
F882: BE      		cp	(hl)
F883: 78      		ld	a,b		;if yes, then use the same record count.
F884: CA8EF8  		jp	z,openit2
F887: 3E00    		ld	a,0		;if the user specified an extent greater than
F889: DA8EF8  		jp	c,openit2	;the one in the directory, then set record count to 0.
F88C: 3E80    		ld	a,128		;otherwise set to maximum.
F88E: 2A46F3  	openit2:ld	hl,(params)	;set record count in users fcb to (a).
F891: 110F00  		ld	de,15
F894: 19      		add	hl,de		;compute relative position.
F895: 77      		ld	(hl),a		;and set the record count.
F896: C9      		ret	
              	;
              	;   move two bytes from (de) to (hl) if (and only if) (hl)
              	; point to a zero value (16 bit).
              	;   return with zero flag set it (de) was moved. registers (de)
              	; and (hl) are not changed. however (a) is.
              	;
F897: 7E      	moveword: ld	a,(hl)		;check for a zero word.
F898: 23      		inc	hl
F899: B6      		or	(hl)		;both bytes zero?
F89A: 2B      		dec	hl
F89B: C0      		ret	nz		;nope, just return.
F89C: 1A      		ld	a,(de)		;yes, move two bytes from (de) into
F89D: 77      		ld	(hl),a		;this zero space.
F89E: 13      		inc	de
F89F: 23      		inc	hl
F8A0: 1A      		ld	a,(de)
F8A1: 77      		ld	(hl),a
F8A2: 1B      		dec	de		;don't disturb these registers.
F8A3: 2B      		dec	hl
F8A4: C9      		ret	
              	;
              	;   get here to close a file specified by (fcb).
              	;
F8A5: AF      	closeit:xor	a		;clear status and file position bytes.
F8A6: 3248F3  		ld	(status),a
F8A9: 32EDFD  		ld	(filepos),a
F8AC: 32EEFD  		ld	(filepos+1),a
F8AF: CD21F5  		call	getwprt		;get write protect bit for this drive.
F8B2: C0      		ret	nz		;just return if it is set.
F8B3: CD6CF5  		call	gets2		;else get the 's2' byte.
F8B6: E680    		and	80h		;and look at bit 7 (file unmodified?).
F8B8: C0      		ret	nz		;just return if set.
F8B9: 0E0F    		ld	c,15		;else look up this file in directory.
F8BB: CD1BF7  		call	findfst
F8BE: CDF8F5  		call	ckfilpos	;was it found?
F8C1: C8      		ret	z		;just return if not.
F8C2: 011000  		ld	bc,16		;set (hl) pointing to records used section.
F8C5: CD61F5  		call	fcb2hl
F8C8: 09      		add	hl,bc
F8C9: EB      		ex	de,hl
F8CA: 2A46F3  		ld	hl,(params)	;do the same for users specified fcb.
F8CD: 09      		add	hl,bc
F8CE: 0E10    		ld	c,16		;this many bytes are present in this extent.
F8D0: 3AE0FD  	closeit1: ld	a,(bigdisk)	;8 or 16 bit record numbers?
F8D3: B7      		or	a
F8D4: CAEBF8  		jp	z,closeit4
F8D7: 7E      		ld	a,(hl)		;just 8 bit. get one from users fcb.
F8D8: B7      		or	a
F8D9: 1A      		ld	a,(de)		;now get one from directory fcb.
F8DA: C2DEF8  		jp	nz,closeit2
F8DD: 77      		ld	(hl),a		;users byte was zero. update from directory.
F8DE: B7      	closeit2: or	a
F8DF: C2E4F8  		jp	nz,closeit3
F8E2: 7E      		ld	a,(hl)		;directories byte was zero, update from users fcb.
F8E3: 12      		ld	(de),a
F8E4: BE      	closeit3: cp	(hl)		;if neither one of these bytes were zero,
F8E5: C222F9  		jp	nz,closeit7	;then close error if they are not the same.
F8E8: C300F9  		jp	closeit5	;ok so far, get to next byte in fcbs.
F8EB: CD97F8  	closeit4: call	moveword	;update users fcb if it is zero.
F8EE: EB      		ex	de,hl
F8EF: CD97F8  		call	moveword	;update directories fcb if it is zero.
F8F2: EB      		ex	de,hl
F8F3: 1A      		ld	a,(de)		;if these two values are no different,
F8F4: BE      		cp	(hl)		;then a close error occured.
F8F5: C222F9  		jp	nz,closeit7
F8F8: 13      		inc	de		;check second byte.
F8F9: 23      		inc	hl
F8FA: 1A      		ld	a,(de)
F8FB: BE      		cp	(hl)
F8FC: C222F9  		jp	nz,closeit7
F8FF: 0D      		dec	c		;remember 16 bit values.
F900: 13      	closeit5: inc	de		;bump to next item in table.
F901: 23      		inc	hl
F902: 0D      		dec	c		;there are 16 entries only.
F903: C2D0F8  		jp	nz,closeit1	;continue if more to do.
F906: 01ECFF  		ld	bc,0ffech	;backup 20 places (extent byte).
F909: 09      		add	hl,bc
F90A: EB      		ex	de,hl
F90B: 09      		add	hl,bc
F90C: 1A      		ld	a,(de)
F90D: BE      		cp	(hl)		;directory's extent already greater than the
F90E: DA1AF9  		jp	c,closeit6	;users extent?
F911: 77      		ld	(hl),a		;no, update directory extent.
F912: 010300  		ld	bc,3		;and update the record count byte in
F915: 09      		add	hl,bc		;directories fcb.
F916: EB      		ex	de,hl
F917: 09      		add	hl,bc
F918: 7E      		ld	a,(hl)		;get from user.
F919: 12      		ld	(de),a		;and put in directory.
F91A: 3EFF    	closeit6: ld	a,0ffh		;set 'was open and is now closed' byte.
F91C: 32D5FD  		ld	(closeflg),a
F91F: C313F8  		jp	update1		;update the directory now.
F922: 2148F3  	closeit7: ld	hl,status	;set return status and then return.
F925: 35      		dec	(hl)
F926: C9      		ret	
              	;
              	;   routine to get the next empty space in the directory. it
              	; will then be cleared for use.
              	;
F927: CD57F5  	getempty: call	chkwprt		;make sure disk is not write protected.
F92A: 2A46F3  		ld	hl,(params)	;save current parameters (fcb).
F92D: E5      		push	hl
F92E: 21AFFD  		ld	hl,emptyfcb	;use special one for empty space.
F931: 2246F3  		ld	(params),hl
F934: 0E01    		ld	c,1		;search for first empty spot in directory.
F936: CD1BF7  		call	findfst		;(* only check first byte *)
F939: CDF8F5  		call	ckfilpos	;none?
F93C: E1      		pop	hl
F93D: 2246F3  		ld	(params),hl	;restore original fcb address.
F940: C8      		ret	z		;return if no more space.
F941: EB      		ex	de,hl
F942: 210F00  		ld	hl,15		;point to number of records for this file.
F945: 19      		add	hl,de
F946: 0E11    		ld	c,17		;and clear all of this space.
F948: AF      		xor	a
F949: 77      	getmt1:	ld	(hl),a
F94A: 23      		inc	hl
F94B: 0D      		dec	c
F94C: C249F9  		jp	nz,getmt1
F94F: 210D00  		ld	hl,13		;clear the 's1' byte also.
F952: 19      		add	hl,de
F953: 77      		ld	(hl),a
F954: CD8FF5  		call	chknmbr		;keep (scratch1) within bounds.
F957: CD00F8  		call	fcbset		;write out this fcb entry to directory.
F95A: C37BF5  		jp	sets2b7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   routine to close the current extent and open the next one
              	; for reading.
              	;
F95D: AF      	getnext:xor	a
F95E: 32D5FD  		ld	(closeflg),a	;clear close flag.
F961: CDA5F8  		call	closeit		;close this extent.
F964: CDF8F5  		call	ckfilpos
F967: C8      		ret	z		;not there???
F968: 2A46F3  		ld	hl,(params)	;get extent byte.
F96B: 010C00  		ld	bc,12
F96E: 09      		add	hl,bc
F96F: 7E      		ld	a,(hl)		;and increment it.
F970: 3C      		inc	a
F971: E61F    		and	1fh		;keep within range 0-31.
F973: 77      		ld	(hl),a
F974: CA86F9  		jp	z,gtnext1	;overflow?
F977: 47      		ld	b,a		;mask extent byte.
F978: 3AC8FD  		ld	a,(extmask)
F97B: A0      		and	b
F97C: 21D5FD  		ld	hl,closeflg	;check close flag (0ffh is ok).
F97F: A6      		and	(hl)
F980: CA91F9  		jp	z,gtnext2	;if zero, we must read in next extent.
F983: C3AFF9  		jp	gtnext3		;else, it is already in memory.
F986: 010200  	gtnext1:ld	bc,2		;point to the 's2' byte.
F989: 09      		add	hl,bc
F98A: 34      		inc	(hl)		;and bump it.
F98B: 7E      		ld	a,(hl)		;too many extents?
F98C: E60F    		and	0fh
F98E: CAB9F9  		jp	z,gtnext5	;yes, set error code.
              	;
              	;   get here to open the next extent.
              	;
F991: 0E0F    	gtnext2:ld	c,15		;set to check first 15 bytes of fcb.
F993: CD1BF7  		call	findfst		;find the first one.
F996: CDF8F5  		call	ckfilpos	;none available?
F999: C2AFF9  		jp	nz,gtnext3
F99C: 3AD6FD  		ld	a,(rdwrtflg)	;no extent present. can we open an empty one?
F99F: 3C      		inc	a		;0ffh means reading (so not possible).
F9A0: CAB9F9  		jp	z,gtnext5	;or an error.
F9A3: CD27F9  		call	getempty	;we are writing, get an empty entry.
F9A6: CDF8F5  		call	ckfilpos	;none?
F9A9: CAB9F9  		jp	z,gtnext5	;error if true.
F9AC: C3B2F9  		jp	gtnext4		;else we are almost done.
F9AF: CD5DF8  	gtnext3:call	openit1		;open this extent.
F9B2: CDBEF4  	gtnext4:call	strdata		;move in updated data (rec #, extent #, etc.)
F9B5: AF      		xor	a		;clear status and return.
F9B6: C304F3  		jp	setstat
              	;
              	;   error in extending the file. too many extents were needed
              	; or not enough space on the disk.
              	;
F9B9: CD08F3  	gtnext5:call	ioerr1		;set error code, clear bit 7 of 's2'
F9BC: C37BF5  		jp	sets2b7		;so this is not written on a close.
              	;
              	;   read a sequential file.
              	;
F9BF: 3E01    	rdseq:	ld	a,1		;set sequential access mode.
F9C1: 32D8FD  		ld	(mode),a
F9C4: 3EFF    	rdseq1:	ld	a,0ffh		;don't allow reading unwritten space.
F9C6: 32D6FD  		ld	(rdwrtflg),a
F9C9: CDBEF4  		call	strdata		;put rec# and ext# into fcb.
F9CC: 3AE6FD  		ld	a,(savnrec)	;get next record to read.
F9CF: 21E4FD  		ld	hl,savnxt	;get number of records in extent.
F9D2: BE      		cp	(hl)		;within this extent?
F9D3: DAE9F9  		jp	c,rdseq2
F9D6: FE80    		cp	128		;no. is this extent fully used?
F9D8: C2FEF9  		jp	nz,rdseq3	;no. end-of-file.
F9DB: CD5DF9  		call	getnext		;yes, open the next one.
F9DE: AF      		xor	a		;reset next record to read.
F9DF: 32E6FD  		ld	(savnrec),a
F9E2: 3A48F3  		ld	a,(status)	;check on open, successful?
F9E5: B7      		or	a
F9E6: C2FEF9  		jp	nz,rdseq3	;no, error.
F9E9: CD7AF4  	rdseq2:	call	comblk		;ok. compute block number to read.
F9EC: CD87F4  		call	chkblk		;check it. within bounds?
F9EF: CAFEF9  		jp	z,rdseq3	;no, error.
F9F2: CD8DF4  		call	logical		;convert (blknmbr) to logical sector (128 byte).
F9F5: CDD4F3  		call	trksec1		;set the track and sector for this block #.
F9F8: CDB5F3  		call	doread		;and read it.
F9FB: C3D5F4  		jp	setnrec		;and set the next record to be accessed.
              	;
              	;   read error occured. set status and return.
              	;
F9FE: C308F3  	rdseq3:	jp	ioerr1
              	;
              	;   write the next sequential record.
              	;
FA01: 3E01    	wtseq:	ld	a,1		;set sequential access mode.
FA03: 32D8FD  		ld	(mode),a
FA06: 3E00    	wtseq1:	ld	a,0		;allow an addition empty extent to be opened.
FA08: 32D6FD  		ld	(rdwrtflg),a
FA0B: CD57F5  		call	chkwprt		;check write protect status.
FA0E: 2A46F3  		ld	hl,(params)
FA11: CD4AF5  		call	ckrof1		;check for read only file, (hl) already set to fcb.
FA14: CDBEF4  		call	strdata		;put updated data into fcb.
FA17: 3AE6FD  		ld	a,(savnrec)	;get record number to write.
FA1A: FE80    		cp	128		;within range?
FA1C: D208F3  		jp	nc,ioerr1	;no, error(?).
FA1F: CD7AF4  		call	comblk		;compute block number.
FA22: CD87F4  		call	chkblk		;check number.
FA25: 0E00    		ld	c,0		;is there one to write to?
FA27: C271FA  		jp	nz,wtseq6	;yes, go do it.
FA2A: CD41F4  		call	getblock	;get next block number within fcb to use.
FA2D: 32DAFD  		ld	(relblock),a	;and save.
FA30: 010000  		ld	bc,0		;start looking for space from the start
FA33: B7      		or	a		;if none allocated as yet.
FA34: CA3EFA  		jp	z,wtseq2
FA37: 4F      		ld	c,a		;extract previous block number from fcb
FA38: 0B      		dec	bc		;so we can be closest to it.
FA39: CD61F4  		call	extblk
FA3C: 44      		ld	b,h
FA3D: 4D      		ld	c,l
FA3E: CDC1F7  	wtseq2:	call	fndspace	;find the next empty block nearest number (bc).
FA41: 7D      		ld	a,l		;check for a zero number.
FA42: B4      		or	h
FA43: C24BFA  		jp	nz,wtseq3
FA46: 3E02    		ld	a,2		;no more space?
FA48: C304F3  		jp	setstat
FA4B: 22E8FD  	wtseq3:	ld	(blknmbr),hl	;save block number to access.
FA4E: EB      		ex	de,hl		;put block number into (de).
FA4F: 2A46F3  		ld	hl,(params)	;now we must update the fcb for this
FA52: 011000  		ld	bc,16		;newly allocated block.
FA55: 09      		add	hl,bc
FA56: 3AE0FD  		ld	a,(bigdisk)	;8 or 16 bit block numbers?
FA59: B7      		or	a
FA5A: 3ADAFD  		ld	a,(relblock)	;(* update this entry *)
FA5D: CA67FA  		jp	z,wtseq4	;zero means 16 bit ones.
FA60: CD67F5  		call	adda2hl		;(hl)=(hl)+(a)
FA63: 73      		ld	(hl),e		;store new block number.
FA64: C36FFA  		jp	wtseq5
FA67: 4F      	wtseq4:	ld	c,a		;compute spot in this 16 bit table.
FA68: 0600    		ld	b,0
FA6A: 09      		add	hl,bc
FA6B: 09      		add	hl,bc
FA6C: 73      		ld	(hl),e		;stuff block number (de) there.
FA6D: 23      		inc	hl
FA6E: 72      		ld	(hl),d
FA6F: 0E02    	wtseq5:	ld	c,2		;set (c) to indicate writing to un-used disk space.
FA71: 3A48F3  	wtseq6:	ld	a,(status)	;are we ok so far?
FA74: B7      		or	a
FA75: C0      		ret	nz
FA76: C5      		push	bc		;yes, save write flag for bios (register c).
FA77: CD8DF4  		call	logical		;convert (blknmbr) over to loical sectors.
FA7A: 3AD8FD  		ld	a,(mode)	;get access mode flag (1=sequential,
FA7D: 3D      		dec	a		;0=random, 2=special?).
FA7E: 3D      		dec	a
FA7F: C2BEFA  		jp	nz,wtseq9
              	;
              	;   special random i/o from function #40. maybe for m/pm, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
FA82: C1      		pop	bc
FA83: C5      		push	bc
FA84: 79      		ld	a,c		;get write status flag (2=writing unused space).
FA85: 3D      		dec	a
FA86: 3D      		dec	a
FA87: C2BEFA  		jp	nz,wtseq9
FA8A: E5      		push	hl
FA8B: 2ABCFD  		ld	hl,(dirbuf)	;zero out the directory buffer.
FA8E: 57      		ld	d,a		;note that (a) is zero here.
FA8F: 77      	wtseq7:	ld	(hl),a
FA90: 23      		inc	hl
FA91: 14      		inc	d		;do 128 bytes.
FA92: F28FFA  		jp	p,wtseq7
FA95: CDE3F5  		call	dirdma		;tell the bios the dma address for directory access.
FA98: 2AEAFD  		ld	hl,(logsect)	;get sector that starts current block.
FA9B: 0E02    		ld	c,2		;set 'writing to unused space' flag.
FA9D: 22E8FD  	wtseq8:	ld	(blknmbr),hl	;save sector to write.
FAA0: C5      		push	bc
FAA1: CDD4F3  		call	trksec1		;determine its track and sector numbers.
FAA4: C1      		pop	bc
FAA5: CDBBF3  		call	dowrite		;now write out 128 bytes of zeros.
FAA8: 2AE8FD  		ld	hl,(blknmbr)	;get sector number.
FAAB: 0E00    		ld	c,0		;set normal write flag.
FAAD: 3AC7FD  		ld	a,(blkmask)	;determine if we have written the entire
FAB0: 47      		ld	b,a		;physical block.
FAB1: A5      		and	l
FAB2: B8      		cp	b
FAB3: 23      		inc	hl		;prepare for the next one.
FAB4: C29DFA  		jp	nz,wtseq8	;continue until (blkmask+1) sectors written.
FAB7: E1      		pop	hl		;reset next sector number.
FAB8: 22E8FD  		ld	(blknmbr),hl
FABB: CDDDF5  		call	defdma		;and reset dma address.
              	;
              	;   normal disk write. set the desired track and sector then
              	; do the actual write.
              	;
FABE: CDD4F3  	wtseq9:	call	trksec1		;determine track and sector for this write.
FAC1: C1      		pop	bc		;get write status flag.
FAC2: C5      		push	bc
FAC3: CDBBF3  		call	dowrite		;and write this out.
FAC6: C1      		pop	bc
FAC7: 3AE6FD  		ld	a,(savnrec)	;get number of records in file.
FACA: 21E4FD  		ld	hl,savnxt	;get last record written.
FACD: BE      		cp	(hl)
FACE: DAD5FA  		jp	c,wtseq10
FAD1: 77      		ld	(hl),a		;we have to update record count.
FAD2: 34      		inc	(hl)
FAD3: 0E02    		ld	c,2
              	;
              	;*   this area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the bios.
              	;
FAD5: 00      	wtseq10:nop			;was 'dcr c'
FAD6: 00      		nop			;was 'dcr c'
FAD7: 210000  		ld	hl,0		;was 'jnz wtseq99'
              	;
              	; *   end of patch.
              	;
FADA: F5      		push	af
FADB: CD6CF5  		call	gets2		;set 'extent written to' flag.
FADE: E67F    		and	7fh		;(* clear bit 7 *)
FAE0: 77      		ld	(hl),a
FAE1: F1      		pop	af		;get record count for this extent.
FAE2: FE7F    	wtseq99:cp	127		;is it full?
FAE4: C203FB  		jp	nz,wtseq12
FAE7: 3AD8FD  		ld	a,(mode)	;yes, are we in sequential mode?
FAEA: FE01    		cp	1
FAEC: C203FB  		jp	nz,wtseq12
FAEF: CDD5F4  		call	setnrec		;yes, set next record number.
FAF2: CD5DF9  		call	getnext		;and get next empty space in directory.
FAF5: 2148F3  		ld	hl,status	;ok?
FAF8: 7E      		ld	a,(hl)
FAF9: B7      		or	a
FAFA: C201FB  		jp	nz,wtseq11
FAFD: 3D      		dec	a		;yes, set record count to -1.
FAFE: 32E6FD  		ld	(savnrec),a
FB01: 3600    	wtseq11:ld	(hl),0		;clear status.
FB03: C3D5F4  	wtseq12:jp	setnrec		;set next record to access.
              	;
              	;   for random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. these bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   on entry, register (c) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. otherwise,
              	; another extent will be opened (for writing) if required.
              	;
FB06: AF      	position: xor	a		;set random i/o flag.
FB07: 32D8FD  		ld	(mode),a
              	;
              	;   special entry (function #40). m/pm ?
              	;
FB0A: C5      	positn1:push	bc		;save read/write flag.
FB0B: 2A46F3  		ld	hl,(params)	;get address of fcb.
FB0E: EB      		ex	de,hl
FB0F: 212100  		ld	hl,33		;now get byte 'r0'.
FB12: 19      		add	hl,de
FB13: 7E      		ld	a,(hl)
FB14: E67F    		and	7fh		;keep bits 0-6 for the record number to access.
FB16: F5      		push	af
FB17: 7E      		ld	a,(hl)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
FB18: 17      		rla	
FB19: 23      		inc	hl
FB1A: 7E      		ld	a,(hl)
FB1B: 17      		rla	
FB1C: E61F    		and	1fh		;and save this in bits 0-4 of (c).
FB1E: 4F      		ld	c,a		;this is the extent byte.
FB1F: 7E      		ld	a,(hl)		;now get the extra extent byte.
FB20: 1F      		rra	
FB21: 1F      		rra	
FB22: 1F      		rra	
FB23: 1F      		rra	
FB24: E60F    		and	0fh
FB26: 47      		ld	b,a		;and save it in (b).
FB27: F1      		pop	af		;get record number back to (a).
FB28: 23      		inc	hl		;check overflow byte 'r2'.
FB29: 6E      		ld	l,(hl)
FB2A: 2C      		inc	l
FB2B: 2D      		dec	l
FB2C: 2E06    		ld	l,6		;prepare for error.
FB2E: C28EFB  		jp	nz,positn5	;out of disk space error.
FB31: 212000  		ld	hl,32		;store record number into fcb.
FB34: 19      		add	hl,de
FB35: 77      		ld	(hl),a
FB36: 210C00  		ld	hl,12		;and now check the extent byte.
FB39: 19      		add	hl,de
FB3A: 79      		ld	a,c
FB3B: 96      		sub	(hl)		;same extent as before?
FB3C: C24AFB  		jp	nz,positn2
FB3F: 210E00  		ld	hl,14		;yes, check extra extent byte 's2' also.
FB42: 19      		add	hl,de
FB43: 78      		ld	a,b
FB44: 96      		sub	(hl)
FB45: E67F    		and	7fh
FB47: CA82FB  		jp	z,positn3	;same, we are almost done then.
              	;
              	;  get here when another extent is required.
              	;
FB4A: C5      	positn2:push	bc
FB4B: D5      		push	de
FB4C: CDA5F8  		call	closeit		;close current extent.
FB4F: D1      		pop	de
FB50: C1      		pop	bc
FB51: 2E03    		ld	l,3		;prepare for error.
FB53: 3A48F3  		ld	a,(status)
FB56: 3C      		inc	a
FB57: CA87FB  		jp	z,positn4	;close error.
FB5A: 210C00  		ld	hl,12		;put desired extent into fcb now.
FB5D: 19      		add	hl,de
FB5E: 71      		ld	(hl),c
FB5F: 210E00  		ld	hl,14		;and store extra extent byte 's2'.
FB62: 19      		add	hl,de
FB63: 70      		ld	(hl),b
FB64: CD54F8  		call	openit		;try and get this extent.
FB67: 3A48F3  		ld	a,(status)	;was it there?
FB6A: 3C      		inc	a
FB6B: C282FB  		jp	nz,positn3
FB6E: C1      		pop	bc		;no. can we create a new one (writing?).
FB6F: C5      		push	bc
FB70: 2E04    		ld	l,4		;prepare for error.
FB72: 0C      		inc	c
FB73: CA87FB  		jp	z,positn4	;nope, reading unwritten space error.
FB76: CD27F9  		call	getempty	;yes we can, try to find space.
FB79: 2E05    		ld	l,5		;prepare for error.
FB7B: 3A48F3  		ld	a,(status)
FB7E: 3C      		inc	a
FB7F: CA87FB  		jp	z,positn4	;out of space?
              	;
              	;   normal return location. clear error code and return.
              	;
FB82: C1      	positn3:pop	bc		;restore stack.
FB83: AF      		xor	a		;and clear error code byte.
FB84: C304F3  		jp	setstat
              	;
              	;   error. set the 's2' byte to indicate this (why?).
              	;
FB87: E5      	positn4:push	hl
FB88: CD6CF5  		call	gets2
FB8B: 36C0    		ld	(hl),0c0h
FB8D: E1      		pop	hl
              	;
              	;   return with error code (presently in l).
              	;
FB8E: C1      	positn5:pop	bc
FB8F: 7D      		ld	a,l		;get error code.
FB90: 3248F3  		ld	(status),a
FB93: C37BF5  		jp	sets2b7
              	;
              	;   read a random record.
              	;
FB96: 0EFF    	readran:ld	c,0ffh		;set 'read' status.
FB98: CD06FB  		call	position	;position the file to proper record.
FB9B: CCC4F9  		call	z,rdseq1	;and read it as usual (if no errors).
FB9E: C9      		ret	
              	;
              	;   write to a random record.
              	;
FB9F: 0E00    	writeran: ld	c,0		;set 'writing' flag.
FBA1: CD06FB  		call	position	;position the file to proper record.
FBA4: CC06FA  		call	z,wtseq1	;and write as usual (if no errors).
FBA7: C9      		ret	
              	;
              	;   compute the random record number. enter with (hl) pointing
              	; to a fcb an (de) contains a relative location of a record
              	; number. on exit, (c) contains the 'r0' byte, (b) the 'r1'
              	; byte, and (a) the 'r2' byte.
              	;
              	;   on return, the zero flag is set if the record is within
              	; bounds. otherwise, an overflow occured.
              	;
FBA8: EB      	comprand: ex	de,hl		;save fcb pointer in (de).
FBA9: 19      		add	hl,de		;compute relative position of record #.
FBAA: 4E      		ld	c,(hl)		;get record number into (bc).
FBAB: 0600    		ld	b,0
FBAD: 210C00  		ld	hl,12		;now get extent.
FBB0: 19      		add	hl,de
FBB1: 7E      		ld	a,(hl)		;compute (bc)=(record #)+(extent)*128.
FBB2: 0F      		rrca			;move lower bit into bit 7.
FBB3: E680    		and	80h		;and ignore all other bits.
FBB5: 81      		add	a,c		;add to our record number.
FBB6: 4F      		ld	c,a
FBB7: 3E00    		ld	a,0		;take care of any carry.
FBB9: 88      		adc	a,b
FBBA: 47      		ld	b,a
FBBB: 7E      		ld	a,(hl)		;now get the upper bits of extent into
FBBC: 0F      		rrca			;bit positions 0-3.
FBBD: E60F    		and	0fh		;and ignore all others.
FBBF: 80      		add	a,b		;add this in to 'r1' byte.
FBC0: 47      		ld	b,a
FBC1: 210E00  		ld	hl,14		;get the 's2' byte (extra extent).
FBC4: 19      		add	hl,de
FBC5: 7E      		ld	a,(hl)
FBC6: 87      		add	a,a		;and shift it left 4 bits (bits 4-7).
FBC7: 87      		add	a,a
FBC8: 87      		add	a,a
FBC9: 87      		add	a,a
FBCA: F5      		push	af		;save carry flag (bit 0 of flag byte).
FBCB: 80      		add	a,b		;now add extra extent into 'r1'.
FBCC: 47      		ld	b,a
FBCD: F5      		push	af		;and save carry (overflow byte 'r2').
FBCE: E1      		pop	hl		;bit 0 of (l) is the overflow indicator.
FBCF: 7D      		ld	a,l
FBD0: E1      		pop	hl		;and same for first carry flag.
FBD1: B5      		or	l		;either one of these set?
FBD2: E601    		and	01h		;only check the carry flags.
FBD4: C9      		ret	
              	;
              	;   routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; this reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. this is used to compute the space used
              	; by a random file.
              	;
FBD5: 0E0C    	ransize:ld	c,12		;look thru directory for first entry with
FBD7: CD1BF7  		call	findfst		;this name.
FBDA: 2A46F3  		ld	hl,(params)	;zero out the 'r0, r1, r2' bytes.
FBDD: 112100  		ld	de,33
FBE0: 19      		add	hl,de
FBE1: E5      		push	hl
FBE2: 72      		ld	(hl),d		;note that (d)=0.
FBE3: 23      		inc	hl
FBE4: 72      		ld	(hl),d
FBE5: 23      		inc	hl
FBE6: 72      		ld	(hl),d
FBE7: CDF8F5  	ransiz1:call	ckfilpos	;is there an extent to process?
FBEA: CA0FFC  		jp	z,ransiz3	;no, we are done.
FBED: CD61F5  		call	fcb2hl		;set (hl) pointing to proper fcb in dir.
FBF0: 110F00  		ld	de,15		;point to last record in extent.
FBF3: CDA8FB  		call	comprand	;and compute random parameters.
FBF6: E1      		pop	hl
FBF7: E5      		push	hl		;now check these values against those
FBF8: 5F      		ld	e,a		;already in fcb.
FBF9: 79      		ld	a,c		;the carry flag will be set if those
FBFA: 96      		sub	(hl)		;in the fcb represent a larger size than
FBFB: 23      		inc	hl		;this extent does.
FBFC: 78      		ld	a,b
FBFD: 9E      		sbc	a,(hl)
FBFE: 23      		inc	hl
FBFF: 7B      		ld	a,e
FC00: 9E      		sbc	a,(hl)
FC01: DA09FC  		jp	c,ransiz2
FC04: 73      		ld	(hl),e		;we found a larger (in size) extent.
FC05: 2B      		dec	hl		;stuff these values into fcb.
FC06: 70      		ld	(hl),b
FC07: 2B      		dec	hl
FC08: 71      		ld	(hl),c
FC09: CD30F7  	ransiz2:call	findnxt		;now get the next extent.
FC0C: C3E7FB  		jp	ransiz1		;continue til all done.
FC0F: E1      	ransiz3:pop	hl		;we are done, restore the stack and
FC10: C9      		ret			;return.
              	;
              	;   function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
FC11: 2A46F3  	setran:	ld	hl,(params)	;point to fcb.
FC14: 112000  		ld	de,32		;and to last used record.
FC17: CDA8FB  		call	comprand	;compute random position.
FC1A: 212100  		ld	hl,33		;now stuff these values into fcb.
FC1D: 19      		add	hl,de
FC1E: 71      		ld	(hl),c		;move 'r0'.
FC1F: 23      		inc	hl
FC20: 70      		ld	(hl),b		;and 'r1'.
FC21: 23      		inc	hl
FC22: 77      		ld	(hl),a		;and lastly 'r2'.
FC23: C9      		ret	
              	;
              	;   this routine select the drive specified in (active) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
FC24: 2AB2FD  	logindrv: ld	hl,(login)	;get the login vector.
FC27: 3A45F3  		ld	a,(active)	;get the default drive.
FC2A: 4F      		ld	c,a
FC2B: CDEDF4  		call	shiftr		;position active bit for this drive
FC2E: E5      		push	hl		;into bit 0.
FC2F: EB      		ex	de,hl
FC30: CD5CF3  		call	select		;select this drive.
FC33: E1      		pop	hl
FC34: CC4AF3  		call	z,slcterr	;valid drive?
FC37: 7D      		ld	a,l		;is this a newly activated drive?
FC38: 1F      		rra	
FC39: D8      		ret	c
FC3A: 2AB2FD  		ld	hl,(login)	;yes, update the login vector.
FC3D: 4D      		ld	c,l
FC3E: 44      		ld	b,h
FC3F: CD0EF5  		call	setbit
FC42: 22B2FD  		ld	(login),hl	;and save.
FC45: C3A6F6  		jp	bitmap		;now update the bitmap.
              	;
              	;   function to set the active disk number.
              	;
FC48: 3AD9FD  	setdsk:	ld	a,(eparam)	;get parameter passed and see if this
FC4B: 2145F3  		ld	hl,active	;represents a change in drives.
FC4E: BE      		cp	(hl)
FC4F: C8      		ret	z
FC50: 77      		ld	(hl),a		;yes it does, log it in.
FC51: C324FC  		jp	logindrv
              	;
              	;   this is the 'auto disk select' routine. the firsst byte
              	; of the fcb is examined for a drive specification. if non
              	; zero then the drive will be selected and loged in.
              	;
FC54: 3EFF    	autosel:ld	a,0ffh		;say 'auto-select activated'.
FC56: 32E1FD  		ld	(auto),a
FC59: 2A46F3  		ld	hl,(params)	;get drive specified.
FC5C: 7E      		ld	a,(hl)
FC5D: E61F    		and	1fh		;look at lower 5 bits.
FC5F: 3D      		dec	a		;adjust for (1=a, 2=b) etc.
FC60: 32D9FD  		ld	(eparam),a	;and save for the select routine.
FC63: FE1E    		cp	1eh		;check for 'no change' condition.
FC65: D278FC  		jp	nc,autosl1	;yes, don't change.
FC68: 3A45F3  		ld	a,(active)	;we must change, save currently active
FC6B: 32E2FD  		ld	(olddrv),a	;drive.
FC6E: 7E      		ld	a,(hl)		;and save first byte of fcb also.
FC6F: 32E3FD  		ld	(autoflag),a	;this must be non-zero.
FC72: E6E0    		and	0e0h		;whats this for (bits 6,7 are used for
FC74: 77      		ld	(hl),a		;something)?
FC75: CD48FC  		call	setdsk		;select and log in this drive.
FC78: 3A44F3  	autosl1:ld	a,(userno)	;move user number into fcb.
FC7B: 2A46F3  		ld	hl,(params)	;(* upper half of first byte *)
FC7E: B6      		or	(hl)
FC7F: 77      		ld	(hl),a
FC80: C9      		ret			;and return (all done).
              	;
              	;   function to return the current cp/m version number.
              	;
FC81: 3E22    	getver:	ld	a,022h		;version 2.2
FC83: C304F3  		jp	setstat
              	;
              	;   function to reset the disk system.
              	;
FC86: 210000  	rstdsk:	ld	hl,0		;clear write protect status and log
FC89: 22B0FD  		ld	(wrtprt),hl	;in vector.
FC8C: 22B2FD  		ld	(login),hl
FC8F: AF      		xor	a		;select drive 'a'.
FC90: 3245F3  		ld	(active),a
FC93: 218000  		ld	hl,tbuff	;setup default dma address.
FC96: 22B4FD  		ld	(userdma),hl
FC99: CDDDF5  		call	defdma
FC9C: C324FC  		jp	logindrv	;now log in drive 'a'.
              	;
              	;   function to open a specified file.
              	;
FC9F: CD75F5  	openfil:call	clears2		;clear 's2' byte.
FCA2: CD54FC  		call	autosel		;select proper disk.
FCA5: C354F8  		jp	openit		;and open the file.
              	;
              	;   function to close a specified file.
              	;
FCA8: CD54FC  	closefil: call	autosel		;select proper disk.
FCAB: C3A5F8  		jp	closeit		;and close the file.
              	;
              	;   function to return the first occurence of a specified file
              	; name. if the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
FCAE: 0E00    	getfst:	ld	c,0		;prepare for special search.
FCB0: EB      		ex	de,hl
FCB1: 7E      		ld	a,(hl)		;is first byte a '?'?
FCB2: FE3F    		cp	'?'
FCB4: CAC5FC  		jp	z,getfst1	;yes, just get very first entry (zero length match).
FCB7: CDA9F4  		call	setext		;get the extension byte from fcb.
FCBA: 7E      		ld	a,(hl)		;is it '?'? if yes, then we want
FCBB: FE3F    		cp	'?'		;an entry with a specific 's2' byte.
FCBD: C475F5  		call	nz,clears2	;otherwise, look for a zero 's2' byte.
FCC0: CD54FC  		call	autosel		;select proper drive.
FCC3: 0E0F    		ld	c,15		;compare bytes 0-14 in fcb (12&13 excluded).
FCC5: CD1BF7  	getfst1:call	findfst		;find an entry and then move it into
FCC8: C3ECF5  		jp	movedir		;the users dma space.
              	;
              	;   function to return the next occurence of a file name.
              	;
FCCB: 2ADCFD  	getnxt:	ld	hl,(savefcb)	;restore pointers. note that no
FCCE: 2246F3  		ld	(params),hl	;other dbos calls are allowed.
FCD1: CD54FC  		call	autosel		;no error will be returned, but the
FCD4: CD30F7  		call	findnxt		;results will be wrong.
FCD7: C3ECF5  		jp	movedir
              	;
              	;   function to delete a file by name.
              	;
FCDA: CD54FC  	delfile:call	autosel		;select proper drive.
FCDD: CD9FF7  		call	erafile		;erase the file.
FCE0: C304F7  		jp	ststatus	;set status and return.
              	;
              	;   function to execute a sequential read of the specified
              	; record number.
              	;
FCE3: CD54FC  	readseq:call	autosel		;select proper drive then read.
FCE6: C3BFF9  		jp	rdseq
              	;
              	;   function to write the net sequential record.
              	;
FCE9: CD54FC  	wrtseq:	call	autosel		;select proper drive then write.
FCEC: C301FA  		jp	wtseq
              	;
              	;   create a file function.
              	;
FCEF: CD75F5  	fcreate:call	clears2		;clear the 's2' byte on all creates.
FCF2: CD54FC  		call	autosel		;select proper drive and get the next
FCF5: C327F9  		jp	getempty	;empty directory space.
              	;
              	;   function to rename a file.
              	;
FCF8: CD54FC  	renfile:call	autosel		;select proper drive and then switch
FCFB: CD19F8  		call	chgnames	;file names.
FCFE: C304F7  		jp	ststatus
              	;
              	;   function to return the login vector.
              	;
FD01: 2AB2FD  	getlog:	ld	hl,(login)
FD04: C32CFD  		jp	getprm1
              	;
              	;   function to return the current disk assignment.
              	;
FD07: 3A45F3  	getcrnt:ld	a,(active)
FD0A: C304F3  		jp	setstat
              	;
              	;   function to set the dma address.
              	;
FD0D: EB      	putdma:	ex	de,hl
FD0E: 22B4FD  		ld	(userdma),hl	;save in our space and then get to
FD11: C3DDF5  		jp	defdma		;the bios with this also.
              	;
              	;   function to return the allocation vector.
              	;
FD14: 2AC2FD  	getaloc:ld	hl,(alocvect)
FD17: C32CFD  		jp	getprm1
              	;
              	;   function to return the read-only status vector.
              	;
FD1A: 2AB0FD  	getrov:	ld	hl,(wrtprt)
FD1D: C32CFD  		jp	getprm1
              	;
              	;   function to set the file attributes (read-only, system).
              	;
FD20: CD54FC  	setattr:call	autosel		;select proper drive then save attributes.
FD23: CD3EF8  		call	saveattr
FD26: C304F7  		jp	ststatus
              	;
              	;   function to return the address of the disk parameter block
              	; for the current drive.
              	;
FD29: 2ABEFD  	getparm:ld	hl,(diskpb)
FD2C: 2248F3  	getprm1:ld	(status),hl
FD2F: C9      		ret	
              	;
              	;   function to get or set the user number. if (e) was (ff)
              	; then this is a request to return the current user number.
              	; else set the user number from (e).
              	;
FD30: 3AD9FD  	getuser:ld	a,(eparam)	;get parameter.
FD33: FEFF    		cp	0ffh		;get user number?
FD35: C23EFD  		jp	nz,setuser
FD38: 3A44F3  		ld	a,(userno)	;yes, just do it.
FD3B: C304F3  		jp	setstat
FD3E: E61F    	setuser:and	1fh		;no, we should set it instead. keep low
FD40: 3244F3  		ld	(userno),a	;bits (0-4) only.
FD43: C9      		ret	
              	;
              	;   function to read a random record from a file.
              	;
FD44: CD54FC  	rdrandom: call	autosel		;select proper drive and read.
FD47: C396FB  		jp	readran
              	;
              	;   function to compute the file size for random files.
              	;
FD4A: CD54FC  	wtrandom: call	autosel		;select proper drive and write.
FD4D: C39FFB  		jp	writeran
              	;
              	;   function to compute the size of a random file.
              	;
FD50: CD54FC  	filesize: call	autosel		;select proper drive and check file length
FD53: C3D5FB  		jp	ransize
              	;
              	;   function #37. this allows a program to log off any drives.
              	; on entry, set (de) to contain a word with bits set for those
              	; drives that are to be logged off. the log-in vector and the
              	; write protect vector will be updated. this must be a m/pm
              	; special function.
              	;
FD56: 2A46F3  	logoff:	ld	hl,(params)	;get drives to log off.
FD59: 7D      		ld	a,l		;for each bit that is set, we want
FD5A: 2F      		cpl			;to clear that bit in (login)
FD5B: 5F      		ld	e,a		;and (wrtprt).
FD5C: 7C      		ld	a,h
FD5D: 2F      		cpl	
FD5E: 2AB2FD  		ld	hl,(login)	;reset the login vector.
FD61: A4      		and	h
FD62: 57      		ld	d,a
FD63: 7D      		ld	a,l
FD64: A3      		and	e
FD65: 5F      		ld	e,a
FD66: 2AB0FD  		ld	hl,(wrtprt)
FD69: EB      		ex	de,hl
FD6A: 22B2FD  		ld	(login),hl	;and save.
FD6D: 7D      		ld	a,l		;now do the write protect vector.
FD6E: A3      		and	e
FD6F: 6F      		ld	l,a
FD70: 7C      		ld	a,h
FD71: A2      		and	d
FD72: 67      		ld	h,a
FD73: 22B0FD  		ld	(wrtprt),hl	;and save. all done.
FD76: C9      		ret	
              	;
              	;   get here to return to the user.
              	;
FD77: 3AE1FD  	goback:	ld	a,(auto)	;was auto select activated?
FD7A: B7      		or	a
FD7B: CA94FD  		jp	z,goback1
FD7E: 2A46F3  		ld	hl,(params)	;yes, but was a change made?
FD81: 3600    		ld	(hl),0		;(* reset first byte of fcb *)
FD83: 3AE3FD  		ld	a,(autoflag)
FD86: B7      		or	a
FD87: CA94FD  		jp	z,goback1
FD8A: 77      		ld	(hl),a		;yes, reset first byte properly.
FD8B: 3AE2FD  		ld	a,(olddrv)	;and get the old drive and select it.
FD8E: 32D9FD  		ld	(eparam),a
FD91: CD48FC  		call	setdsk
FD94: 2A12F3  	goback1:ld	hl,(usrstack)	;reset the users stack pointer.
FD97: F9      		ld	sp,hl
FD98: 2A48F3  		ld	hl,(status)	;get return status.
FD9B: 7D      		ld	a,l		;force version 1.4 compatability.
FD9C: 44      		ld	b,h
FD9D: C9      		ret			;and go back to user.
              	;
              	;   function #40. this is a special entry to do random i/o.
              	; for the case where we are writing to unused disk space, this
              	; space will be zeroed out first. this must be a m/pm special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
FD9E: CD54FC  	wtspecl:call	autosel		;select proper drive.
FDA1: 3E02    		ld	a,2		;use special write mode.
FDA3: 32D8FD  		ld	(mode),a
FDA6: 0E00    		ld	c,0		;set write indicator.
FDA8: CD0AFB  		call	positn1		;position the file.
FDAB: CC06FA  		call	z,wtseq1	;and write (if no errors).
FDAE: C9      		ret	
              	;
              	;**************************************************************
              	;*
              	;*     bdos data storage pool.
              	;*
              	;**************************************************************
              	;
FDAF: E5      	emptyfcb: defb	0e5h		;empty directory segment indicator.
FDB0: 0000    	wrtprt:	defw	0		;write protect status for all 16 drives.
FDB2: 0000    	login:	defw	0		;drive active word (1 bit per drive).
FDB4: 8000    	userdma:defw	080h		;user's dma address (defaults to 80h).
              	;
              	;   scratch areas from parameter block.
              	;
FDB6: 0000    	scratch1: defw	0		;relative position within dir segment for file (0-3).
FDB8: 0000    	scratch2: defw	0		;last selected track number.
FDBA: 0000    	scratch3: defw	0		;last selected sector number.
              	;
              	;   disk storage areas from parameter block.
              	;
FDBC: 0000    	dirbuf:	defw	0		;address of directory buffer to use.
FDBE: 0000    	diskpb:	defw	0		;contains address of disk parameter block.
FDC0: 0000    	chkvect:defw	0		;address of check vector.
FDC2: 0000    	alocvect: defw	0		;address of allocation vector (bit map).
              	;
              	;   parameter block returned from the bios.
              	;
FDC4: 0000    	sectors:defw	0		;sectors per track from bios.
FDC6: 00      	blkshft:defb	0		;block shift.
FDC7: 00      	blkmask:defb	0		;block mask.
FDC8: 00      	extmask:defb	0		;extent mask.
FDC9: 0000    	dsksize:defw	0		;disk size from bios (number of blocks-1).
FDCB: 0000    	dirsize:defw	0		;directory size.
FDCD: 0000    	alloc0:	defw	0		;storage for first bytes of bit map (dir space used).
FDCF: 0000    	alloc1:	defw	0
FDD1: 0000    	offset:	defw	0		;first usable track number.
FDD3: 0000    	xlate:	defw	0		;sector translation table address.
              	;
              	;
FDD5: 00      	closeflg: defb	0		;close flag (=0ffh is extent written ok).
FDD6: 00      	rdwrtflg: defb	0		;read/write flag (0ffh=read, 0=write).
FDD7: 00      	fndstat:defb	0		;filename found status (0=found first entry).
FDD8: 00      	mode:	defb	0		;i/o mode select (0=random, 1=sequential, 2=special random).
FDD9: 00      	eparam:	defb	0		;storage for register (e) on entry to bdos.
FDDA: 00      	relblock: defb	0		;relative position within fcb of block number written.
FDDB: 00      	counter:defb	0		;byte counter for directory name searches.
FDDC: 00000000	savefcb:defw	0,0		;save space for address of fcb (for directory searches).
FDE0: 00      	bigdisk:defb	0		;if =0 then disk is > 256 blocks long.
FDE1: 00      	auto:	defb	0		;if non-zero, then auto select activated.
FDE2: 00      	olddrv:	defb	0		;on auto select, storage for previous drive.
FDE3: 00      	autoflag: defb	0		;if non-zero, then auto select changed drives.
FDE4: 00      	savnxt:	defb	0		;storage for next record number to access.
FDE5: 00      	savext:	defb	0		;storage for extent number of file.
FDE6: 0000    	savnrec:defw	0		;storage for number of records in file.
FDE8: 0000    	blknmbr:defw	0		;block number (physical sector) used within a file or logical sect
FDEA: 0000    	logsect:defw	0		;starting logical (128 byte) sector of block (physical sector).
FDEC: 00      	fcbpos:	defb	0		;relative position within buffer for fcb of file of interest.
FDED: 0000    	filepos:defw	0		;files position within directory (0 to max entries -1).
              	;
              	;   disk directory buffer checksum bytes. one for each of the
              	; 16 possible drives.
              	;
FDEF: 00000000	cksumtbl: defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FDF3: 00...   	
              	;
              	;   extra space ?
              	;
FDFF: 00      		defb	0
              		
              	#include "bios.asm"
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   B O O T   R O U T I N E S
              	;*
              	;**************************************************************
              	;
FE00: 76      	boot:	halt
FE01: C300FE  		jp	boot
              	
FE04: C30000  	wboot:	jp	0
FE07: C30000  	const:	jp	0
FE0A: C30000  	conin:	jp	0
FE0D: C30000  	conout:	jp	0
FE10: C30000  	list:	jp	0
FE13: C30000  	punch:	jp	0
FE16: C30000  	reader:	jp	0
FE19: C30000  	home:	jp	0
FE1C: C30000  	seldsk:	jp	0
FE1F: C30000  	settrk:	jp	0
FE22: C30000  	setsec:	jp	0
FE25: C30000  	setdma:	jp	0
FE28: C30000  	read:	jp	0
FE2B: C30000  	write:	jp	0
FE2E: C30000  	prstat:	jp	0
FE31: C30000  	sectrn:	jp	0
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	


; +++ segments +++

#CODE          = $E800 = 59392,  size = $1634 =  5684

; +++ global symbols +++

_end     = $FE34 = 65076          cpm22.asm:43 (unused)
_size    = $1634 =  5684          cpm22.asm:43 (unused)
active   = $F345 = 62277          cpm22.asm:1701
adda2hl  = $F567 = 62823          cpm22.asm:2130
addhl    = $EA59 = 59993          cpm22.asm:432
alloc0   = $FDCD = 64973          cpm22.asm:3678
alloc1   = $FDCF = 64975          cpm22.asm:3679
alocvect = $FDC2 = 64962          cpm22.asm:3668
auto     = $FDE1 = 64993          cpm22.asm:3693
autoflag = $FDE3 = 64995          cpm22.asm:3695
autosel  = $FC54 = 64596          cpm22.asm:3408
autosl1  = $FC78 = 64632          cpm22.asm:3424
backup   = $F1A7 = 61863          cpm22.asm:1461
backup1  = $F1AF = 61871          cpm22.asm:1464
badload  = $EF7A = 61306          cpm22.asm:1191
badsctr  = $F00C = 61452          cpm22.asm:1245
badsec   = $F0CD = 61645          cpm22.asm:1316
badsel   = $F0D8 = 61656          cpm22.asm:1317
badslct  = $F00E = 61454          cpm22.asm:1246
batch    = $EFAB = 61355          cpm22.asm:1214
batchfcb = $EFAC = 61356          cpm22.asm:1215
bdosdrv  = $F0C9 = 61641          cpm22.asm:1315
bdoserr  = $F0BD = 61629          cpm22.asm:1314
bigdisk  = $FDE0 = 64992          cpm22.asm:3692
bitmap   = $F6A6 = 63142          cpm22.asm:2423
bitmap1  = $F6B4 = 63156          cpm22.asm:2438
bitmap2  = $F6D5 = 63189          cpm22.asm:2459
bitmap3  = $F6F9 = 63225          cpm22.asm:2476
blkmask  = $FDC7 = 64967          cpm22.asm:3674
blknmbr  = $FDE8 = 65000          cpm22.asm:3699
blkshft  = $FDC6 = 64966          cpm22.asm:3673
boot     = $FE00 = 65024          bios.asm:8
bs       = $0008 =     8          cpm22.asm:28
cbase    = $E800 = 59392          cpm22.asm:45
ccpstack = $EFAB = 61355          cpm22.asm:1210
cdrive   = $EFEF = 61423          cpm22.asm:1221
charbuf  = $F311 = 62225          cpm22.asm:1690
check    = $EA30 = 59952          cpm22.asm:398
checkdir = $F5A1 = 62881          cpm22.asm:2203
checksum = $F4FA = 62714          cpm22.asm:2042
chgdrv   = $EFF0 = 61424          cpm22.asm:1222
chgnam1  = $F82A = 63530          cpm22.asm:2715
chgnames = $F819 = 63513          cpm22.asm:2707
chkblk   = $F487 = 62599          cpm22.asm:1949
chkchar  = $F117 = 61719          cpm22.asm:1358
chkcon   = $E9C2 = 59842          cpm22.asm:323
chkdir1  = $F5C7 = 62919          cpm22.asm:2223
chknmbr  = $F58F = 62863          cpm22.asm:2176
chkrofl  = $F547 = 62791          cpm22.asm:2106
chksum1  = $F500 = 62720          cpm22.asm:2045
chkvect  = $FDC0 = 64960          cpm22.asm:3667
chkwprt  = $F557 = 62807          cpm22.asm:2117
ckbitmap = $F638 = 63032          cpm22.asm:2317
ckbmap1  = $F659 = 63065          cpm22.asm:2352
ckcon1   = $F145 = 61765          cpm22.asm:1388
ckcon2   = $F148 = 61768          cpm22.asm:1389
ckconsol = $F126 = 61734          cpm22.asm:1374
ckfilpos = $F5F8 = 62968          cpm22.asm:2266
ckrof1   = $F54A = 62794          cpm22.asm:2107
cksumtbl = $FDEF = 65007          cpm22.asm:3707
clearbuf = $EB58 = 60248          cpm22.asm:598
clears2  = $F575 = 62837          cpm22.asm:2147
close    = $E8DA = 59610          cpm22.asm:138
closefil = $FCA8 = 64680          cpm22.asm:3455
closeflg = $FDD5 = 64981          cpm22.asm:3684
closeit  = $F8A5 = 63653          cpm22.asm:2801
closeit1 = $F8D0 = 63696          cpm22.asm:2821
closeit2 = $F8DE = 63710          cpm22.asm:2829
closeit3 = $F8E4 = 63716          cpm22.asm:2833
closeit4 = $F8EB = 63723          cpm22.asm:2836
closeit5 = $F900 = 63744          cpm22.asm:2849
closeit6 = $F91A = 63770          cpm22.asm:2867
closeit7 = $F922 = 63778          cpm22.asm:2870
cmdadr   = $EBC1 = 60353          cpm22.asm:670
cmdtbl   = $EB10 = 60176          cpm22.asm:552
cmmnd1   = $EB82 = 60290          cpm22.asm:631
cmmnd2   = $EB98 = 60312          cpm22.asm:642
cntrlc   = $0003 =     3          cpm22.asm:26
cntrle   = $0005 =     5          cpm22.asm:27
cntrlp   = $0010 =    16          cpm22.asm:33
cntrlr   = $0012 =    18          cpm22.asm:34
cntrls   = $0013 =    19          cpm22.asm:35
cntrlu   = $0015 =    21          cpm22.asm:36
cntrlx   = $0018 =    24          cpm22.asm:37
cntrlz   = $001A =    26          cpm22.asm:38
comblk   = $F47A = 62586          cpm22.asm:1940
comfile  = $EF83 = 61315          cpm22.asm:1192
command  = $EB5C = 60252          cpm22.asm:608
comprand = $FBA8 = 64424          cpm22.asm:3274
conin    = $FE0A = 65034          bios.asm:13
conout   = $FE0D = 65037          bios.asm:14
const    = $FE07 = 65031          bios.asm:12
convert  = $EA60 = 60000          cpm22.asm:446
convfst  = $EA5E = 59998          cpm22.asm:440
convrt1  = $EA89 = 60041          cpm22.asm:469
convrt2  = $EA90 = 60048          cpm22.asm:472
convrt3  = $EA96 = 60054          cpm22.asm:479
convrt4  = $EA98 = 60056          cpm22.asm:480
convrt5  = $EAA9 = 60073          cpm22.asm:487
convrt6  = $EAAB = 60075          cpm22.asm:489
convrt7  = $EAAF = 60079          cpm22.asm:491
convrt8  = $EAB9 = 60089          cpm22.asm:495
counter  = $FDDB = 64987          cpm22.asm:3690
cr       = $000D =    13          cpm22.asm:32
create   = $E909 = 59657          cpm22.asm:188
crlf     = $E898 = 59544          cpm22.asm:80
curpos   = $F30F = 62223          cpm22.asm:1688
de2hl    = $F352 = 62290          cpm22.asm:1719
de2hl1   = $F353 = 62291          cpm22.asm:1720
decode   = $EBF8 = 60408          cpm22.asm:697
decode1  = $EC08 = 60424          cpm22.asm:703
decode2  = $EC2A = 60458          cpm22.asm:723 (unused)
decode3  = $EC33 = 60467          cpm22.asm:728
decode4  = $EC3A = 60474          cpm22.asm:732 (unused)
defdma   = $F5DD = 62941          cpm22.asm:2241
del      = $007F =   127          cpm22.asm:39
delbatch = $E9DD = 59869          cpm22.asm:348
delete   = $E8EF = 59631          cpm22.asm:159
delfile  = $FCDA = 64730          cpm22.asm:3486
dirbuf   = $FDBC = 64956          cpm22.asm:3665
dirc1    = $F2E3 = 62179          cpm22.asm:1646
dircio   = $F2D7 = 62167          cpm22.asm:1640
dirdma   = $F5E3 = 62947          cpm22.asm:2246
dirdma1  = $F5E6 = 62950          cpm22.asm:2251
direct   = $EC77 = 60535          cpm22.asm:794
direct1  = $EC88 = 60552          cpm22.asm:801
direct2  = $EC8F = 60559          cpm22.asm:805
direct3  = $EC98 = 60568          cpm22.asm:809
direct4  = $ECCC = 60620          cpm22.asm:836
direct5  = $ECD4 = 60628          cpm22.asm:839
direct6  = $ECD9 = 60633          cpm22.asm:841
direct7  = $ED0E = 60686          cpm22.asm:865
direct8  = $ED0F = 60687          cpm22.asm:866
direct9  = $ED1B = 60699          cpm22.asm:870
dirread  = $F5D7 = 62935          cpm22.asm:2236
dirsize  = $FDCB = 64971          cpm22.asm:3677
dirwrite = $F5C9 = 62921          cpm22.asm:2228
diskpb   = $FDBE = 64958          cpm22.asm:3666
diskro   = $F0E4 = 61668          cpm22.asm:1319
dmaset   = $E9D8 = 59864          cpm22.asm:343
doread   = $F3B5 = 62389          cpm22.asm:1790
dowrite  = $F3BB = 62395          cpm22.asm:1795
drect63  = $ECF7 = 60663          cpm22.asm:855
drect65  = $ECF9 = 60665          cpm22.asm:856
dselect  = $EC54 = 60500          cpm22.asm:764
dsksel   = $E8BD = 59581          cpm22.asm:112
dsksize  = $FDC9 = 64969          cpm22.asm:3676
emptyfcb = $FDAF = 64943          cpm22.asm:3652
entry    = $0005 =     5          cpm22.asm:19
entry1   = $E8C3 = 59587          cpm22.asm:119
entry2   = $E8F4 = 59636          cpm22.asm:165
eparam   = $FDD9 = 64985          cpm22.asm:3688
erafil1  = $F7A7 = 63399          cpm22.asm:2593
erafile  = $F79F = 63391          cpm22.asm:2590
erase    = $ED1F = 60703          cpm22.asm:879
erase1   = $ED42 = 60738          cpm22.asm:894
error1   = $F09C = 61596          cpm22.asm:1297
error2   = $F0A8 = 61608          cpm22.asm:1303
error3   = $F0AE = 61614          cpm22.asm:1306
error4   = $F0B4 = 61620          cpm22.asm:1309
error5   = $F0B7 = 61623          cpm22.asm:1311
exists   = $EE82 = 61058          cpm22.asm:1056
extblk   = $F461 = 62561          cpm22.asm:1921
extblk1  = $F474 = 62580          cpm22.asm:1931
extmask  = $FDC8 = 64968          cpm22.asm:3675
extract  = $EC4B = 60491          cpm22.asm:754
fbase    = $F006 = 61446          cpm22.asm:1240 (unused)
fbase1   = $F014 = 61460          cpm22.asm:1253
fcb      = $EFCD = 61389          cpm22.asm:1219
fcb2hl   = $F561 = 62817          cpm22.asm:2125
fcbpos   = $FDEC = 65004          cpm22.asm:3701
fcbset   = $F800 = 63488          cpm22.asm:2685
fcreate  = $FCEF = 64751          cpm22.asm:3503
ff       = $000C =    12          cpm22.asm:31 (unused)
filepos  = $FDED = 65005          cpm22.asm:3702
filero   = $F0DF = 61663          cpm22.asm:1318
filesize = $FD50 = 64848          cpm22.asm:3577
findfst  = $F71B = 63259          cpm22.asm:2510
findnxt  = $F730 = 63280          cpm22.asm:2523
fndnxt1  = $F74D = 63309          cpm22.asm:2536
fndnxt2  = $F756 = 63318          cpm22.asm:2540
fndnxt3  = $F776 = 63350          cpm22.asm:2556
fndnxt4  = $F77F = 63359          cpm22.asm:2565
fndnxt5  = $F786 = 63366          cpm22.asm:2570
fndnxt6  = $F797 = 63383          cpm22.asm:2583
fndspa1  = $F7C3 = 63427          cpm22.asm:2623
fndspa2  = $F7D4 = 63444          cpm22.asm:2646
fndspa3  = $F7EF = 63471          cpm22.asm:2667
fndspa4  = $F7F7 = 63479          cpm22.asm:2677
fndspace = $F7C1 = 63425          cpm22.asm:2617
fndstat  = $FDD7 = 64983          cpm22.asm:3686
functns  = $F04A = 61514          cpm22.asm:1288
getaloc  = $FD14 = 64788          cpm22.asm:3531
getback  = $EF86 = 61318          cpm22.asm:1198
getback1 = $EF89 = 61321          cpm22.asm:1199
getblk1  = $F448 = 62536          cpm22.asm:1899
getblk2  = $F456 = 62550          cpm22.asm:1908
getblk3  = $F45F = 62559          cpm22.asm:1913
getblock = $F441 = 62529          cpm22.asm:1896
getchar  = $F0FE = 61694          cpm22.asm:1336
getcon   = $F2CB = 62155          cpm22.asm:1628
getcrnt  = $FD07 = 64775          cpm22.asm:3520
getcsts  = $F301 = 62209          cpm22.asm:1673
getdsk   = $E9D0 = 59856          cpm22.asm:334
getecho  = $F109 = 61705          cpm22.asm:1345
getempty = $F927 = 63783          cpm22.asm:2877
getext   = $EAC0 = 60096          cpm22.asm:502
getext1  = $EAC8 = 60104          cpm22.asm:506
getext2  = $EAD9 = 60121          cpm22.asm:513
getext3  = $EADB = 60123          cpm22.asm:515
getext4  = $EADF = 60127          cpm22.asm:517
getext5  = $EAE9 = 60137          cpm22.asm:521
getext6  = $EAF0 = 60144          cpm22.asm:525
getext7  = $EAF2 = 60146          cpm22.asm:526
getext8  = $EB01 = 60161          cpm22.asm:538
getext9  = $EB09 = 60169          cpm22.asm:543
getfst   = $FCAE = 64686          cpm22.asm:3462
getfst1  = $FCC5 = 64709          cpm22.asm:3473
getinp   = $E939 = 59705          cpm22.asm:239
getinp1  = $E996 = 59798          cpm22.asm:295
getinp2  = $E9A7 = 59815          cpm22.asm:304
getinp3  = $E9AB = 59819          cpm22.asm:306
getinp4  = $E9BA = 59834          cpm22.asm:315
getiob   = $F2F0 = 62192          cpm22.asm:1654
getlog   = $FD01 = 64769          cpm22.asm:3515
getmt1   = $F949 = 63817          cpm22.asm:2893
getnext  = $F95D = 63837          cpm22.asm:2907
getnxt   = $FCCB = 64715          cpm22.asm:3478
getparm  = $FD29 = 64809          cpm22.asm:3548
getprm1  = $FD2C = 64812          cpm22.asm:3549
getrdr   = $F2D1 = 62161          cpm22.asm:1633
getrov   = $FD1A = 64794          cpm22.asm:3536
gets2    = $F56C = 62828          cpm22.asm:2139
getsetuc = $E915 = 59669          cpm22.asm:204
getuser  = $FD30 = 64816          cpm22.asm:3556
getusr   = $E913 = 59667          cpm22.asm:199
getver   = $FC81 = 64641          cpm22.asm:3432
getwprt  = $F521 = 62753          cpm22.asm:2079
goback   = $FD77 = 64887          cpm22.asm:3612
goback1  = $FD94 = 64916          cpm22.asm:3624
gtnext1  = $F986 = 63878          cpm22.asm:2927
gtnext2  = $F991 = 63889          cpm22.asm:2936
gtnext3  = $F9AF = 63919          cpm22.asm:2947
gtnext4  = $F9B2 = 63922          cpm22.asm:2948
gtnext5  = $F9B9 = 63929          cpm22.asm:2955
halt     = $EBCF = 60367          cpm22.asm:675
hl2de    = $EC42 = 60482          cpm22.asm:744
home     = $FE19 = 65049          bios.asm:18
homedrv  = $F3A4 = 62372          cpm22.asm:1776
inbuff   = $E806 = 59398          cpm22.asm:52
inpoint  = $E888 = 59528          cpm22.asm:60
iobyte   = $0003 =     3          cpm22.asm:17
ioerr1   = $F308 = 62216          cpm22.asm:1683
ioret    = $F3BE = 62398          cpm22.asm:1796
jumphl   = $F34D = 62285          cpm22.asm:1711
lf       = $000A =    10          cpm22.asm:30
list     = $FE10 = 65040          bios.asm:15
logical  = $F48D = 62605          cpm22.asm:1960
logicl1  = $F493 = 62611          cpm22.asm:1962
login    = $FDB2 = 64946          cpm22.asm:3654
logindrv = $FC24 = 64548          cpm22.asm:3376
logoff   = $FD56 = 64854          cpm22.asm:3586
logsect  = $FDEA = 65002          cpm22.asm:3700
mem      = $003A =    58          cpm22.asm:15
mode     = $FDD8 = 64984          cpm22.asm:3687
morefls  = $F582 = 62850          cpm22.asm:2163
move3    = $EC40 = 60480          cpm22.asm:740
movecd   = $E929 = 59689          cpm22.asm:221
movedir  = $F5EC = 62956          cpm22.asm:2258
moveword = $F897 = 63639          cpm22.asm:2784
namepnt  = $E88A = 59530          cpm22.asm:61
nbytes   = $EFF1 = 61425          cpm22.asm:1223
newline  = $F1B4 = 61876          cpm22.asm:1470
newln1   = $F1BC = 61884          cpm22.asm:1473
nfuncts  = $0029 =    41          cpm22.asm:1286
nofile   = $EBF0 = 60400          cpm22.asm:690
nonblank = $EA4F = 59983          cpm22.asm:422
none     = $EBEA = 60394          cpm22.asm:688
nospace  = $EE07 = 60935          cpm22.asm:998
numcmds  = $0006 =     6          cpm22.asm:551
nxent1   = $F61C = 63004          cpm22.asm:2296
nxent2   = $F623 = 63011          cpm22.asm:2299
nxentry  = $F608 = 62984          cpm22.asm:2288
offset   = $FDD1 = 64977          cpm22.asm:3680
olddrv   = $FDE2 = 64994          cpm22.asm:3694
open     = $E8CB = 59595          cpm22.asm:126
openfcb  = $E8D0 = 59600          cpm22.asm:131
openfil  = $FC9F = 64671          cpm22.asm:3449
openit   = $F854 = 63572          cpm22.asm:2741
openit1  = $F85D = 63581          cpm22.asm:2745
openit2  = $F88E = 63630          cpm22.asm:2773
outchar  = $F14B = 61771          cpm22.asm:1396
outchr1  = $F165 = 61797          cpm22.asm:1410
outchr2  = $F17C = 61820          cpm22.asm:1426
outcon   = $F193 = 61843          cpm22.asm:1447
outcon1  = $F199 = 61849          cpm22.asm:1450
outcrlf  = $F1CC = 61900          cpm22.asm:1483
outflag  = $F30D = 62221          cpm22.asm:1686
params   = $F346 = 62278          cpm22.asm:1702
pattrn1  = $EB28 = 60200          cpm22.asm:562
pattrn2  = $F000 = 61440          cpm22.asm:1232
pline    = $E8A7 = 59559          cpm22.asm:93
pline2   = $E8AC = 59564          cpm22.asm:96
position = $FB06 = 64262          cpm22.asm:3151
positn1  = $FB0A = 64266          cpm22.asm:3156
positn2  = $FB4A = 64330          cpm22.asm:3202
positn3  = $FB82 = 64386          cpm22.asm:3234
positn4  = $FB87 = 64391          cpm22.asm:3240
positn5  = $FB8E = 64398          cpm22.asm:3247
print    = $E88C = 59532          cpm22.asm:66
printb   = $E892 = 59538          cpm22.asm:72
prstat   = $FE2E = 65070          bios.asm:25 (unused)
prterr   = $F0E8 = 61672          cpm22.asm:1323
prtflag  = $F310 = 62224          cpm22.asm:1689
prtmesg  = $F1D6 = 61910          cpm22.asm:1490
prtstr   = $F2FB = 62203          cpm22.asm:1666
punch    = $FE13 = 65043          bios.asm:16
putdma   = $FD0D = 64781          cpm22.asm:3525
ransiz1  = $FBE7 = 64487          cpm22.asm:3330
ransiz2  = $FC09 = 64521          cpm22.asm:3352
ransiz3  = $FC0F = 64527          cpm22.asm:3354
ransize  = $FBD5 = 64469          cpm22.asm:3319
rdbuf1   = $F1F2 = 61938          cpm22.asm:1509
rdbuf10  = $F273 = 62067          cpm22.asm:1571
rdbuf11  = $F27B = 62075          cpm22.asm:1577
rdbuf12  = $F28D = 62093          cpm22.asm:1589
rdbuf13  = $F29C = 62108          cpm22.asm:1596
rdbuf14  = $F2A9 = 62121          cpm22.asm:1604
rdbuf15  = $F2AC = 62124          cpm22.asm:1607
rdbuf16  = $F2C0 = 62144          cpm22.asm:1619
rdbuf17  = $F2C4 = 62148          cpm22.asm:1621
rdbuf2   = $F1F4 = 61940          cpm22.asm:1511
rdbuf3   = $F219 = 61977          cpm22.asm:1528
rdbuf4   = $F229 = 61993          cpm22.asm:1537
rdbuf5   = $F23A = 62010          cpm22.asm:1545
rdbuf6   = $F24B = 62027          cpm22.asm:1554
rdbuf7   = $F251 = 62033          cpm22.asm:1557
rdbuf8   = $F262 = 62050          cpm22.asm:1564
rdbuf9   = $F26E = 62062          cpm22.asm:1569
rdbuff   = $F1E4 = 61924          cpm22.asm:1502
rderr    = $EBDF = 60383          cpm22.asm:684
rderror  = $EBD9 = 60377          cpm22.asm:682
rdrandom = $FD44 = 64836          cpm22.asm:3567
rdrec    = $E8F9 = 59641          cpm22.asm:172
rdseq    = $F9BF = 63935          cpm22.asm:2960
rdseq1   = $F9C4 = 63940          cpm22.asm:2962
rdseq2   = $F9E9 = 63977          cpm22.asm:2977
rdseq3   = $F9FE = 63998          cpm22.asm:2987
rdwrtflg = $FDD6 = 64982          cpm22.asm:3685
read     = $FE28 = 65064          bios.asm:23
reader   = $FE16 = 65046          bios.asm:17
readfcb  = $E8FE = 59646          cpm22.asm:177
readran  = $FB96 = 64406          cpm22.asm:3254
readseq  = $FCE3 = 64739          cpm22.asm:3493
relblock = $FDDA = 64986          cpm22.asm:3689
renam    = $E90E = 59662          cpm22.asm:194
rename   = $EE10 = 60944          cpm22.asm:1006
rename1  = $EE3F = 60991          cpm22.asm:1024
rename2  = $EE59 = 61017          cpm22.asm:1038
rename3  = $EE5E = 61022          cpm22.asm:1041 (unused)
rename4  = $EE6D = 61037          cpm22.asm:1049
rename5  = $EE73 = 61043          cpm22.asm:1051
rename6  = $EE79 = 61049          cpm22.asm:1053
renfile  = $FCF8 = 64760          cpm22.asm:3509
resdsk   = $E8B8 = 59576          cpm22.asm:107
resetdr  = $EC66 = 60518          cpm22.asm:778
rodisk   = $F010 = 61456          cpm22.asm:1247
rofile   = $F012 = 61458          cpm22.asm:1248
rstdsk   = $FC86 = 64646          cpm22.asm:3437
rtn      = $F307 = 62215          cpm22.asm:1679
rtncode  = $EFEE = 61422          cpm22.asm:1220
samext   = $F70A = 63242          cpm22.asm:2491
savatr1  = $F843 = 63555          cpm22.asm:2731
save     = $EDAD = 60845          cpm22.asm:951
save1    = $EDD4 = 60884          cpm22.asm:969
save2    = $EDF1 = 60913          cpm22.asm:987
save3    = $EDFB = 60923          cpm22.asm:994
save4    = $EE01 = 60929          cpm22.asm:996
saveattr = $F83E = 63550          cpm22.asm:2729
savefcb  = $FDDC = 64988          cpm22.asm:3691
savext   = $FDE5 = 64997          cpm22.asm:3697
savnrec  = $FDE6 = 64998          cpm22.asm:3698
savnxt   = $FDE4 = 64996          cpm22.asm:3696
scratch1 = $FDB6 = 64950          cpm22.asm:3659
scratch2 = $FDB8 = 64952          cpm22.asm:3660
scratch3 = $FDBA = 64954          cpm22.asm:3661
search   = $EB2E = 60206          cpm22.asm:570
search1  = $EB33 = 60211          cpm22.asm:572
search2  = $EB3C = 60220          cpm22.asm:577
search3  = $EB4F = 60239          cpm22.asm:589
search4  = $EB54 = 60244          cpm22.asm:592
sectors  = $FDC4 = 64964          cpm22.asm:3672
sectrn   = $FE31 = 65073          bios.asm:26
seldsk   = $FE1C = 65052          bios.asm:19
select   = $F35C = 62300          cpm22.asm:1730
select1  = $F3A0 = 62368          cpm22.asm:1770
setattr  = $FD20 = 64800          cpm22.asm:3541
setbit   = $F50E = 62734          cpm22.asm:2062
setcdrv  = $E91A = 59674          cpm22.asm:209
setdir   = $F59F = 62879          cpm22.asm:2196
setdma   = $FE25 = 65061          bios.asm:22
setdsk   = $FC48 = 64584          cpm22.asm:3397
setext   = $F4A9 = 62633          cpm22.asm:1977
setfile  = $F66E = 63086          cpm22.asm:2381
setfl1   = $F678 = 63096          cpm22.asm:2386
setfl2   = $F68B = 63115          cpm22.asm:2398
setfl3   = $F691 = 63121          cpm22.asm:2404
setfl4   = $F6A0 = 63136          cpm22.asm:2413
sethlde  = $F4B1 = 62641          cpm22.asm:1985
setiob   = $F2F6 = 62198          cpm22.asm:1659
setnrec  = $F4D5 = 62677          cpm22.asm:2011
setran   = $FC11 = 64529          cpm22.asm:3360
sets2b7  = $F57B = 62843          cpm22.asm:2153
setsec   = $FE22 = 65058          bios.asm:21
setstat  = $F304 = 62212          cpm22.asm:1678
settrk   = $FE1F = 65055          bios.asm:20
setuser  = $FD3E = 64830          cpm22.asm:3561
shiftl   = $F507 = 62727          cpm22.asm:2053
shiftl1  = $F508 = 62728          cpm22.asm:2054
shiftr   = $F4ED = 62701          cpm22.asm:2027
shiftr1  = $F4EE = 62702          cpm22.asm:2028
showit   = $F182 = 61826          cpm22.asm:1434
slcterr  = $F34A = 62282          cpm22.asm:1707
space    = $E8A2 = 59554          cpm22.asm:87
srchfcb  = $E8E9 = 59625          cpm22.asm:154
srchfst  = $E8DF = 59615          cpm22.asm:144
srchnxt  = $E8E4 = 59620          cpm22.asm:149
starting = $F30E = 62222          cpm22.asm:1687
status   = $F348 = 62280          cpm22.asm:1703
stbitmap = $F65F = 63071          cpm22.asm:2361
stbmap1  = $F667 = 63079          cpm22.asm:2372
stddma   = $E9D5 = 59861          cpm22.asm:339
stfilpos = $F601 = 62977          cpm22.asm:2276
stkarea  = $F344 = 62276          cpm22.asm:1698
stnrec1  = $F4E1 = 62689          cpm22.asm:2016
strdata  = $F4BE = 62654          cpm22.asm:1995
ststatus = $F704 = 63236          cpm22.asm:2483
subhl    = $F598 = 62872          cpm22.asm:2186
synerr   = $EA09 = 59913          cpm22.asm:377
synerr1  = $EA0F = 59919          cpm22.asm:379
synerr2  = $EA22 = 59938          cpm22.asm:389
tab      = $0009 =     9          cpm22.asm:29
tbase    = $0100 =   256          cpm22.asm:22
tbuff    = $0080 =   128          cpm22.asm:21
tdrive   = $0004 =     4          cpm22.asm:18
tfcb     = $005C =    92          cpm22.asm:20
trksec   = $F3C6 = 62406          cpm22.asm:1804
trksec1  = $F3D4 = 62420          cpm22.asm:1813
trksec2  = $F3E7 = 62439          cpm22.asm:1826
trksec3  = $F3FD = 62461          cpm22.asm:1842
trksec4  = $F412 = 62482          cpm22.asm:1859
type     = $ED5D = 60765          cpm22.asm:908
type1    = $ED74 = 60788          cpm22.asm:916
type2    = $ED77 = 60791          cpm22.asm:917 (unused)
type3    = $ED87 = 60807          cpm22.asm:926
type4    = $EDA0 = 60832          cpm22.asm:939
type5    = $EDA7 = 60839          cpm22.asm:942
unknown  = $EEA5 = 61093          cpm22.asm:1080
unkwn0   = $EF71 = 61297          cpm22.asm:1188
unkwn1   = $EEC4 = 61124          cpm22.asm:1095
unkwn2   = $EECD = 61133          cpm22.asm:1099 (unused)
unkwn3   = $EEE1 = 61153          cpm22.asm:1110
unkwn4   = $EF01 = 61185          cpm22.asm:1129
unkwn5   = $EF30 = 61232          cpm22.asm:1150
unkwn6   = $EF3E = 61246          cpm22.asm:1160
unkwn7   = $EF43 = 61251          cpm22.asm:1162
unkwn8   = $EF4F = 61263          cpm22.asm:1170
unkwn9   = $EF6B = 61291          cpm22.asm:1186
update   = $F804 = 63492          cpm22.asm:2692
update1  = $F813 = 63507          cpm22.asm:2700
upper    = $E930 = 59696          cpm22.asm:228
user     = $EE8E = 61070          cpm22.asm:1064
userdma  = $FDB4 = 64948          cpm22.asm:3655
userno   = $F344 = 62276          cpm22.asm:1700
usrstack = $F312 = 62226          cpm22.asm:1694
verify   = $E9F5 = 59893          cpm22.asm:363
verify1  = $E9FD = 59901          cpm22.asm:366
wboot    = $FE04 = 65028          bios.asm:11
write    = $FE2B = 65067          bios.asm:24
writeran = $FB9F = 64415          cpm22.asm:3261
wrtprt   = $FDB0 = 64944          cpm22.asm:3653
wrtprtd  = $F52F = 62767          cpm22.asm:2089
wrtrec   = $E904 = 59652          cpm22.asm:183
wrtseq   = $FCE9 = 64745          cpm22.asm:3498
wtrandom = $FD4A = 64842          cpm22.asm:3572
wtseq    = $FA01 = 64001          cpm22.asm:2991
wtseq1   = $FA06 = 64006          cpm22.asm:2993
wtseq10  = $FAD5 = 64213          cpm22.asm:3108
wtseq11  = $FB01 = 64257          cpm22.asm:3132
wtseq12  = $FB03 = 64259          cpm22.asm:3133
wtseq2   = $FA3E = 64062          cpm22.asm:3016
wtseq3   = $FA4B = 64075          cpm22.asm:3022
wtseq4   = $FA67 = 64103          cpm22.asm:3034
wtseq5   = $FA6F = 64111          cpm22.asm:3041
wtseq6   = $FA71 = 64113          cpm22.asm:3042
wtseq7   = $FA8F = 64143          cpm22.asm:3065
wtseq8   = $FA9D = 64157          cpm22.asm:3072
wtseq9   = $FABE = 64190          cpm22.asm:3092
wtseq99  = $FAE2 = 64226          cpm22.asm:3119 (unused)
wtspecl  = $FD9E = 64926          cpm22.asm:3638
xlate    = $FDD3 = 64979          cpm22.asm:3681
yesno    = $ED52 = 60754          cpm22.asm:900


total time: 0.0188 sec.
no errors
