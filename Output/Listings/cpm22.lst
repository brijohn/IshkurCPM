              	; --------------------------------------
              	; zasm: assemble "cpm22.asm"
              	; date: 2023-02-28 13:50:21
              	; --------------------------------------


              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;*      Modified to build as single image from source
              	;*
              	;**************************************************************
              	
              	
0003:         	iobyte	equ	3		;i/o definition byte.
0004:         	tdrive	equ	4		;current drive name and user number.
0005:         	entry	equ	5		;entry point for the cp/m bdos.
005C:         	tfcb	equ	5ch		;default file control block.
0080:         	tbuff	equ	80h		;i/o buffer and command line storage.
0100:         	tbase	equ	100h		;transiant program storage area.
              	;
              	;   set control character equates.
              	;
0003:         	cntrlc	equ	3		;control-c
0005:         	cntrle	equ	05h		;control-e
0008:         	bs	equ	08h		;backspace
0009:         	tab	equ	09h		;tab
000A:         	lf	equ	0ah		;line feed
000C:         	ff	equ	0ch		;form feed
000D:         	cr	equ	0dh		;carriage return
0010:         	cntrlp	equ	10h		;control-p
0012:         	cntrlr	equ	12h		;control-r
0013:         	cntrls	equ	13h		;control-s
0015:         	cntrlu	equ	15h		;control-u
0018:         	cntrlx	equ	18h		;control-x
001A:         	cntrlz	equ	1ah		;control-z (end-of-file mark)
007F:         	del	equ	7fh		;rubout
              	;
              	;   set origin for cp/m
              	;
E000:         		org	(mem)*1024
              	;
E000: C35CE3  	cbase:	jp	command		;execute command processor (ccp).
E003: C358E3  		jp	clearbuf	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   standard cp/m ccp input buffer. format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
E006: 7F      	inbuff:	defb	127		;length of input buffer.
E007: 00      		defb	0		;current length of contents.
E008: 436F7079		defb	'Copyright'
E00C: 72696768	
E010: 74      	
E011: 20313937		defb	' 1979 (c) by Digital Research      '
E015: 39202863	
E019: 29206279	
E01D: 20446967	
E021: 6974616C	
E025: 20526573	
E029: 65617263	
E02D: 68202020	
E031: 202020  	
E034: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E038: 00...   	
E04B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E04F: 00...   	
E062: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E066: 00...   	
E079: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E07D: 00...   	
E088: 08E0    	inpoint:defw	inbuff+2	;input line pointer
E08A: 0000    	namepnt:defw	0		;input line pointer used for error message. points to
              	;			;start of name in error.
              	;
              	;   routine to print (a) on the console. all registers used.
              	;
E08C: 5F      	print:	ld	e,a		;setup bdos call.
E08D: 0E02    		ld	c,2
E08F: C30500  		jp	entry
              	;
              	;   routine to print (a) on the console and to save (bc).
              	;
E092: C5      	printb:	push	bc
E093: CD8CE0  		call	print
E096: C1      		pop	bc
E097: C9      		ret	
              	;
              	;   routine to send a carriage return, line feed combination
              	; to the console.
              	;
E098: 3E0D    	crlf:	ld	a,cr
E09A: CD92E0  		call	printb
E09D: 3E0A    		ld	a,lf
E09F: C392E0  		jp	printb
              	;
              	;   routine to send one space to the console and save (bc).
              	;
E0A2: 3E20    	space:	ld	a,' '
E0A4: C392E0  		jp	printb
              	;
              	;   routine to print character string pointed to be (bc) on the
              	; console. it must terminate with a null byte.
              	;
E0A7: C5      	pline:	push	bc
E0A8: CD98E0  		call	crlf
E0AB: E1      		pop	hl
E0AC: 7E      	pline2:	ld	a,(hl)
E0AD: B7      		or	a
E0AE: C8      		ret	z
E0AF: 23      		inc	hl
E0B0: E5      		push	hl
E0B1: CD8CE0  		call	print
E0B4: E1      		pop	hl
E0B5: C3ACE0  		jp	pline2
              	;
              	;   routine to reset the disk system.
              	;
E0B8: 0E0D    	resdsk:	ld	c,13
E0BA: C30500  		jp	entry
              	;
              	;   routine to select disk (a).
              	;
E0BD: 5F      	dsksel:	ld	e,a
E0BE: 0E0E    		ld	c,14
E0C0: C30500  		jp	entry
              	;
              	;   routine to call bdos and save the return code. the zero
              	; flag is set on a return of 0ffh.
              	;
E0C3: CD0500  	entry1:	call	entry
E0C6: 32EEE7  		ld	(rtncode),a	;save return code.
E0C9: 3C      		inc	a		;set zero if 0ffh returned.
E0CA: C9      		ret	
              	;
              	;   routine to open a file. (de) must point to the fcb.
              	;
E0CB: 0E0F    	open:	ld	c,15
E0CD: C3C3E0  		jp	entry1
              	;
              	;   routine to open file at (fcb).
              	;
E0D0: AF      	openfcb:xor	a		;clear the record number byte at fcb+32
E0D1: 32EDE7  		ld	(fcb+32),a
E0D4: 11CDE7  		ld	de,fcb
E0D7: C3CBE0  		jp	open
              	;
              	;   routine to close a file. (de) points to fcb.
              	;
E0DA: 0E10    	close:	ld	c,16
E0DC: C3C3E0  		jp	entry1
              	;
              	;   routine to search for the first file with ambigueous name
              	; (de).
              	;
E0DF: 0E11    	srchfst:ld	c,17
E0E1: C3C3E0  		jp	entry1
              	;
              	;   search for the next ambigeous file name.
              	;
E0E4: 0E12    	srchnxt:ld	c,18
E0E6: C3C3E0  		jp	entry1
              	;
              	;   search for file at (fcb).
              	;
E0E9: 11CDE7  	srchfcb:ld	de,fcb
E0EC: C3DFE0  		jp	srchfst
              	;
              	;   routine to delete a file pointed to by (de).
              	;
E0EF: 0E13    	delete:	ld	c,19
E0F1: C30500  		jp	entry
              	;
              	;   routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
E0F4: CD0500  	entry2:	call	entry
E0F7: B7      		or	a		;set zero flag if appropriate.
E0F8: C9      		ret	
              	;
              	;   routine to read the next record from a sequential file.
              	; (de) points to the fcb.
              	;
E0F9: 0E14    	rdrec:	ld	c,20
E0FB: C3F4E0  		jp	entry2
              	;
              	;   routine to read file at (fcb).
              	;
E0FE: 11CDE7  	readfcb:ld	de,fcb
E101: C3F9E0  		jp	rdrec
              	;
              	;   routine to write the next record of a sequential file.
              	; (de) points to the fcb.
              	;
E104: 0E15    	wrtrec:	ld	c,21
E106: C3F4E0  		jp	entry2
              	;
              	;   routine to create the file pointed to by (de).
              	;
E109: 0E16    	create:	ld	c,22
E10B: C3C3E0  		jp	entry1
              	;
              	;   routine to rename the file pointed to by (de). note that
              	; the new name starts at (de+16).
              	;
E10E: 0E17    	renam:	ld	c,23
E110: C30500  		jp	entry
              	;
              	;   get the current user code.
              	;
E113: 1EFF    	getusr:	ld	e,0ffh
              	;
              	;   routne to get or set the current user code.
              	; if (e) is ff then this is a get, else it is a set.
              	;
E115: 0E20    	getsetuc: ld	c,32
E117: C30500  		jp	entry
              	;
              	;   routine to set the current drive byte at (tdrive).
              	;
E11A: CD13E1  	setcdrv:call	getusr		;get user number
E11D: 87      		add	a,a		;and shift into the upper 4 bits.
E11E: 87      		add	a,a
E11F: 87      		add	a,a
E120: 87      		add	a,a
E121: 21EFE7  		ld	hl,cdrive	;now add in the current drive number.
E124: B6      		or	(hl)
E125: 320400  		ld	(tdrive),a	;and save.
E128: C9      		ret	
              	;
              	;   move currently active drive down to (tdrive).
              	;
E129: 3AEFE7  	movecd:	ld	a,(cdrive)
E12C: 320400  		ld	(tdrive),a
E12F: C9      		ret	
              	;
              	;   routine to convert (a) into upper case ascii. only letters
              	; are affected.
              	;
E130: FE61    	upper:	cp	'a'		;check for letters in the range of 'a' to 'z'.
E132: D8      		ret	c
E133: FE7B    		cp	'{'
E135: D0      		ret	nc
E136: E65F    		and	5fh		;convert it if found.
E138: C9      		ret	
              	;
              	;   routine to get a line of input. we must check to see if the
              	; user is in (batch) mode. if so, then read the input from file
              	; ($$$.sub). at the end, reset to console input.
              	;
E139: 3AABE7  	getinp:	ld	a,(batch)	;if =0, then use console input.
E13C: B7      		or	a
E13D: CA96E1  		jp	z,getinp1
              	;
              	;   use the submit file ($$$.sub) which is prepared by a
              	; submit run. it must be on drive (a) and it will be deleted
              	; if and error occures (like eof).
              	;
E140: 3AEFE7  		ld	a,(cdrive)	;select drive 0 if need be.
E143: B7      		or	a
E144: 3E00    		ld	a,0		;always use drive a for submit.
E146: C4BDE0  		call	nz,dsksel	;select it if required.
E149: 11ACE7  		ld	de,batchfcb
E14C: CDCBE0  		call	open		;look for it.
E14F: CA96E1  		jp	z,getinp1	;if not there, use normal input.
E152: 3ABBE7  		ld	a,(batchfcb+15)	;get last record number+1.
E155: 3D      		dec	a
E156: 32CCE7  		ld	(batchfcb+32),a
E159: 11ACE7  		ld	de,batchfcb
E15C: CDF9E0  		call	rdrec		;read last record.
E15F: C296E1  		jp	nz,getinp1	;quit on end of file.
              	;
              	;   move this record into input buffer.
              	;
E162: 1107E0  		ld	de,inbuff+1
E165: 218000  		ld	hl,tbuff	;data was read into buffer here.
E168: 0680    		ld	b,128		;all 128 characters may be used.
E16A: CD42E4  		call	hl2de		;(hl) to (de), (b) bytes.
E16D: 21BAE7  		ld	hl,batchfcb+14
E170: 3600    		ld	(hl),0		;zero out the 's2' byte.
E172: 23      		inc	hl		;and decrement the record count.
E173: 35      		dec	(hl)
E174: 11ACE7  		ld	de,batchfcb	;close the batch file now.
E177: CDDAE0  		call	close
E17A: CA96E1  		jp	z,getinp1	;quit on an error.
E17D: 3AEFE7  		ld	a,(cdrive)	;re-select previous drive if need be.
E180: B7      		or	a
E181: C4BDE0  		call	nz,dsksel	;don't do needless selects.
              	;
              	;   print line just read on console.
              	;
E184: 2108E0  		ld	hl,inbuff+2
E187: CDACE0  		call	pline2
E18A: CDC2E1  		call	chkcon		;check console, quit on a key.
E18D: CAA7E1  		jp	z,getinp2	;jump if no key is pressed.
              	;
              	;   terminate the submit job on any keyboard input. delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
E190: CDDDE1  		call	delbatch	;delete the batch file.
E193: C382E3  		jp	cmmnd1		;and restart command input.
              	;
              	;   get here for normal keyboard input. delete the submit file
              	; incase there was one.
              	;
E196: CDDDE1  	getinp1:call	delbatch	;delete file ($$$.sub).
E199: CD1AE1  		call	setcdrv		;reset active disk.
E19C: 0E0A    		ld	c,10		;get line from console device.
E19E: 1106E0  		ld	de,inbuff
E1A1: CD0500  		call	entry
E1A4: CD29E1  		call	movecd		;reset current drive (again).
              	;
              	;   convert input line to upper case.
              	;
E1A7: 2107E0  	getinp2:ld	hl,inbuff+1
E1AA: 46      		ld	b,(hl)		;(b)=character counter.
E1AB: 23      	getinp3:inc	hl
E1AC: 78      		ld	a,b		;end of the line?
E1AD: B7      		or	a
E1AE: CABAE1  		jp	z,getinp4
E1B1: 7E      		ld	a,(hl)		;convert to upper case.
E1B2: CD30E1  		call	upper
E1B5: 77      		ld	(hl),a
E1B6: 05      		dec	b		;adjust character count.
E1B7: C3ABE1  		jp	getinp3
E1BA: 77      	getinp4:ld	(hl),a		;add trailing null.
E1BB: 2108E0  		ld	hl,inbuff+2
E1BE: 2288E0  		ld	(inpoint),hl	;reset input line pointer.
E1C1: C9      		ret	
              	;
              	;   routine to check the console for a key pressed. the zero
              	; flag is set is none, else the character is returned in (a).
              	;
E1C2: 0E0B    	chkcon:	ld	c,11		;check console.
E1C4: CD0500  		call	entry
E1C7: B7      		or	a
E1C8: C8      		ret	z		;return if nothing.
E1C9: 0E01    		ld	c,1		;else get character.
E1CB: CD0500  		call	entry
E1CE: B7      		or	a		;clear zero flag and return.
E1CF: C9      		ret	
              	;
              	;   routine to get the currently active drive number.
              	;
E1D0: 0E19    	getdsk:	ld	c,25
E1D2: C30500  		jp	entry
              	;
              	;   set the stabdard dma address.
              	;
E1D5: 118000  	stddma:	ld	de,tbuff
              	;
              	;   routine to set the dma address to (de).
              	;
E1D8: 0E1A    	dmaset:	ld	c,26
E1DA: C30500  		jp	entry
              	;
              	;  delete the batch file created by submit.
              	;
E1DD: 21ABE7  	delbatch: ld	hl,batch	;is batch active?
E1E0: 7E      		ld	a,(hl)
E1E1: B7      		or	a
E1E2: C8      		ret	z
E1E3: 3600    		ld	(hl),0		;yes, de-activate it.
E1E5: AF      		xor	a
E1E6: CDBDE0  		call	dsksel		;select drive 0 for sure.
E1E9: 11ACE7  		ld	de,batchfcb	;and delete this file.
E1EC: CDEFE0  		call	delete
E1EF: 3AEFE7  		ld	a,(cdrive)	;reset current drive.
E1F2: C3BDE0  		jp	dsksel
              	;
              	;   check to two strings at (pattrn1) and (pattrn2). they must be
              	; the same or we halt....
              	;
E1F5: 1128E3  	verify:	ld	de,pattrn1	;these are the serial number bytes.
E1F8: 2100E8  		ld	hl,pattrn2	;ditto, but how could they be different?
E1FB: 0606    		ld	b,6		;6 bytes each.
E1FD: 1A      	verify1:ld	a,(de)
E1FE: BE      		cp	(hl)
E1FF: C2CFE3  		jp	nz,halt		;jump to halt routine.
E202: 13      		inc	de
E203: 23      		inc	hl
E204: 05      		dec	b
E205: C2FDE1  		jp	nz,verify1
E208: C9      		ret	
              	;
              	;   print back file name with a '?' to indicate a syntax error.
              	;
E209: CD98E0  	synerr:	call	crlf		;end current line.
E20C: 2A8AE0  		ld	hl,(namepnt)	;this points to name in error.
E20F: 7E      	synerr1:ld	a,(hl)		;print it until a space or null is found.
E210: FE20    		cp	' '
E212: CA22E2  		jp	z,synerr2
E215: B7      		or	a
E216: CA22E2  		jp	z,synerr2
E219: E5      		push	hl
E21A: CD8CE0  		call	print
E21D: E1      		pop	hl
E21E: 23      		inc	hl
E21F: C30FE2  		jp	synerr1
E222: 3E3F    	synerr2:ld	a,'?'		;add trailing '?'.
E224: CD8CE0  		call	print
E227: CD98E0  		call	crlf
E22A: CDDDE1  		call	delbatch	;delete any batch file.
E22D: C382E3  		jp	cmmnd1		;and restart from console input.
              	;
              	;   check character at (de) for legal command input. note that the
              	; zero flag is set if the character is a delimiter.
              	;
E230: 1A      	check:	ld	a,(de)
E231: B7      		or	a
E232: C8      		ret	z
E233: FE20    		cp	' '		;control characters are not legal here.
E235: DA09E2  		jp	c,synerr
E238: C8      		ret	z		;check for valid delimiter.
E239: FE3D    		cp	'='
E23B: C8      		ret	z
E23C: FE5F    		cp	'_'
E23E: C8      		ret	z
E23F: FE2E    		cp	'.'
E241: C8      		ret	z
E242: FE3A    		cp	':'
E244: C8      		ret	z
E245: FE3B    		cp	';'
E247: C8      		ret	z
E248: FE3C    		cp	'<'
E24A: C8      		ret	z
E24B: FE3E    		cp	'>'
E24D: C8      		ret	z
E24E: C9      		ret	
              	;
              	;   get the next non-blank character from (de).
              	;
E24F: 1A      	nonblank: ld	a,(de)
E250: B7      		or	a		;string ends with a null.
E251: C8      		ret	z
E252: FE20    		cp	' '
E254: C0      		ret	nz
E255: 13      		inc	de
E256: C34FE2  		jp	nonblank
              	;
              	;   add (hl)=(hl)+(a)
              	;
E259: 85      	addhl:	add	a,l
E25A: 6F      		ld	l,a
E25B: D0      		ret	nc		;take care of any carry.
E25C: 24      		inc	h
E25D: C9      		ret	
              	;
              	;   convert the first name in (fcb).
              	;
E25E: 3E00    	convfst:ld	a,0
              	;
              	;   format a file name (convert * to '?', etc.). on return,
              	; (a)=0 is an unambigeous name was specified. enter with (a) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
E260: 21CDE7  	convert:ld	hl,fcb
E263: CD59E2  		call	addhl
E266: E5      		push	hl
E267: E5      		push	hl
E268: AF      		xor	a
E269: 32F0E7  		ld	(chgdrv),a	;initialize drive change flag.
E26C: 2A88E0  		ld	hl,(inpoint)	;set (hl) as pointer into input line.
E26F: EB      		ex	de,hl
E270: CD4FE2  		call	nonblank	;get next non-blank character.
E273: EB      		ex	de,hl
E274: 228AE0  		ld	(namepnt),hl	;save pointer here for any error message.
E277: EB      		ex	de,hl
E278: E1      		pop	hl
E279: 1A      		ld	a,(de)		;get first character.
E27A: B7      		or	a
E27B: CA89E2  		jp	z,convrt1
E27E: DE40    		sbc	a,'A'-1		;might be a drive name, convert to binary.
E280: 47      		ld	b,a		;and save.
E281: 13      		inc	de		;check next character for a ':'.
E282: 1A      		ld	a,(de)
E283: FE3A    		cp	':'
E285: CA90E2  		jp	z,convrt2
E288: 1B      		dec	de		;nope, move pointer back to the start of the line.
E289: 3AEFE7  	convrt1:ld	a,(cdrive)
E28C: 77      		ld	(hl),a
E28D: C396E2  		jp	convrt3
E290: 78      	convrt2:ld	a,b
E291: 32F0E7  		ld	(chgdrv),a	;set change in drives flag.
E294: 70      		ld	(hl),b
E295: 13      		inc	de
              	;
              	;   convert the basic file name.
              	;
E296: 0608    	convrt3:ld	b,08h
E298: CD30E2  	convrt4:call	check
E29B: CAB9E2  		jp	z,convrt8
E29E: 23      		inc	hl
E29F: FE2A    		cp	'*'		;note that an '*' will fill the remaining
E2A1: C2A9E2  		jp	nz,convrt5	;field with '?'.
E2A4: 363F    		ld	(hl),'?'
E2A6: C3ABE2  		jp	convrt6
E2A9: 77      	convrt5:ld	(hl),a
E2AA: 13      		inc	de
E2AB: 05      	convrt6:dec	b
E2AC: C298E2  		jp	nz,convrt4
E2AF: CD30E2  	convrt7:call	check		;get next delimiter.
E2B2: CAC0E2  		jp	z,getext
E2B5: 13      		inc	de
E2B6: C3AFE2  		jp	convrt7
E2B9: 23      	convrt8:inc	hl		;blank fill the file name.
E2BA: 3620    		ld	(hl),' '
E2BC: 05      		dec	b
E2BD: C2B9E2  		jp	nz,convrt8
              	;
              	;   get the extension and convert it.
              	;
E2C0: 0603    	getext:	ld	b,03h
E2C2: FE2E    		cp	'.'
E2C4: C2E9E2  		jp	nz,getext5
E2C7: 13      		inc	de
E2C8: CD30E2  	getext1:call	check
E2CB: CAE9E2  		jp	z,getext5
E2CE: 23      		inc	hl
E2CF: FE2A    		cp	'*'
E2D1: C2D9E2  		jp	nz,getext2
E2D4: 363F    		ld	(hl),'?'
E2D6: C3DBE2  		jp	getext3
E2D9: 77      	getext2:ld	(hl),a
E2DA: 13      		inc	de
E2DB: 05      	getext3:dec	b
E2DC: C2C8E2  		jp	nz,getext1
E2DF: CD30E2  	getext4:call	check
E2E2: CAF0E2  		jp	z,getext6
E2E5: 13      		inc	de
E2E6: C3DFE2  		jp	getext4
E2E9: 23      	getext5:inc	hl
E2EA: 3620    		ld	(hl),' '
E2EC: 05      		dec	b
E2ED: C2E9E2  		jp	nz,getext5
E2F0: 0603    	getext6:ld	b,3
E2F2: 23      	getext7:inc	hl
E2F3: 3600    		ld	(hl),0
E2F5: 05      		dec	b
E2F6: C2F2E2  		jp	nz,getext7
E2F9: EB      		ex	de,hl
E2FA: 2288E0  		ld	(inpoint),hl	;save input line pointer.
E2FD: E1      		pop	hl
              	;
              	;   check to see if this is an ambigeous file name specification.
              	; set the (a) register to non zero if it is.
              	;
E2FE: 010B00  		ld	bc,11		;set name length.
E301: 23      	getext8:inc	hl
E302: 7E      		ld	a,(hl)
E303: FE3F    		cp	'?'		;any question marks?
E305: C209E3  		jp	nz,getext9
E308: 04      		inc	b		;count them.
E309: 0D      	getext9:dec	c
E30A: C201E3  		jp	nz,getext8
E30D: 78      		ld	a,b
E30E: B7      		or	a
E30F: C9      		ret	
              	;
              	;   cp/m command table. note commands can be either 3 or 4 characters long.
              	;
0006:         	numcmds equ	6		;number of commands
E310: 44495220	cmdtbl:	defb	'DIR '
E314: 45524120		defb	'ERA '
E318: 54595045		defb	'TYPE'
E31C: 53415645		defb	'SAVE'
E320: 52454E20		defb	'REN '
E324: 55534552		defb	'USER'
              	;
              	;   the following six bytes must agree with those at (pattrn2)
              	; or cp/m will halt. why?
              	;
E328: 00160000	pattrn1:defb	0,22,0,0,0,0	;(* serial number bytes *).
E32C: 0000    	
              	;
              	;   search the command table for a match with what has just
              	; been entered. if a match is found, then we jump to the
              	; proper section. else jump to (unknown).
              	; on return, the (c) register is set to the command number
              	; that matched (or numcmds+1 if no match).
              	;
E32E: 2110E3  	search:	ld	hl,cmdtbl
E331: 0E00    		ld	c,0
E333: 79      	search1:ld	a,c
E334: FE06    		cp	numcmds		;this commands exists.
E336: D0      		ret	nc
E337: 11CEE7  		ld	de,fcb+1	;check this one.
E33A: 0604    		ld	b,4		;max command length.
E33C: 1A      	search2:ld	a,(de)
E33D: BE      		cp	(hl)
E33E: C24FE3  		jp	nz,search3	;not a match.
E341: 13      		inc	de
E342: 23      		inc	hl
E343: 05      		dec	b
E344: C23CE3  		jp	nz,search2
E347: 1A      		ld	a,(de)		;allow a 3 character command to match.
E348: FE20    		cp	' '
E34A: C254E3  		jp	nz,search4
E34D: 79      		ld	a,c		;set return register for this command.
E34E: C9      		ret	
E34F: 23      	search3:inc	hl
E350: 05      		dec	b
E351: C24FE3  		jp	nz,search3
E354: 0C      	search4:inc	c
E355: C333E3  		jp	search1
              	;
              	;   set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
E358: AF      	clearbuf: xor	a
E359: 3207E0  		ld	(inbuff+1),a	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
E35C: 31ABE7  	command:ld	sp,ccpstack	;setup stack area.
E35F: C5      		push	bc		;note that (c) should be equal to:
E360: 79      		ld	a,c		;(uuuudddd) where 'uuuu' is the user number
E361: 1F      		rra			;and 'dddd' is the drive number.
E362: 1F      		rra	
E363: 1F      		rra	
E364: 1F      		rra	
E365: E60F    		and	0fh		;isolate the user number.
E367: 5F      		ld	e,a
E368: CD15E1  		call	getsetuc	;and set it.
E36B: CDB8E0  		call	resdsk		;reset the disk system.
E36E: 32ABE7  		ld	(batch),a	;clear batch mode flag.
E371: C1      		pop	bc
E372: 79      		ld	a,c
E373: E60F    		and	0fh		;isolate the drive number.
E375: 32EFE7  		ld	(cdrive),a	;and save.
E378: CDBDE0  		call	dsksel		;...and select.
E37B: 3A07E0  		ld	a,(inbuff+1)
E37E: B7      		or	a		;anything in input buffer already?
E37F: C298E3  		jp	nz,cmmnd2	;yes, we just process it.
              	;
              	;   entry point to get a command line from the console.
              	;
E382: 31ABE7  	cmmnd1:	ld	sp,ccpstack	;set stack straight.
E385: CD98E0  		call	crlf		;start a new line on the screen.
E388: CDD0E1  		call	getdsk		;get current drive.
E38B: C641    		add	a,'A'
E38D: CD8CE0  		call	print		;print current drive.
E390: 3E3E    		ld	a,'>'
E392: CD8CE0  		call	print		;and add prompt.
E395: CD39E1  		call	getinp		;get line from user.
              	;
              	;   process command line here.
              	;
E398: 118000  	cmmnd2:	ld	de,tbuff
E39B: CDD8E1  		call	dmaset		;set standard dma address.
E39E: CDD0E1  		call	getdsk
E3A1: 32EFE7  		ld	(cdrive),a	;set current drive.
E3A4: CD5EE2  		call	convfst		;convert name typed in.
E3A7: C409E2  		call	nz,synerr	;wild cards are not allowed.
E3AA: 3AF0E7  		ld	a,(chgdrv)	;if a change in drives was indicated,
E3AD: B7      		or	a		;then treat this as an unknown command
E3AE: C2A5E6  		jp	nz,unknown	;which gets executed.
E3B1: CD2EE3  		call	search		;else search command table for a match.
              	;
              	;   note that an unknown command returns
              	; with (a) pointing to the last address
              	; in our table which is (unknown).
              	;
E3B4: 21C1E3  		ld	hl,cmdadr	;now, look thru our address table for command (a).
E3B7: 5F      		ld	e,a		;set (de) to command number.
E3B8: 1600    		ld	d,0
E3BA: 19      		add	hl,de
E3BB: 19      		add	hl,de		;(hl)=(cmdadr)+2*(command number).
E3BC: 7E      		ld	a,(hl)		;now pick out this address.
E3BD: 23      		inc	hl
E3BE: 66      		ld	h,(hl)
E3BF: 6F      		ld	l,a
E3C0: E9      		jp	(hl)		;now execute it.
              	;
              	;   cp/m command address table.
              	;
E3C1: 77E41FE5	cmdadr:	defw	direct,erase,type,save
E3C5: 5DE5ADE5	
E3C9: 10E68EE6		defw	rename,user,unknown
E3CD: A5E6    	
              	;
              	;   halt the system. reason for this is unknown at present.
              	;
E3CF: 21F376  	halt:	ld	hl,76f3h	;'di hlt' instructions.
E3D2: 2200E0  		ld	(cbase),hl
E3D5: 2100E0  		ld	hl,cbase
E3D8: E9      		jp	(hl)
              	;
              	;   read error while typeing a file.
              	;
E3D9: 01DFE3  	rderror:ld	bc,rderr
E3DC: C3A7E0  		jp	pline
E3DF: 72656164	rderr:	defb	'read error',0
E3E3: 20657272	
E3E7: 6F7200  	
              	;
              	;   required file was not located.
              	;
E3EA: 01F0E3  	none:	ld	bc,nofile
E3ED: C3A7E0  		jp	pline
E3F0: 6E6F2066	nofile:	defb	'no file',0
E3F4: 696C6500	
              	;
              	;   decode a command of the form 'a>filename number{ filename}.
              	; note that a drive specifier is not allowed on the first file
              	; name. on return, the number is in register (a). any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
E3F8: CD5EE2  	decode:	call	convfst		;convert filename.
E3FB: 3AF0E7  		ld	a,(chgdrv)	;do not allow a drive to be specified.
E3FE: B7      		or	a
E3FF: C209E2  		jp	nz,synerr
E402: 21CEE7  		ld	hl,fcb+1	;convert number now.
E405: 010B00  		ld	bc,11		;(b)=sum register, (c)=max digit count.
E408: 7E      	decode1:ld	a,(hl)
E409: FE20    		cp	' '		;a space terminates the numeral.
E40B: CA33E4  		jp	z,decode3
E40E: 23      		inc	hl
E40F: D630    		sub	'0'		;make binary from ascii.
E411: FE0A    		cp	10		;legal digit?
E413: D209E2  		jp	nc,synerr
E416: 57      		ld	d,a		;yes, save it in (d).
E417: 78      		ld	a,b		;compute (b)=(b)*10 and check for overflow.
E418: E6E0    		and	0e0h
E41A: C209E2  		jp	nz,synerr
E41D: 78      		ld	a,b
E41E: 07      		rlca	
E41F: 07      		rlca	
E420: 07      		rlca			;(a)=(b)*8
E421: 80      		add	a,b		;.......*9
E422: DA09E2  		jp	c,synerr
E425: 80      		add	a,b		;.......*10
E426: DA09E2  		jp	c,synerr
E429: 82      		add	a,d		;add in new digit now.
E42A: DA09E2  	decode2:jp	c,synerr
E42D: 47      		ld	b,a		;and save result.
E42E: 0D      		dec	c		;only look at 11 digits.
E42F: C208E4  		jp	nz,decode1
E432: C9      		ret	
E433: 7E      	decode3:ld	a,(hl)		;spaces must follow (why?).
E434: FE20    		cp	' '
E436: C209E2  		jp	nz,synerr
E439: 23      		inc	hl
E43A: 0D      	decode4:dec	c
E43B: C233E4  		jp	nz,decode3
E43E: 78      		ld	a,b		;set (a)=the numeric value entered.
E43F: C9      		ret	
              	;
              	;   move 3 bytes from (hl) to (de). note that there is only
              	; one reference to this at (a2d5h).
              	;
E440: 0603    	move3:	ld	b,3
              	;
              	;   move (b) bytes from (hl) to (de).
              	;
E442: 7E      	hl2de:	ld	a,(hl)
E443: 12      		ld	(de),a
E444: 23      		inc	hl
E445: 13      		inc	de
E446: 05      		dec	b
E447: C242E4  		jp	nz,hl2de
E44A: C9      		ret	
              	;
              	;   compute (hl)=(tbuff)+(a)+(c) and get the byte that's here.
              	;
E44B: 218000  	extract:ld	hl,tbuff
E44E: 81      		add	a,c
E44F: CD59E2  		call	addhl
E452: 7E      		ld	a,(hl)
E453: C9      		ret	
              	;
              	;  check drive specified. if it means a change, then the new
              	; drive will be selected. in any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
E454: AF      	dselect:xor	a		;null out first byte of fcb.
E455: 32CDE7  		ld	(fcb),a
E458: 3AF0E7  		ld	a,(chgdrv)	;a drive change indicated?
E45B: B7      		or	a
E45C: C8      		ret	z
E45D: 3D      		dec	a		;yes, is it the same as the current drive?
E45E: 21EFE7  		ld	hl,cdrive
E461: BE      		cp	(hl)
E462: C8      		ret	z
E463: C3BDE0  		jp	dsksel		;no. select it then.
              	;
              	;   check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
E466: 3AF0E7  	resetdr:ld	a,(chgdrv)	;drive change indicated?
E469: B7      		or	a
E46A: C8      		ret	z
E46B: 3D      		dec	a		;yes, was it a different drive?
E46C: 21EFE7  		ld	hl,cdrive
E46F: BE      		cp	(hl)
E470: C8      		ret	z
E471: 3AEFE7  		ld	a,(cdrive)	;yes, re-select our old drive.
E474: C3BDE0  		jp	dsksel
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
E477: CD5EE2  	direct:	call	convfst		;convert file name.
E47A: CD54E4  		call	dselect		;select indicated drive.
E47D: 21CEE7  		ld	hl,fcb+1	;was any file indicated?
E480: 7E      		ld	a,(hl)
E481: FE20    		cp	' '
E483: C28FE4  		jp	nz,direct2
E486: 060B    		ld	b,11		;no. fill field with '?' - same as *.*.
E488: 363F    	direct1:ld	(hl),'?'
E48A: 23      		inc	hl
E48B: 05      		dec	b
E48C: C288E4  		jp	nz,direct1
E48F: 1E00    	direct2:ld	e,0		;set initial cursor position.
E491: D5      		push	de
E492: CDE9E0  		call	srchfcb		;get first file name.
E495: CCEAE3  		call	z,none		;none found at all?
E498: CA1BE5  	direct3:jp	z,direct9	;terminate if no more names.
E49B: 3AEEE7  		ld	a,(rtncode)	;get file's position in segment (0-3).
E49E: 0F      		rrca	
E49F: 0F      		rrca	
E4A0: 0F      		rrca	
E4A1: E660    		and	60h		;(a)=position*32
E4A3: 4F      		ld	c,a
E4A4: 3E0A    		ld	a,10
E4A6: CD4BE4  		call	extract		;extract the tenth entry in fcb.
E4A9: 17      		rla			;check system file status bit.
E4AA: DA0FE5  		jp	c,direct8	;we don't list them.
E4AD: D1      		pop	de
E4AE: 7B      		ld	a,e		;bump name count.
E4AF: 1C      		inc	e
E4B0: D5      		push	de
E4B1: E603    		and	03h		;at end of line?
E4B3: F5      		push	af
E4B4: C2CCE4  		jp	nz,direct4
E4B7: CD98E0  		call	crlf		;yes, end this line and start another.
E4BA: C5      		push	bc
E4BB: CDD0E1  		call	getdsk		;start line with ('a:').
E4BE: C1      		pop	bc
E4BF: C641    		add	a,'A'
E4C1: CD92E0  		call	printb
E4C4: 3E3A    		ld	a,':'
E4C6: CD92E0  		call	printb
E4C9: C3D4E4  		jp	direct5
E4CC: CDA2E0  	direct4:call	space		;add seperator between file names.
E4CF: 3E3A    		ld	a,':'
E4D1: CD92E0  		call	printb
E4D4: CDA2E0  	direct5:call	space
E4D7: 0601    		ld	b,1		;'extract' each file name character at a time.
E4D9: 78      	direct6:ld	a,b
E4DA: CD4BE4  		call	extract
E4DD: E67F    		and	7fh		;strip bit 7 (status bit).
E4DF: FE20    		cp	' '		;are we at the end of the name?
E4E1: C2F9E4  		jp	nz,drect65
E4E4: F1      		pop	af		;yes, don't print spaces at the end of a line.
E4E5: F5      		push	af
E4E6: FE03    		cp	3
E4E8: C2F7E4  		jp	nz,drect63
E4EB: 3E09    		ld	a,9		;first check for no extension.
E4ED: CD4BE4  		call	extract
E4F0: E67F    		and	7fh
E4F2: FE20    		cp	' '
E4F4: CA0EE5  		jp	z,direct7	;don't print spaces.
E4F7: 3E20    	drect63:ld	a,' '		;else print them.
E4F9: CD92E0  	drect65:call	printb
E4FC: 04      		inc	b		;bump to next character psoition.
E4FD: 78      		ld	a,b
E4FE: FE0C    		cp	12		;end of the name?
E500: D20EE5  		jp	nc,direct7
E503: FE09    		cp	9		;nope, starting extension?
E505: C2D9E4  		jp	nz,direct6
E508: CDA2E0  		call	space		;yes, add seperating space.
E50B: C3D9E4  		jp	direct6
E50E: F1      	direct7:pop	af		;get the next file name.
E50F: CDC2E1  	direct8:call	chkcon		;first check console, quit on anything.
E512: C21BE5  		jp	nz,direct9
E515: CDE4E0  		call	srchnxt		;get next name.
E518: C398E4  		jp	direct3		;and continue with our list.
E51B: D1      	direct9:pop	de		;restore the stack and return to command level.
E51C: C386E7  		jp	getback
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E51F: CD5EE2  	erase:	call	convfst		;convert file name.
E522: FE0B    		cp	11		;was '*.*' entered?
E524: C242E5  		jp	nz,erase1
E527: 0152E5  		ld	bc,yesno	;yes, ask for confirmation.
E52A: CDA7E0  		call	pline
E52D: CD39E1  		call	getinp
E530: 2107E0  		ld	hl,inbuff+1
E533: 35      		dec	(hl)		;must be exactly 'y'.
E534: C282E3  		jp	nz,cmmnd1
E537: 23      		inc	hl
E538: 7E      		ld	a,(hl)
E539: FE79    		cp	'y'
E53B: C282E3  		jp	nz,cmmnd1
E53E: 23      		inc	hl
E53F: 2288E0  		ld	(inpoint),hl	;save input line pointer.
E542: CD54E4  	erase1:	call	dselect		;select desired disk.
E545: 11CDE7  		ld	de,fcb
E548: CDEFE0  		call	delete		;delete the file.
E54B: 3C      		inc	a
E54C: CCEAE3  		call	z,none		;not there?
E54F: C386E7  		jp	getback		;return to command level now.
E552: 616C6C20	yesno:	defb	'all (y/n)?',0
E556: 28792F6E	
E55A: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E55D: CD5EE2  	type:	call	convfst		;convert file name.
E560: C209E2  		jp	nz,synerr	;wild cards not allowed.
E563: CD54E4  		call	dselect		;select indicated drive.
E566: CDD0E0  		call	openfcb		;open the file.
E569: CAA7E5  		jp	z,type5		;not there?
E56C: CD98E0  		call	crlf		;ok, start a new line on the screen.
E56F: 21F1E7  		ld	hl,nbytes	;initialize byte counter.
E572: 36FF    		ld	(hl),0ffh	;set to read first sector.
E574: 21F1E7  	type1:	ld	hl,nbytes
E577: 7E      	type2:	ld	a,(hl)		;have we written the entire sector?
E578: FE80    		cp	128
E57A: DA87E5  		jp	c,type3
E57D: E5      		push	hl		;yes, read in the next one.
E57E: CDFEE0  		call	readfcb
E581: E1      		pop	hl
E582: C2A0E5  		jp	nz,type4	;end or error?
E585: AF      		xor	a		;ok, clear byte counter.
E586: 77      		ld	(hl),a
E587: 34      	type3:	inc	(hl)		;count this byte.
E588: 218000  		ld	hl,tbuff	;and get the (a)th one from the buffer (tbuff).
E58B: CD59E2  		call	addhl
E58E: 7E      		ld	a,(hl)
E58F: FE1A    		cp	cntrlz		;end of file mark?
E591: CA86E7  		jp	z,getback
E594: CD8CE0  		call	print		;no, print it.
E597: CDC2E1  		call	chkcon		;check console, quit if anything ready.
E59A: C286E7  		jp	nz,getback
E59D: C374E5  		jp	type1
              	;
              	;   get here on an end of file or read error.
              	;
E5A0: 3D      	type4:	dec	a		;read error?
E5A1: CA86E7  		jp	z,getback
E5A4: CDD9E3  		call	rderror		;yes, print message.
E5A7: CD66E4  	type5:	call	resetdr		;and reset proper drive
E5AA: C309E2  		jp	synerr		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E5AD: CDF8E3  	save:	call	decode		;get numeric number that follows save.
E5B0: F5      		push	af		;save number of pages to write.
E5B1: CD5EE2  		call	convfst		;convert file name.
E5B4: C209E2  		jp	nz,synerr	;wild cards not allowed.
E5B7: CD54E4  		call	dselect		;select specified drive.
E5BA: 11CDE7  		ld	de,fcb		;now delete this file.
E5BD: D5      		push	de
E5BE: CDEFE0  		call	delete
E5C1: D1      		pop	de
E5C2: CD09E1  		call	create		;and create it again.
E5C5: CAFBE5  		jp	z,save3		;can't create?
E5C8: AF      		xor	a		;clear record number byte.
E5C9: 32EDE7  		ld	(fcb+32),a
E5CC: F1      		pop	af		;convert pages to sectors.
E5CD: 6F      		ld	l,a
E5CE: 2600    		ld	h,0
E5D0: 29      		add	hl,hl		;(hl)=number of sectors to write.
E5D1: 110001  		ld	de,tbase	;and we start from here.
E5D4: 7C      	save1:	ld	a,h		;done yet?
E5D5: B5      		or	l
E5D6: CAF1E5  		jp	z,save2
E5D9: 2B      		dec	hl		;nope, count this and compute the start
E5DA: E5      		push	hl		;of the next 128 byte sector.
E5DB: 218000  		ld	hl,128
E5DE: 19      		add	hl,de
E5DF: E5      		push	hl		;save it and set the transfer address.
E5E0: CDD8E1  		call	dmaset
E5E3: 11CDE7  		ld	de,fcb		;write out this sector now.
E5E6: CD04E1  		call	wrtrec
E5E9: D1      		pop	de		;reset (de) to the start of the last sector.
E5EA: E1      		pop	hl		;restore sector count.
E5EB: C2FBE5  		jp	nz,save3	;write error?
E5EE: C3D4E5  		jp	save1
              	;
              	;   get here after writing all of the file.
              	;
E5F1: 11CDE7  	save2:	ld	de,fcb		;now close the file.
E5F4: CDDAE0  		call	close
E5F7: 3C      		inc	a		;did it close ok?
E5F8: C201E6  		jp	nz,save4
              	;
              	;   print out error message (no space).
              	;
E5FB: 0107E6  	save3:	ld	bc,nospace
E5FE: CDA7E0  		call	pline
E601: CDD5E1  	save4:	call	stddma		;reset the standard dma address.
E604: C386E7  		jp	getback
E607: 6E6F2073	nospace:defb	'no space',0
E60B: 70616365	
E60F: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E610: CD5EE2  	rename:	call	convfst		;convert first file name.
E613: C209E2  		jp	nz,synerr	;wild cards not allowed.
E616: 3AF0E7  		ld	a,(chgdrv)	;remember any change in drives specified.
E619: F5      		push	af
E61A: CD54E4  		call	dselect		;and select this drive.
E61D: CDE9E0  		call	srchfcb		;is this file present?
E620: C279E6  		jp	nz,rename6	;yes, print error message.
E623: 21CDE7  		ld	hl,fcb		;yes, move this name into second slot.
E626: 11DDE7  		ld	de,fcb+16
E629: 0610    		ld	b,16
E62B: CD42E4  		call	hl2de
E62E: 2A88E0  		ld	hl,(inpoint)	;get input pointer.
E631: EB      		ex	de,hl
E632: CD4FE2  		call	nonblank	;get next non blank character.
E635: FE3D    		cp	'='		;only allow an '=' or '_' seperator.
E637: CA3FE6  		jp	z,rename1
E63A: FE5F    		cp	'_'
E63C: C273E6  		jp	nz,rename5
E63F: EB      	rename1:ex	de,hl
E640: 23      		inc	hl		;ok, skip seperator.
E641: 2288E0  		ld	(inpoint),hl	;save input line pointer.
E644: CD5EE2  		call	convfst		;convert this second file name now.
E647: C273E6  		jp	nz,rename5	;again, no wild cards.
E64A: F1      		pop	af		;if a drive was specified, then it
E64B: 47      		ld	b,a		;must be the same as before.
E64C: 21F0E7  		ld	hl,chgdrv
E64F: 7E      		ld	a,(hl)
E650: B7      		or	a
E651: CA59E6  		jp	z,rename2
E654: B8      		cp	b
E655: 70      		ld	(hl),b
E656: C273E6  		jp	nz,rename5	;they were different, error.
E659: 70      	rename2:ld	(hl),b		;	reset as per the first file specification.
E65A: AF      		xor	a
E65B: 32CDE7  		ld	(fcb),a		;clear the drive byte of the fcb.
E65E: CDE9E0  	rename3:call	srchfcb		;and go look for second file.
E661: CA6DE6  		jp	z,rename4	;doesn't exist?
E664: 11CDE7  		ld	de,fcb
E667: CD0EE1  		call	renam		;ok, rename the file.
E66A: C386E7  		jp	getback
              	;
              	;   process rename errors here.
              	;
E66D: CDEAE3  	rename4:call	none		;file not there.
E670: C386E7  		jp	getback
E673: CD66E4  	rename5:call	resetdr		;bad command format.
E676: C309E2  		jp	synerr
E679: 0182E6  	rename6:ld	bc,exists	;destination file already exists.
E67C: CDA7E0  		call	pline
E67F: C386E7  		jp	getback
E682: 66696C65	exists:	defb	'file exists',0
E686: 20657869	
E68A: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
E68E: CDF8E3  	user:	call	decode		;get numeric value following command.
E691: FE10    		cp	16		;legal user number?
E693: D209E2  		jp	nc,synerr
E696: 5F      		ld	e,a		;yes but is there anything else?
E697: 3ACEE7  		ld	a,(fcb+1)
E69A: FE20    		cp	' '
E69C: CA09E2  		jp	z,synerr	;yes, that is not allowed.
E69F: CD15E1  		call	getsetuc	;ok, set user code.
E6A2: C389E7  		jp	getback1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
E6A5: CDF5E1  	unknown:call	verify		;check for valid system (why?).
E6A8: 3ACEE7  		ld	a,(fcb+1)	;anything to execute?
E6AB: FE20    		cp	' '
E6AD: C2C4E6  		jp	nz,unkwn1
E6B0: 3AF0E7  		ld	a,(chgdrv)	;nope, only a drive change?
E6B3: B7      		or	a
E6B4: CA89E7  		jp	z,getback1	;neither???
E6B7: 3D      		dec	a
E6B8: 32EFE7  		ld	(cdrive),a	;ok, store new drive.
E6BB: CD29E1  		call	movecd		;set (tdrive) also.
E6BE: CDBDE0  		call	dsksel		;and select this drive.
E6C1: C389E7  		jp	getback1	;then return.
              	;
              	;   here a file name was typed. prepare to execute it.
              	;
E6C4: 11D6E7  	unkwn1:	ld	de,fcb+9	;an extension specified?
E6C7: 1A      		ld	a,(de)
E6C8: FE20    		cp	' '
E6CA: C209E2  		jp	nz,synerr	;yes, not allowed.
E6CD: D5      	unkwn2:	push	de
E6CE: CD54E4  		call	dselect		;select specified drive.
E6D1: D1      		pop	de
E6D2: 2183E7  		ld	hl,comfile	;set the extension to 'com'.
E6D5: CD40E4  		call	move3
E6D8: CDD0E0  		call	openfcb		;and open this file.
E6DB: CA6BE7  		jp	z,unkwn9	;not present?
              	;
              	;   load in the program.
              	;
E6DE: 210001  		ld	hl,tbase	;store the program starting here.
E6E1: E5      	unkwn3:	push	hl
E6E2: EB      		ex	de,hl
E6E3: CDD8E1  		call	dmaset		;set transfer address.
E6E6: 11CDE7  		ld	de,fcb		;and read the next record.
E6E9: CDF9E0  		call	rdrec
E6EC: C201E7  		jp	nz,unkwn4	;end of file or read error?
E6EF: E1      		pop	hl		;nope, bump pointer for next sector.
E6F0: 118000  		ld	de,128
E6F3: 19      		add	hl,de
E6F4: 1100E0  		ld	de,cbase	;enough room for the whole file?
E6F7: 7D      		ld	a,l
E6F8: 93      		sub	e
E6F9: 7C      		ld	a,h
E6FA: 9A      		sbc	a,d
E6FB: D271E7  		jp	nc,unkwn0	;no, it can't fit.
E6FE: C3E1E6  		jp	unkwn3
              	;
              	;   get here after finished reading.
              	;
E701: E1      	unkwn4:	pop	hl
E702: 3D      		dec	a		;normal end of file?
E703: C271E7  		jp	nz,unkwn0
E706: CD66E4  		call	resetdr		;yes, reset previous drive.
E709: CD5EE2  		call	convfst		;convert the first file name that follows
E70C: 21F0E7  		ld	hl,chgdrv	;command name.
E70F: E5      		push	hl
E710: 7E      		ld	a,(hl)		;set drive code in default fcb.
E711: 32CDE7  		ld	(fcb),a
E714: 3E10    		ld	a,16		;put second name 16 bytes later.
E716: CD60E2  		call	convert		;convert second file name.
E719: E1      		pop	hl
E71A: 7E      		ld	a,(hl)		;and set the drive for this second file.
E71B: 32DDE7  		ld	(fcb+16),a
E71E: AF      		xor	a		;clear record byte in fcb.
E71F: 32EDE7  		ld	(fcb+32),a
E722: 115C00  		ld	de,tfcb		;move it into place at(005ch).
E725: 21CDE7  		ld	hl,fcb
E728: 0621    		ld	b,33
E72A: CD42E4  		call	hl2de
E72D: 2108E0  		ld	hl,inbuff+2	;now move the remainder of the input
E730: 7E      	unkwn5:	ld	a,(hl)		;line down to (0080h). look for a non blank.
E731: B7      		or	a		;or a null.
E732: CA3EE7  		jp	z,unkwn6
E735: FE20    		cp	' '
E737: CA3EE7  		jp	z,unkwn6
E73A: 23      		inc	hl
E73B: C330E7  		jp	unkwn5
              	;
              	;   do the line move now. it ends in a null byte.
              	;
E73E: 0600    	unkwn6:	ld	b,0		;keep a character count.
E740: 118100  		ld	de,tbuff+1	;data gets put here.
E743: 7E      	unkwn7:	ld	a,(hl)		;move it now.
E744: 12      		ld	(de),a
E745: B7      		or	a
E746: CA4FE7  		jp	z,unkwn8
E749: 04      		inc	b
E74A: 23      		inc	hl
E74B: 13      		inc	de
E74C: C343E7  		jp	unkwn7
E74F: 78      	unkwn8:	ld	a,b		;now store the character count.
E750: 328000  		ld	(tbuff),a
E753: CD98E0  		call	crlf		;clean up the screen.
E756: CDD5E1  		call	stddma		;set standard transfer address.
E759: CD1AE1  		call	setcdrv		;reset current drive.
E75C: CD0001  		call	tbase		;and execute the program.
              	;
              	;   transiant programs return here (or reboot).
              	;
E75F: 31ABE7  		ld	sp,batch	;set stack first off.
E762: CD29E1  		call	movecd		;move current drive into place (tdrive).
E765: CDBDE0  		call	dsksel		;and reselect it.
E768: C382E3  		jp	cmmnd1		;back to comand mode.
              	;
              	;   get here if some error occured.
              	;
E76B: CD66E4  	unkwn9:	call	resetdr		;inproper format.
E76E: C309E2  		jp	synerr
E771: 017AE7  	unkwn0:	ld	bc,badload	;read error or won't fit.
E774: CDA7E0  		call	pline
E777: C386E7  		jp	getback
E77A: 62616420	badload:defb	'bad load',0
E77E: 6C6F6164	
E782: 00      	
E783: 636F6D  	comfile:defb	'com'		;command file extension.
              	;
              	;   get here to return to command level. we will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
E786: CD66E4  	getback:call	resetdr		;reset previous drive.
E789: CD5EE2  	getback1: call	convfst		;convert first name in (fcb).
E78C: 3ACEE7  		ld	a,(fcb+1)	;if this was just a drive change request,
E78F: D620    		sub	' '		;make sure it was valid.
E791: 21F0E7  		ld	hl,chgdrv
E794: B6      		or	(hl)
E795: C209E2  		jp	nz,synerr
E798: C382E3  		jp	cmmnd1		;ok, return to command level.
              	;
              	;   ccp stack area.
              	;
E79B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E79F: 00...   	
E7AB:         	ccpstack equ	$	;end of ccp stack area.
              	;
              	;   batch (or submit) processing information storage.
              	;
E7AB: 00      	batch:	defb	0		;batch mode flag (0=not active).
E7AC: 00242424	batchfcb: defb	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E7B0: 20202020	
E7B4: 20535542	
E7B8: 00000000	
E7BC: 00...   	
              	;
              	;   file control block setup by the ccp.
              	;
E7CD: 00202020	fcb:	defb	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
E7D1: 20202020	
E7D5: 20202020	
E7D9: 00000000	
E7DD: 00202020	
E7E1: 20202020	
E7E5: 20202020	
E7E9: 00000000	
E7ED: 00      	
E7EE: 00      	rtncode:defb	0		;status returned from bdos call.
E7EF: 00      	cdrive:	defb	0		;currently active drive.
E7F0: 00      	chgdrv:	defb	0		;change in drives flag (0=no change).
E7F1: 0000    	nbytes:	defw	0		;byte counter used by type.
              	;
              	;   room for expansion?
              	;
E7F3: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0
E7F7: 00...   	
              	;
              	;   note that the following six bytes must match those at
              	; (pattrn1) or cp/m will halt. why?
              	;
E800: 00160000	pattrn2:defb	0,22,0,0,0,0	;(* serial number bytes *).
E804: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
E806: C314E8  	fbase:	jp	fbase1
E809: C300F6  		jp	boot
              	;
              	;   bdos error table.
              	;
E80C: 9CE8    	badsctr:defw	error1		;bad sector on read or write.
E80E: A8E8    	badslct:defw	error2		;bad disk select.
E810: AEE8    	rodisk:	defw	error3		;disk is read only.
E812: B4E8    	rofile:	defw	error4		;file is read only.
              	;
              	;   entry into bdos. (de) or (e) are the parameters passed. the
              	; function number desired is in register (c).
              	;
E814: EB      	fbase1:	ex	de,hl		;save the (de) parameters.
E815: 2246EB  		ld	(params),hl
E818: EB      		ex	de,hl
E819: 7B      		ld	a,e		;and save register (e) in particular.
E81A: 32D9F5  		ld	(eparam),a
E81D: 210000  		ld	hl,0
E820: 2248EB  		ld	(status),hl	;clear return status.
E823: 39      		add	hl,sp
E824: 2212EB  		ld	(usrstack),hl	;save users stack pointer.
E827: 3144EB  		ld	sp,stkarea	;and set our own.
E82A: AF      		xor	a		;clear auto select storage space.
E82B: 32E3F5  		ld	(autoflag),a
E82E: 32E1F5  		ld	(auto),a
E831: 2177F5  		ld	hl,goback	;set return address.
E834: E5      		push	hl
E835: 79      		ld	a,c		;get function number.
E836: FE29    		cp	nfuncts		;valid function number?
E838: D0      		ret	nc
E839: 4B      		ld	c,e		;keep single register function here.
E83A: 214AE8  		ld	hl,functns	;now look thru the function table.
E83D: 5F      		ld	e,a
E83E: 1600    		ld	d,0		;(de)=function number.
E840: 19      		add	hl,de
E841: 19      		add	hl,de		;(hl)=(start of table)+2*(function number).
E842: 5E      		ld	e,(hl)
E843: 23      		inc	hl
E844: 56      		ld	d,(hl)		;now (de)=address for this function.
E845: 2A46EB  		ld	hl,(params)	;retrieve parameters.
E848: EB      		ex	de,hl		;now (de) has the original parameters.
E849: E9      		jp	(hl)		;execute desired function.
              	;
              	;   bdos function jump table.
              	;
0029:         	nfuncts equ	41		;number of functions in followin table.
              	;
E84A: 03F6CBEA	functns:defw	wboot,getcon,outcon,getrdr,punch,list,dircio,getiob
E84E: 93E9D1EA	
E852: 47F646F6	
E856: D7EAF0EA	
E85A: F6EAFBEA		defw	setiob,prtstr,rdbuff,getcsts,getver,rstdsk,setdsk,openfil
E85E: E4E901EB	
E862: 81F486F4	
E866: 48F49FF4	
E86A: A8F4AEF4		defw	closefil,getfst,getnxt,delfile,readseq,wrtseq,fcreate
E86E: CBF4DAF4	
E872: E3F4E9F4	
E876: EFF4    	
E878: F8F401F5		defw	renfile,getlog,getcrnt,putdma,getaloc,wrtprtd,getrov,setattr
E87C: 07F50DF5	
E880: 14F52FED	
E884: 1AF520F5	
E888: 29F530F5		defw	getparm,getuser,rdrandom,wtrandom,filesize,setran,logoff,rtn
E88C: 44F54AF5	
E890: 50F511F4	
E894: 56F507EB	
E898: 07EB9EF5		defw	rtn,wtspecl
              	;
              	;   bdos error message section.
              	;
E89C: 21CDE8  	error1:	ld	hl,badsec	;bad sector message.
E89F: CDE8E8  		call	prterr		;print it and get a 1 char responce.
E8A2: FE03    		cp	cntrlc		;re-boot request (control-c)?
E8A4: CA0000  		jp	z,0		;yes.
E8A7: C9      		ret			;no, return to retry i/o function.
              	;
E8A8: 21D8E8  	error2:	ld	hl,badsel	;bad drive selected.
E8AB: C3B7E8  		jp	error5
              	;
E8AE: 21E4E8  	error3:	ld	hl,diskro	;disk is read only.
E8B1: C3B7E8  		jp	error5
              	;
E8B4: 21DFE8  	error4:	ld	hl,filero	;file is read only.
              	;
E8B7: CDE8E8  	error5:	call	prterr
E8BA: C30000  		jp	0		;always reboot on these errors.
              	;
E8BD: 42646F73	bdoserr:defb	'Bdos Err on '
E8C1: 20457272	
E8C5: 206F6E20	
E8C9: 203A2024	bdosdrv:defb	' : $'
E8CD: 42616420	badsec:	defb	'Bad Sector$'
E8D1: 53656374	
E8D5: 6F7224  	
E8D8: 53656C65	badsel:	defb	'Select$'
E8DC: 637424  	
E8DF: 46696C65	filero:	defb	'File '
E8E3: 20      	
E8E4: 522F4F24	diskro:	defb	'R/O$'
              	;
              	;   print bdos error message.
              	;
E8E8: E5      	prterr:	push	hl		;save second message pointer.
E8E9: CDCCE9  		call	outcrlf		;send (cr)(lf).
E8EC: 3A45EB  		ld	a,(active)	;get active drive.
E8EF: C641    		add	a,'A'		;make ascii.
E8F1: 32C9E8  		ld	(bdosdrv),a	;and put in message.
E8F4: 01BDE8  		ld	bc,bdoserr	;and print it.
E8F7: CDD6E9  		call	prtmesg
E8FA: C1      		pop	bc		;print second message line now.
E8FB: CDD6E9  		call	prtmesg
              	;
              	;   get an input character. we will check our 1 character
              	; buffer first. this may be set by the console status routine.
              	;
E8FE: 2111EB  	getchar:ld	hl,charbuf	;check character buffer.
E901: 7E      		ld	a,(hl)		;anything present already?
E902: 3600    		ld	(hl),0		;...either case clear it.
E904: B7      		or	a
E905: C0      		ret	nz		;yes, use it.
E906: C344F6  		jp	conin		;nope, go get a character responce.
              	;
              	;   input and echo a character.
              	;
E909: CDFEE8  	getecho:call	getchar		;input a character.
E90C: CD17E9  		call	chkchar		;carriage control?
E90F: D8      		ret	c		;no, a regular control char so don't echo.
E910: F5      		push	af		;ok, save character now.
E911: 4F      		ld	c,a
E912: CD93E9  		call	outcon		;and echo it.
E915: F1      		pop	af		;get character and return.
E916: C9      		ret	
              	;
              	;   check character in (a). set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
E917: FE0D    	chkchar:cp	cr		;check for carriage return, line feed, backspace,
E919: C8      		ret	z		;or a tab.
E91A: FE0A    		cp	lf
E91C: C8      		ret	z
E91D: FE09    		cp	tab
E91F: C8      		ret	z
E920: FE08    		cp	bs
E922: C8      		ret	z
E923: FE20    		cp	' '		;other control char? set carry flag.
E925: C9      		ret	
              	;
              	;   check the console during output. halt on a control-s, then
              	; reboot on a control-c. if anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
E926: 3A11EB  	ckconsol: ld	a,(charbuf)	;check buffer.
E929: B7      		or	a		;if anything, just return without checking.
E92A: C248E9  		jp	nz,ckcon2
E92D: CD43F6  		call	const		;nothing in buffer. check console.
E930: E601    		and	01h		;look at bit 0.
E932: C8      		ret	z		;return if nothing.
E933: CD44F6  		call	conin		;ok, get it.
E936: FE13    		cp	cntrls		;if not control-s, return with zero cleared.
E938: C245E9  		jp	nz,ckcon1
E93B: CD44F6  		call	conin		;halt processing until another char
E93E: FE03    		cp	cntrlc		;is typed. control-c?
E940: CA0000  		jp	z,0		;yes, reboot now.
E943: AF      		xor	a		;no, just pretend nothing was ever ready.
E944: C9      		ret	
E945: 3211EB  	ckcon1:	ld	(charbuf),a	;save character in buffer for later processing.
E948: 3E01    	ckcon2:	ld	a,1		;set (a) to non zero to mean something is ready.
E94A: C9      		ret	
              	;
              	;   output (c) to the screen. if the printer flip-flop flag
              	; is set, we will send character to printer also. the console
              	; will be checked in the process.
              	;
E94B: 3A0DEB  	outchar:ld	a,(outflag)	;check output flag.
E94E: B7      		or	a		;anything and we won't generate output.
E94F: C265E9  		jp	nz,outchr1
E952: C5      		push	bc
E953: CD26E9  		call	ckconsol	;check console (we don't care whats there).
E956: C1      		pop	bc
E957: C5      		push	bc
E958: CD45F6  		call	conout		;output (c) to the screen.
E95B: C1      		pop	bc
E95C: C5      		push	bc
E95D: 3A10EB  		ld	a,(prtflag)	;check printer flip-flop flag.
E960: B7      		or	a
E961: C446F6  		call	nz,list		;print it also if non-zero.
E964: C1      		pop	bc
E965: 79      	outchr1:ld	a,c		;update cursors position.
E966: 210FEB  		ld	hl,curpos
E969: FE7F    		cp	del		;rubouts don't do anything here.
E96B: C8      		ret	z
E96C: 34      		inc	(hl)		;bump line pointer.
E96D: FE20    		cp	' '		;and return if a normal character.
E96F: D0      		ret	nc
E970: 35      		dec	(hl)		;restore and check for the start of the line.
E971: 7E      		ld	a,(hl)
E972: B7      		or	a
E973: C8      		ret	z		;ingnore control characters at the start of the line.
E974: 79      		ld	a,c
E975: FE08    		cp	bs		;is it a backspace?
E977: C27CE9  		jp	nz,outchr2
E97A: 35      		dec	(hl)		;yes, backup pointer.
E97B: C9      		ret	
E97C: FE0A    	outchr2:cp	lf		;is it a line feed?
E97E: C0      		ret	nz		;ignore anything else.
E97F: 3600    		ld	(hl),0		;reset pointer to start of line.
E981: C9      		ret	
              	;
              	;   output (a) to the screen. if it is a control character
              	; (other than carriage control), use ^x format.
              	;
E982: 79      	showit:	ld	a,c
E983: CD17E9  		call	chkchar		;check character.
E986: D293E9  		jp	nc,outcon	;not a control, use normal output.
E989: F5      		push	af
E98A: 0E5E    		ld	c,'^'		;for a control character, preceed it with '^'.
E98C: CD4BE9  		call	outchar
E98F: F1      		pop	af
E990: F640    		or	'@'		;and then use the letter equivelant.
E992: 4F      		ld	c,a
              	;
              	;   function to output (c) to the console device and expand tabs
              	; if necessary.
              	;
E993: 79      	outcon:	ld	a,c
E994: FE09    		cp	tab		;is it a tab?
E996: C24BE9  		jp	nz,outchar	;use regular output.
E999: 0E20    	outcon1:ld	c,' '		;yes it is, use spaces instead.
E99B: CD4BE9  		call	outchar
E99E: 3A0FEB  		ld	a,(curpos)	;go until the cursor is at a multiple of 8
              	
E9A1: E607    		and	07h		;position.
E9A3: C299E9  		jp	nz,outcon1
E9A6: C9      		ret	
              	;
              	;   echo a backspace character. erase the prevoius character
              	; on the screen.
              	;
E9A7: CDAFE9  	backup:	call	backup1		;backup the screen 1 place.
E9AA: 0E20    		ld	c,' '		;then blank that character.
E9AC: CD45F6  		call	conout
E9AF: 0E08    	backup1:ld	c,bs		;then back space once more.
E9B1: C345F6  		jp	conout
              	;
              	;   signal a deleted line. print a '#' at the end and start
              	; over.
              	;
E9B4: 0E23    	newline:ld	c,'#'
E9B6: CD4BE9  		call	outchar		;print this.
E9B9: CDCCE9  		call	outcrlf		;start new line.
E9BC: 3A0FEB  	newln1:	ld	a,(curpos)	;move the cursor to the starting position.
E9BF: 210EEB  		ld	hl,starting
E9C2: BE      		cp	(hl)
E9C3: D0      		ret	nc		;there yet?
E9C4: 0E20    		ld	c,' '
E9C6: CD4BE9  		call	outchar		;nope, keep going.
E9C9: C3BCE9  		jp	newln1
              	;
              	;   output a (cr) (lf) to the console device (screen).
              	;
E9CC: 0E0D    	outcrlf:ld	c,cr
E9CE: CD4BE9  		call	outchar
E9D1: 0E0A    		ld	c,lf
E9D3: C34BE9  		jp	outchar
              	;
              	;   print message pointed to by (bc). it will end with a '$'.
              	;
E9D6: 0A      	prtmesg:ld	a,(bc)		;check for terminating character.
E9D7: FE24    		cp	'$'
E9D9: C8      		ret	z
E9DA: 03      		inc	bc
E9DB: C5      		push	bc		;otherwise, bump pointer and print it.
E9DC: 4F      		ld	c,a
E9DD: CD93E9  		call	outcon
E9E0: C1      		pop	bc
E9E1: C3D6E9  		jp	prtmesg
              	;
              	;   function to execute a buffered read.
              	;
E9E4: 3A0FEB  	rdbuff:	ld	a,(curpos)	;use present location as starting one.
E9E7: 320EEB  		ld	(starting),a
E9EA: 2A46EB  		ld	hl,(params)	;get the maximum buffer space.
E9ED: 4E      		ld	c,(hl)
E9EE: 23      		inc	hl		;point to first available space.
E9EF: E5      		push	hl		;and save.
E9F0: 0600    		ld	b,0		;keep a character count.
E9F2: C5      	rdbuf1:	push	bc
E9F3: E5      		push	hl
E9F4: CDFEE8  	rdbuf2:	call	getchar		;get the next input character.
E9F7: E67F    		and	7fh		;strip bit 7.
E9F9: E1      		pop	hl		;reset registers.
E9FA: C1      		pop	bc
E9FB: FE0D    		cp	cr		;en of the line?
E9FD: CAC4EA  		jp	z,rdbuf17
EA00: FE0A    		cp	lf
EA02: CAC4EA  		jp	z,rdbuf17
EA05: FE08    		cp	bs		;how about a backspace?
EA07: C219EA  		jp	nz,rdbuf3
EA0A: 78      		ld	a,b		;yes, but ignore at the beginning of the line.
EA0B: B7      		or	a
EA0C: CAF2E9  		jp	z,rdbuf1
EA0F: 05      		dec	b		;ok, update counter.
EA10: 3A0FEB  		ld	a,(curpos)	;if we backspace to the start of the line,
EA13: 320DEB  		ld	(outflag),a	;treat as a cancel (control-x).
EA16: C373EA  		jp	rdbuf10
EA19: FE7F    	rdbuf3:	cp	del		;user typed a rubout?
EA1B: C229EA  		jp	nz,rdbuf4
EA1E: 78      		ld	a,b		;ignore at the start of the line.
EA1F: B7      		or	a
EA20: CAF2E9  		jp	z,rdbuf1
EA23: 7E      		ld	a,(hl)		;ok, echo the prevoius character.
EA24: 05      		dec	b		;and reset pointers (counters).
EA25: 2B      		dec	hl
EA26: C3ACEA  		jp	rdbuf15
EA29: FE05    	rdbuf4:	cp	cntrle		;physical end of line?
EA2B: C23AEA  		jp	nz,rdbuf5
EA2E: C5      		push	bc		;yes, do it.
EA2F: E5      		push	hl
EA30: CDCCE9  		call	outcrlf
EA33: AF      		xor	a		;and update starting position.
EA34: 320EEB  		ld	(starting),a
EA37: C3F4E9  		jp	rdbuf2
EA3A: FE10    	rdbuf5:	cp	cntrlp		;control-p?
EA3C: C24BEA  		jp	nz,rdbuf6
EA3F: E5      		push	hl		;yes, flip the print flag filp-flop byte.
EA40: 2110EB  		ld	hl,prtflag
EA43: 3E01    		ld	a,1		;prtflag=1-prtflag
EA45: 96      		sub	(hl)
EA46: 77      		ld	(hl),a
EA47: E1      		pop	hl
EA48: C3F2E9  		jp	rdbuf1
EA4B: FE18    	rdbuf6:	cp	cntrlx		;control-x (cancel)?
EA4D: C262EA  		jp	nz,rdbuf8
EA50: E1      		pop	hl
EA51: 3A0EEB  	rdbuf7:	ld	a,(starting)	;yes, backup the cursor to here.
EA54: 210FEB  		ld	hl,curpos
EA57: BE      		cp	(hl)
EA58: D2E4E9  		jp	nc,rdbuff	;done yet?
EA5B: 35      		dec	(hl)		;no, decrement pointer and output back up one space.
EA5C: CDA7E9  		call	backup
EA5F: C351EA  		jp	rdbuf7
EA62: FE15    	rdbuf8:	cp	cntrlu		;cntrol-u (cancel line)?
EA64: C26EEA  		jp	nz,rdbuf9
EA67: CDB4E9  		call	newline		;start a new line.
EA6A: E1      		pop	hl
EA6B: C3E4E9  		jp	rdbuff
EA6E: FE12    	rdbuf9:	cp	cntrlr		;control-r?
EA70: C2A9EA  		jp	nz,rdbuf14
EA73: C5      	rdbuf10:push	bc		;yes, start a new line and retype the old one.
EA74: CDB4E9  		call	newline
EA77: C1      		pop	bc
EA78: E1      		pop	hl
EA79: E5      		push	hl
EA7A: C5      		push	bc
EA7B: 78      	rdbuf11:ld	a,b		;done whole line yet?
EA7C: B7      		or	a
EA7D: CA8DEA  		jp	z,rdbuf12
EA80: 23      		inc	hl		;nope, get next character.
EA81: 4E      		ld	c,(hl)
EA82: 05      		dec	b		;count it.
EA83: C5      		push	bc
EA84: E5      		push	hl
EA85: CD82E9  		call	showit		;and display it.
EA88: E1      		pop	hl
EA89: C1      		pop	bc
EA8A: C37BEA  		jp	rdbuf11
EA8D: E5      	rdbuf12:push	hl		;done with line. if we were displaying
EA8E: 3A0DEB  		ld	a,(outflag)	;then update cursor position.
EA91: B7      		or	a
EA92: CAF4E9  		jp	z,rdbuf2
EA95: 210FEB  		ld	hl,curpos	;because this line is shorter, we must
EA98: 96      		sub	(hl)		;back up the cursor (not the screen however)
EA99: 320DEB  		ld	(outflag),a	;some number of positions.
EA9C: CDA7E9  	rdbuf13:call	backup		;note that as long as (outflag) is non
EA9F: 210DEB  		ld	hl,outflag	;zero, the screen will not be changed.
EAA2: 35      		dec	(hl)
EAA3: C29CEA  		jp	nz,rdbuf13
EAA6: C3F4E9  		jp	rdbuf2		;now just get the next character.
              	;
              	;   just a normal character, put this in our buffer and echo.
              	;
EAA9: 23      	rdbuf14:inc	hl
EAAA: 77      		ld	(hl),a		;store character.
EAAB: 04      		inc	b		;and count it.
EAAC: C5      	rdbuf15:push	bc
EAAD: E5      		push	hl
EAAE: 4F      		ld	c,a		;echo it now.
EAAF: CD82E9  		call	showit
EAB2: E1      		pop	hl
EAB3: C1      		pop	bc
EAB4: 7E      		ld	a,(hl)		;was it an abort request?
EAB5: FE03    		cp	cntrlc		;control-c abort?
EAB7: 78      		ld	a,b
EAB8: C2C0EA  		jp	nz,rdbuf16
EABB: FE01    		cp	1		;only if at start of line.
EABD: CA0000  		jp	z,0
EAC0: B9      	rdbuf16:cp	c		;nope, have we filled the buffer?
EAC1: DAF2E9  		jp	c,rdbuf1
EAC4: E1      	rdbuf17:pop	hl		;yes end the line and return.
EAC5: 70      		ld	(hl),b
EAC6: 0E0D    		ld	c,cr
EAC8: C34BE9  		jp	outchar		;output (cr) and return.
              	;
              	;   function to get a character from the console device.
              	;
EACB: CD09E9  	getcon:	call	getecho		;get and echo.
EACE: C304EB  		jp	setstat		;save status and return.
              	;
              	;   function to get a character from the tape reader device.
              	;
EAD1: CD48F6  	getrdr:	call	reader		;get a character from reader, set status and return.
EAD4: C304EB  		jp	setstat
              	;
              	;  function to perform direct console i/o. if (c) contains (ff)
              	; then this is an input request. if (c) contains (fe) then
              	; this is a status request. otherwise we are to output (c).
              	;
EAD7: 79      	dircio:	ld	a,c		;test for (ff).
EAD8: 3C      		inc	a
EAD9: CAE3EA  		jp	z,dirc1
EADC: 3C      		inc	a		;test for (fe).
EADD: CA43F6  		jp	z,const
EAE0: C345F6  		jp	conout		;just output (c).
EAE3: CD43F6  	dirc1:	call	const		;this is an input request.
EAE6: B7      		or	a
EAE7: CA94F5  		jp	z,goback1	;not ready? just return (directly).
EAEA: CD44F6  		call	conin		;yes, get character.
EAED: C304EB  		jp	setstat		;set status and return.
              	;
              	;   function to return the i/o byte.
              	;
EAF0: 3A0300  	getiob:	ld	a,(iobyte)
EAF3: C304EB  		jp	setstat
              	;
              	;   function to set the i/o byte.
              	;
EAF6: 210300  	setiob:	ld	hl,iobyte
EAF9: 71      		ld	(hl),c
EAFA: C9      		ret	
              	;
              	;   function to print the character string pointed to by (de)
              	; on the console device. the string ends with a '$'.
              	;
EAFB: EB      	prtstr:	ex	de,hl
EAFC: 4D      		ld	c,l
EAFD: 44      		ld	b,h		;now (bc) points to it.
EAFE: C3D6E9  		jp	prtmesg
              	;
              	;   function to interigate the console device.
              	;
EB01: CD26E9  	getcsts:call	ckconsol
              	;
              	;   get here to set the status and return to the cleanup
              	; section. then back to the user.
              	;
EB04: 3248EB  	setstat:ld	(status),a
EB07: C9      	rtn:	ret	
              	;
              	;   set the status to 1 (read or write error code).
              	;
EB08: 3E01    	ioerr1:	ld	a,1
EB0A: C304EB  		jp	setstat
              	;
EB0D: 00      	outflag:defb	0		;output flag (non zero means no output).
EB0E: 02      	starting: defb	2		;starting position for cursor.
EB0F: 00      	curpos:	defb	0		;cursor position (0=start of line).
EB10: 00      	prtflag:defb	0		;printer flag (control-p toggle). list if non zero.
EB11: 00      	charbuf:defb	0		;single input character buffer.
              	;
              	;   stack area for bdos calls.
              	;
EB12: 0000    	usrstack: defw	0		;save users stack pointer here.
              	;
EB14: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EB18: 00...   	
EB2C: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EB30: 00...   	
EB44:         	stkarea equ	$		;end of stack area.
              	;
EB44: 00      	userno:	defb	0		;current user number.
EB45: 00      	active:	defb	0		;currently active drive.
EB46: 0000    	params:	defw	0		;save (de) parameters here on entry.
EB48: 0000    	status:	defw	0		;status returned from bdos function.
              	;
              	;   select error occured, jump to error routine.
              	;
EB4A: 210EE8  	slcterr:ld	hl,badslct
              	;
              	;   jump to (hl) indirectly.
              	;
EB4D: 5E      	jumphl:	ld	e,(hl)
EB4E: 23      		inc	hl
EB4F: 56      		ld	d,(hl)		;now (de) contain the desired address.
EB50: EB      		ex	de,hl
EB51: E9      		jp	(hl)
              	;
              	;   block move. (de) to (hl), (c) bytes total.
              	;
EB52: 0C      	de2hl:	inc	c		;is count down to zero?
EB53: 0D      	de2hl1:	dec	c
EB54: C8      		ret	z		;yes, we are done.
EB55: 1A      		ld	a,(de)		;no, move one more byte.
EB56: 77      		ld	(hl),a
EB57: 13      		inc	de
EB58: 23      		inc	hl
EB59: C353EB  		jp	de2hl1		;and repeat.
              	;
              	;   select the desired drive.
              	;
EB5C: 3A45EB  	select:	ld	a,(active)	;get active disk.
EB5F: 4F      		ld	c,a
EB60: CD4AF6  		call	seldsk		;select it.
EB63: 7C      		ld	a,h		;valid drive?
EB64: B5      		or	l		;valid drive?
EB65: C8      		ret	z		;return if not.
              	;
              	;   here, the bios returned the address of the parameter block
              	; in (hl). we will extract the necessary pointers and save them.
              	;
EB66: 5E      		ld	e,(hl)		;yes, get address of translation table into (de).
EB67: 23      		inc	hl
EB68: 56      		ld	d,(hl)
EB69: 23      		inc	hl
EB6A: 22B6F5  		ld	(scratch1),hl	;save pointers to scratch areas.
EB6D: 23      		inc	hl
EB6E: 23      		inc	hl
EB6F: 22B8F5  		ld	(scratch2),hl	;ditto.
EB72: 23      		inc	hl
EB73: 23      		inc	hl
EB74: 22BAF5  		ld	(scratch3),hl	;ditto.
EB77: 23      		inc	hl
EB78: 23      		inc	hl
EB79: EB      		ex	de,hl		;now save the translation table address.
EB7A: 22D3F5  		ld	(xlate),hl
EB7D: 21BCF5  		ld	hl,dirbuf	;put the next 8 bytes here.
EB80: 0E08    		ld	c,8		;they consist of the directory buffer
EB82: CD52EB  		call	de2hl		;pointer, parameter block pointer,
EB85: 2ABEF5  		ld	hl,(diskpb)	;check and allocation vectors.
EB88: EB      		ex	de,hl
EB89: 21C4F5  		ld	hl,sectors	;move parameter block into our ram.
EB8C: 0E0F    		ld	c,15		;it is 15 bytes long.
EB8E: CD52EB  		call	de2hl
EB91: 2AC9F5  		ld	hl,(dsksize)	;check disk size.
EB94: 7C      		ld	a,h		;more than 256 blocks on this?
EB95: 21E0F5  		ld	hl,bigdisk
EB98: 36FF    		ld	(hl),0ffh	;set to samll.
EB9A: B7      		or	a
EB9B: CAA0EB  		jp	z,select1
EB9E: 3600    		ld	(hl),0		;wrong, set to large.
EBA0: 3EFF    	select1:ld	a,0ffh		;clear the zero flag.
EBA2: B7      		or	a
EBA3: C9      		ret	
              	;
              	;   routine to home the disk track head and clear pointers.
              	;
EBA4: CD49F6  	homedrv:call	home		;home the head.
EBA7: AF      		xor	a
EBA8: 2AB8F5  		ld	hl,(scratch2)	;set our track pointer also.
EBAB: 77      		ld	(hl),a
EBAC: 23      		inc	hl
EBAD: 77      		ld	(hl),a
EBAE: 2ABAF5  		ld	hl,(scratch3)	;and our sector pointer.
EBB1: 77      		ld	(hl),a
EBB2: 23      		inc	hl
EBB3: 77      		ld	(hl),a
EBB4: C9      		ret	
              	;
              	;   do the actual disk read and check the error return status.
              	;
EBB5: CD4EF6  	doread:	call	read
EBB8: C3BEEB  		jp	ioret
              	;
              	;   do the actual disk write and handle any bios error.
              	;
EBBB: CD4FF6  	dowrite:call	write
EBBE: B7      	ioret:	or	a
EBBF: C8      		ret	z		;return unless an error occured.
EBC0: 210CE8  		ld	hl,badsctr	;bad read/write on this sector.
EBC3: C34DEB  		jp	jumphl
              	;
              	;   routine to select the track and sector that the desired
              	; block number falls in.
              	;
EBC6: 2AEDF5  	trksec:	ld	hl,(filepos)	;get position of last accessed file
EBC9: 0E02    		ld	c,2		;in directory and compute sector #.
EBCB: CDEDEC  		call	shiftr		;sector #=file-position/4.
EBCE: 22E8F5  		ld	(blknmbr),hl	;save this as the block number of interest.
EBD1: 22EFF5  		ld	(cksumtbl),hl	;what's it doing here too?
              	;
              	;   if the sector number has already been set (blknmbr), enter
              	; at this point.
              	;
EBD4: 21E8F5  	trksec1:ld	hl,blknmbr
EBD7: 4E      		ld	c,(hl)		;move sector number into (bc).
EBD8: 23      		inc	hl
EBD9: 46      		ld	b,(hl)
EBDA: 2ABAF5  		ld	hl,(scratch3)	;get current sector number and
EBDD: 5E      		ld	e,(hl)		;move this into (de).
EBDE: 23      		inc	hl
EBDF: 56      		ld	d,(hl)
EBE0: 2AB8F5  		ld	hl,(scratch2)	;get current track number.
EBE3: 7E      		ld	a,(hl)		;and this into (hl).
EBE4: 23      		inc	hl
EBE5: 66      		ld	h,(hl)
EBE6: 6F      		ld	l,a
EBE7: 79      	trksec2:ld	a,c		;is desired sector before current one?
EBE8: 93      		sub	e
EBE9: 78      		ld	a,b
EBEA: 9A      		sbc	a,d
EBEB: D2FDEB  		jp	nc,trksec3
EBEE: E5      		push	hl		;yes, decrement sectors by one track.
EBEF: 2AC4F5  		ld	hl,(sectors)	;get sectors per track.
EBF2: 7B      		ld	a,e
EBF3: 95      		sub	l
EBF4: 5F      		ld	e,a
EBF5: 7A      		ld	a,d
EBF6: 9C      		sbc	a,h
EBF7: 57      		ld	d,a		;now we have backed up one full track.
EBF8: E1      		pop	hl
EBF9: 2B      		dec	hl		;adjust track counter.
EBFA: C3E7EB  		jp	trksec2
EBFD: E5      	trksec3:push	hl		;desired sector is after current one.
EBFE: 2AC4F5  		ld	hl,(sectors)	;get sectors per track.
EC01: 19      		add	hl,de		;bump sector pointer to next track.
EC02: DA12EC  		jp	c,trksec4
EC05: 79      		ld	a,c		;is desired sector now before current one?
EC06: 95      		sub	l
EC07: 78      		ld	a,b
EC08: 9C      		sbc	a,h
EC09: DA12EC  		jp	c,trksec4
EC0C: EB      		ex	de,hl		;not yes, increment track counter
EC0D: E1      		pop	hl		;and continue until it is.
EC0E: 23      		inc	hl
EC0F: C3FDEB  		jp	trksec3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
EC12: E1      	trksec4:pop	hl		;get track number (hl).
EC13: C5      		push	bc
EC14: D5      		push	de
EC15: E5      		push	hl
EC16: EB      		ex	de,hl
EC17: 2AD1F5  		ld	hl,(offset)	;adjust for first track offset.
EC1A: 19      		add	hl,de
EC1B: 44      		ld	b,h
EC1C: 4D      		ld	c,l
EC1D: CD4BF6  		call	settrk		;select this track.
EC20: D1      		pop	de		;reset current track pointer.
EC21: 2AB8F5  		ld	hl,(scratch2)
EC24: 73      		ld	(hl),e
EC25: 23      		inc	hl
EC26: 72      		ld	(hl),d
EC27: D1      		pop	de
EC28: 2ABAF5  		ld	hl,(scratch3)	;reset the first sector on this track.
EC2B: 73      		ld	(hl),e
EC2C: 23      		inc	hl
EC2D: 72      		ld	(hl),d
EC2E: C1      		pop	bc
EC2F: 79      		ld	a,c		;now subtract the desired one.
EC30: 93      		sub	e		;to make it relative (1-# sectors/track).
EC31: 4F      		ld	c,a
EC32: 78      		ld	a,b
EC33: 9A      		sbc	a,d
EC34: 47      		ld	b,a
EC35: 2AD3F5  		ld	hl,(xlate)	;translate this sector according to this table.
EC38: EB      		ex	de,hl
EC39: CD51F6  		call	sectrn		;let the bios translate it.
EC3C: 4D      		ld	c,l
EC3D: 44      		ld	b,h
EC3E: C34CF6  		jp	setsec		;and select it.
              	;
              	;   compute block number from record number (savnrec) and
              	; extent number (savext).
              	;
EC41: 21C6F5  	getblock: ld	hl,blkshft	;get logical to physical conversion.
EC44: 4E      		ld	c,(hl)		;note that this is base 2 log of ratio.
EC45: 3AE6F5  		ld	a,(savnrec)	;get record number.
EC48: B7      	getblk1:or	a		;compute (a)=(a)/2^blkshft.
EC49: 1F      		rra	
EC4A: 0D      		dec	c
EC4B: C248EC  		jp	nz,getblk1
EC4E: 47      		ld	b,a		;save result in (b).
EC4F: 3E08    		ld	a,8
EC51: 96      		sub	(hl)
EC52: 4F      		ld	c,a		;compute (c)=8-blkshft.
EC53: 3AE5F5  		ld	a,(savext)
EC56: 0D      	getblk2:dec	c		;compute (a)=savext*2^(8-blkshft).
EC57: CA5FEC  		jp	z,getblk3
EC5A: B7      		or	a
EC5B: 17      		rla	
EC5C: C356EC  		jp	getblk2
EC5F: 80      	getblk3:add	a,b
EC60: C9      		ret	
              	;
              	;   routine to extract the (bc) block byte from the fcb pointed
              	; to by (params). if this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; number is returned in (hl).
              	;
EC61: 2A46EB  	extblk:	ld	hl,(params)	;get fcb address.
EC64: 111000  		ld	de,16		;block numbers start 16 bytes into fcb.
EC67: 19      		add	hl,de
EC68: 09      		add	hl,bc
EC69: 3AE0F5  		ld	a,(bigdisk)	;are we using a big-disk?
EC6C: B7      		or	a
EC6D: CA74EC  		jp	z,extblk1
EC70: 6E      		ld	l,(hl)		;no, extract an 8 bit number from the fcb.
EC71: 2600    		ld	h,0
EC73: C9      		ret	
EC74: 09      	extblk1:add	hl,bc		;yes, extract a 16 bit number.
EC75: 5E      		ld	e,(hl)
EC76: 23      		inc	hl
EC77: 56      		ld	d,(hl)
EC78: EB      		ex	de,hl		;return in (hl).
EC79: C9      		ret	
              	;
              	;   compute block number.
              	;
EC7A: CD41EC  	comblk:	call	getblock
EC7D: 4F      		ld	c,a
EC7E: 0600    		ld	b,0
EC80: CD61EC  		call	extblk
EC83: 22E8F5  		ld	(blknmbr),hl
EC86: C9      		ret	
              	;
              	;   check for a zero block number (unused).
              	;
EC87: 2AE8F5  	chkblk:	ld	hl,(blknmbr)
EC8A: 7D      		ld	a,l		;is it zero?
EC8B: B4      		or	h
EC8C: C9      		ret	
              	;
              	;   adjust physical block (blknmbr) and convert to logical
              	; sector (logsect). this is the starting sector of this block.
              	; the actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (blknmbr). this
              	; will still have to be adjusted for the track number.
              	;
EC8D: 3AC6F5  	logical:ld	a,(blkshft)	;get log2(physical/logical sectors).
EC90: 2AE8F5  		ld	hl,(blknmbr)	;get physical sector desired.
EC93: 29      	logicl1:add	hl,hl		;compute logical sector number.
EC94: 3D      		dec	a		;note logical sectors are 128 bytes long.
EC95: C293EC  		jp	nz,logicl1
EC98: 22EAF5  		ld	(logsect),hl	;save logical sector.
EC9B: 3AC7F5  		ld	a,(blkmask)	;get block mask.
EC9E: 4F      		ld	c,a
EC9F: 3AE6F5  		ld	a,(savnrec)	;get next sector to access.
ECA2: A1      		and	c		;extract the relative position within physical block.
ECA3: B5      		or	l		;and add it too logical sector.
ECA4: 6F      		ld	l,a
ECA5: 22E8F5  		ld	(blknmbr),hl	;and store.
ECA8: C9      		ret	
              	;
              	;   set (hl) to point to extent byte in fcb.
              	;
ECA9: 2A46EB  	setext:	ld	hl,(params)
ECAC: 110C00  		ld	de,12		;it is the twelth byte.
ECAF: 19      		add	hl,de
ECB0: C9      		ret	
              	;
              	;   set (hl) to point to record count byte in fcb and (de) to
              	; next record number byte.
              	;
ECB1: 2A46EB  	sethlde:ld	hl,(params)
ECB4: 110F00  		ld	de,15		;record count byte (#15).
ECB7: 19      		add	hl,de
ECB8: EB      		ex	de,hl
ECB9: 211100  		ld	hl,17		;next record number (#32).
ECBC: 19      		add	hl,de
ECBD: C9      		ret	
              	;
              	;   save current file data from fcb.
              	;
ECBE: CDB1EC  	strdata:call	sethlde
ECC1: 7E      		ld	a,(hl)		;get and store record count byte.
ECC2: 32E6F5  		ld	(savnrec),a
ECC5: EB      		ex	de,hl
ECC6: 7E      		ld	a,(hl)		;get and store next record number byte.
ECC7: 32E4F5  		ld	(savnxt),a
ECCA: CDA9EC  		call	setext		;point to extent byte.
ECCD: 3AC8F5  		ld	a,(extmask)	;get extent mask.
ECD0: A6      		and	(hl)
ECD1: 32E5F5  		ld	(savext),a	;and save extent here.
ECD4: C9      		ret	
              	;
              	;   set the next record to access. if (mode) is set to 2, then
              	; the last record byte (savnrec) has the correct number to access.
              	; for sequential access, (mode) will be equal to 1.
              	;
ECD5: CDB1EC  	setnrec:call	sethlde
ECD8: 3AD8F5  		ld	a,(mode)	;get sequential flag (=1).
ECDB: FE02    		cp	2		;a 2 indicates that no adder is needed.
ECDD: C2E1EC  		jp	nz,stnrec1
ECE0: AF      		xor	a		;clear adder (random access?).
ECE1: 4F      	stnrec1:ld	c,a
ECE2: 3AE6F5  		ld	a,(savnrec)	;get last record number.
ECE5: 81      		add	a,c		;increment record count.
ECE6: 77      		ld	(hl),a		;and set fcb's next record byte.
ECE7: EB      		ex	de,hl
ECE8: 3AE4F5  		ld	a,(savnxt)	;get next record byte from storage.
ECEB: 77      		ld	(hl),a		;and put this into fcb as number of records used.
ECEC: C9      		ret	
              	;
              	;   shift (hl) right (c) bits.
              	;
ECED: 0C      	shiftr:	inc	c
ECEE: 0D      	shiftr1:dec	c
ECEF: C8      		ret	z
ECF0: 7C      		ld	a,h
ECF1: B7      		or	a
ECF2: 1F      		rra	
ECF3: 67      		ld	h,a
ECF4: 7D      		ld	a,l
ECF5: 1F      		rra	
ECF6: 6F      		ld	l,a
ECF7: C3EEEC  		jp	shiftr1
              	;
              	;   compute the check-sum for the directory buffer. return
              	; integer sum in (a).
              	;
ECFA: 0E80    	checksum: ld	c,128		;length of buffer.
ECFC: 2ABCF5  		ld	hl,(dirbuf)	;get its location.
ECFF: AF      		xor	a		;clear summation byte.
ED00: 86      	chksum1:add	a,(hl)		;and compute sum ignoring carries.
ED01: 23      		inc	hl
ED02: 0D      		dec	c
ED03: C200ED  		jp	nz,chksum1
ED06: C9      		ret	
              	;
              	;   shift (hl) left (c) bits.
              	;
ED07: 0C      	shiftl:	inc	c
ED08: 0D      	shiftl1:dec	c
ED09: C8      		ret	z
ED0A: 29      		add	hl,hl		;shift left 1 bit.
ED0B: C308ED  		jp	shiftl1
              	;
              	;   routine to set a bit in a 16 bit value contained in (bc).
              	; the bit set depends on the current drive selection.
              	;
ED0E: C5      	setbit:	push	bc		;save 16 bit word.
ED0F: 3A45EB  		ld	a,(active)	;get active drive.
ED12: 4F      		ld	c,a
ED13: 210100  		ld	hl,1
ED16: CD07ED  		call	shiftl		;shift bit 0 into place.
ED19: C1      		pop	bc		;now 'or' this with the original word.
ED1A: 79      		ld	a,c
ED1B: B5      		or	l
ED1C: 6F      		ld	l,a		;low byte done, do high byte.
ED1D: 78      		ld	a,b
ED1E: B4      		or	h
ED1F: 67      		ld	h,a
ED20: C9      		ret	
              	;
              	;   extract the write protect status bit for the current drive.
              	; the result is returned in (a), bit 0.
              	;
ED21: 2AB0F5  	getwprt:ld	hl,(wrtprt)	;get status bytes.
ED24: 3A45EB  		ld	a,(active)	;which drive is current?
ED27: 4F      		ld	c,a
ED28: CDEDEC  		call	shiftr		;shift status such that bit 0 is the
ED2B: 7D      		ld	a,l		;one of interest for this drive.
ED2C: E601    		and	01h		;and isolate it.
ED2E: C9      		ret	
              	;
              	;   function to write protect the current disk.
              	;
ED2F: 21B0F5  	wrtprtd:ld	hl,wrtprt	;point to status word.
ED32: 4E      		ld	c,(hl)		;set (bc) equal to the status.
ED33: 23      		inc	hl
ED34: 46      		ld	b,(hl)
ED35: CD0EED  		call	setbit		;and set this bit according to current drive.
ED38: 22B0F5  		ld	(wrtprt),hl	;then save.
ED3B: 2ACBF5  		ld	hl,(dirsize)	;now save directory size limit.
ED3E: 23      		inc	hl		;remember the last one.
ED3F: EB      		ex	de,hl
ED40: 2AB6F5  		ld	hl,(scratch1)	;and store it here.
ED43: 73      		ld	(hl),e		;put low byte.
ED44: 23      		inc	hl
ED45: 72      		ld	(hl),d		;then high byte.
ED46: C9      		ret	
              	;
              	;   check for a read only file.
              	;
ED47: CD61ED  	chkrofl:call	fcb2hl		;set (hl) to file entry in directory buffer.
ED4A: 110900  	ckrof1:	ld	de,9		;look at bit 7 of the ninth byte.
ED4D: 19      		add	hl,de
ED4E: 7E      		ld	a,(hl)
ED4F: 17      		rla	
ED50: D0      		ret	nc		;return if ok.
ED51: 2112E8  		ld	hl,rofile	;else, print error message and terminate.
ED54: C34DEB  		jp	jumphl
              	;
              	;   check the write protect status of the active disk.
              	;
ED57: CD21ED  	chkwprt:call	getwprt
ED5A: C8      		ret	z		;return if ok.
ED5B: 2110E8  		ld	hl,rodisk	;else print message and terminate.
ED5E: C34DEB  		jp	jumphl
              	;
              	;   routine to set (hl) pointing to the proper entry in the
              	; directory buffer.
              	;
ED61: 2ABCF5  	fcb2hl:	ld	hl,(dirbuf)	;get address of buffer.
ED64: 3AECF5  		ld	a,(fcbpos)	;relative position of file.
              	;
              	;   routine to add (a) to (hl).
              	;
ED67: 85      	adda2hl:add	a,l
ED68: 6F      		ld	l,a
ED69: D0      		ret	nc
ED6A: 24      		inc	h		;take care of any carry.
ED6B: C9      		ret	
              	;
              	;   routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
ED6C: 2A46EB  	gets2:	ld	hl,(params)	;get address of fcb.
ED6F: 110E00  		ld	de,14		;relative position of 's2'.
ED72: 19      		add	hl,de
ED73: 7E      		ld	a,(hl)		;extract this byte.
ED74: C9      		ret	
              	;
              	;   clear the 's2' byte in the fcb.
              	;
ED75: CD6CED  	clears2:call	gets2		;this sets (hl) pointing to it.
ED78: 3600    		ld	(hl),0		;now clear it.
ED7A: C9      		ret	
              	;
              	;   set bit 7 in the 's2' byte of the fcb.
              	;
ED7B: CD6CED  	sets2b7:call	gets2		;get the byte.
ED7E: F680    		or	80h		;and set bit 7.
ED80: 77      		ld	(hl),a		;then store.
ED81: C9      		ret	
              	;
              	;   compare (filepos) with (scratch1) and set flags based on
              	; the difference. this checks to see if there are more file
              	; names in the directory. we are at (filepos) and there are
              	; (scratch1) of them to check.
              	;
ED82: 2AEDF5  	morefls:ld	hl,(filepos)	;we are here.
ED85: EB      		ex	de,hl
ED86: 2AB6F5  		ld	hl,(scratch1)	;and don't go past here.
ED89: 7B      		ld	a,e		;compute difference but don't keep.
ED8A: 96      		sub	(hl)
ED8B: 23      		inc	hl
ED8C: 7A      		ld	a,d
ED8D: 9E      		sbc	a,(hl)		;set carry if no more names.
ED8E: C9      		ret	
              	;
              	;   call this routine to prevent (scratch1) from being greater
              	; than (filepos).
              	;
ED8F: CD82ED  	chknmbr:call	morefls		;scratch1 too big?
ED92: D8      		ret	c
ED93: 13      		inc	de		;yes, reset it to (filepos).
ED94: 72      		ld	(hl),d
ED95: 2B      		dec	hl
ED96: 73      		ld	(hl),e
ED97: C9      		ret	
              	;
              	;   compute (hl)=(de)-(hl)
              	;
ED98: 7B      	subhl:	ld	a,e		;compute difference.
ED99: 95      		sub	l
ED9A: 6F      		ld	l,a		;store low byte.
ED9B: 7A      		ld	a,d
ED9C: 9C      		sbc	a,h
ED9D: 67      		ld	h,a		;and then high byte.
ED9E: C9      		ret	
              	;
              	;   set the directory checksum byte.
              	;
ED9F: 0EFF    	setdir:	ld	c,0ffh
              	;
              	;   routine to set or compare the directory checksum byte. if
              	; (c)=0ffh, then this will set the checksum byte. else the byte
              	; will be checked. if the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
EDA1: 2AEFF5  	checkdir: ld	hl,(cksumtbl)
EDA4: EB      		ex	de,hl
EDA5: 2ACFF5  		ld	hl,(alloc1)
EDA8: CD98ED  		call	subhl
EDAB: D0      		ret	nc		;ok if (cksumtbl) > (alloc1), so return.
EDAC: C5      		push	bc
EDAD: CDFAEC  		call	checksum	;else compute checksum.
EDB0: 2AC0F5  		ld	hl,(chkvect)	;get address of checksum table.
EDB3: EB      		ex	de,hl
EDB4: 2AEFF5  		ld	hl,(cksumtbl)
EDB7: 19      		add	hl,de		;set (hl) to point to byte for this drive.
EDB8: C1      		pop	bc
EDB9: 0C      		inc	c		;set or check ?
EDBA: CAC7ED  		jp	z,chkdir1
EDBD: BE      		cp	(hl)		;check them.
EDBE: C8      		ret	z		;return if they are the same.
EDBF: CD82ED  		call	morefls		;not the same, do we care?
EDC2: D0      		ret	nc
EDC3: CD2FED  		call	wrtprtd		;yes, mark this as write protected.
EDC6: C9      		ret	
EDC7: 77      	chkdir1:ld	(hl),a		;just set the byte.
EDC8: C9      		ret	
              	;
              	;   do a write to the directory of the current disk.
              	;
EDC9: CD9FED  	dirwrite: call	setdir		;set checksum byte.
EDCC: CDE3ED  		call	dirdma		;set directory dma address.
EDCF: 0E01    		ld	c,1		;tell the bios to actually write.
EDD1: CDBBEB  		call	dowrite		;then do the write.
EDD4: C3DDED  		jp	defdma
              	;
              	;   read from the directory.
              	;
EDD7: CDE3ED  	dirread:call	dirdma		;set the directory dma address.
EDDA: CDB5EB  		call	doread		;and read it.
              	;
              	;   routine to set the dma address to the users choice.
              	;
EDDD: 21B4F5  	defdma:	ld	hl,userdma	;reset the default dma address and return.
EDE0: C3E6ED  		jp	dirdma1
              	;
              	;   routine to set the dma address for directory work.
              	;
EDE3: 21BCF5  	dirdma:	ld	hl,dirbuf
              	;
              	;   set the dma address. on entry, (hl) points to
              	; word containing the desired dma address.
              	;
EDE6: 4E      	dirdma1:ld	c,(hl)
EDE7: 23      		inc	hl
EDE8: 46      		ld	b,(hl)		;setup (bc) and go to the bios to set it.
EDE9: C34DF6  		jp	setdma
              	;
              	;   move the directory buffer into user's dma space.
              	;
EDEC: 2ABCF5  	movedir:ld	hl,(dirbuf)	;buffer is located here, and
EDEF: EB      		ex	de,hl
EDF0: 2AB4F5  		ld	hl,(userdma)	; put it here.
EDF3: 0E80    		ld	c,128		;this is its length.
EDF5: C352EB  		jp	de2hl		;move it now and return.
              	;
              	;   check (filepos) and set the zero flag if it equals 0ffffh.
              	;
EDF8: 21EDF5  	ckfilpos: ld	hl,filepos
EDFB: 7E      		ld	a,(hl)
EDFC: 23      		inc	hl
EDFD: BE      		cp	(hl)		;are both bytes the same?
EDFE: C0      		ret	nz
EDFF: 3C      		inc	a		;yes, but are they each 0ffh?
EE00: C9      		ret	
              	;
              	;   set location (filepos) to 0ffffh.
              	;
EE01: 21FFFF  	stfilpos: ld	hl,0ffffh
EE04: 22EDF5  		ld	(filepos),hl
EE07: C9      		ret	
              	;
              	;   move on to the next file position within the current
              	; directory buffer. if no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. enter with (c)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
EE08: 2ACBF5  	nxentry:ld	hl,(dirsize)	;get directory entry size limit.
EE0B: EB      		ex	de,hl
EE0C: 2AEDF5  		ld	hl,(filepos)	;get current count.
EE0F: 23      		inc	hl		;go on to the next one.
EE10: 22EDF5  		ld	(filepos),hl
EE13: CD98ED  		call	subhl		;(hl)=(dirsize)-(filepos)
EE16: D21CEE  		jp	nc,nxent1	;is there more room left?
EE19: C301EE  		jp	stfilpos	;no. set this flag and return.
EE1C: 3AEDF5  	nxent1:	ld	a,(filepos)	;get file position within directory.
EE1F: E603    		and	03h		;only look within this sector (only 4 entries fit).
EE21: 0605    		ld	b,5		;convert to relative position (32 bytes each).
EE23: 87      	nxent2:	add	a,a		;note that this is not efficient code.
EE24: 05      		dec	b		;5 'add a's would be better.
EE25: C223EE  		jp	nz,nxent2
EE28: 32ECF5  		ld	(fcbpos),a	;save it as position of fcb.
EE2B: B7      		or	a
EE2C: C0      		ret	nz		;return if we are within buffer.
EE2D: C5      		push	bc
EE2E: CDC6EB  		call	trksec		;we need the next directory sector.
EE31: CDD7ED  		call	dirread
EE34: C1      		pop	bc
EE35: C3A1ED  		jp	checkdir
              	;
              	;   routine to to get a bit from the disk space allocation
              	; map. it is returned in (a), bit position 0. on entry to here,
              	; set (bc) to the block number on the disk to check.
              	; on return, (d) will contain the original bit position for
              	; this block number and (hl) will point to the address for it.
              	;
EE38: 79      	ckbitmap: ld	a,c		;determine bit number of interest.
EE39: E607    		and	07h		;compute (d)=(e)=(c and 7)+1.
EE3B: 3C      		inc	a
EE3C: 5F      		ld	e,a		;save particular bit number.
EE3D: 57      		ld	d,a
              	;
              	;   compute (bc)=(bc)/8.
              	;
EE3E: 79      		ld	a,c
EE3F: 0F      		rrca			;now shift right 3 bits.
EE40: 0F      		rrca	
EE41: 0F      		rrca	
EE42: E61F    		and	1fh		;and clear bits 7,6,5.
EE44: 4F      		ld	c,a
EE45: 78      		ld	a,b
EE46: 87      		add	a,a		;now shift (b) into bits 7,6,5.
EE47: 87      		add	a,a
EE48: 87      		add	a,a
EE49: 87      		add	a,a
EE4A: 87      		add	a,a
EE4B: B1      		or	c		;and add in (c).
EE4C: 4F      		ld	c,a		;ok, (c) ha been completed.
EE4D: 78      		ld	a,b		;is there a better way of doing this?
EE4E: 0F      		rrca	
EE4F: 0F      		rrca	
EE50: 0F      		rrca	
EE51: E61F    		and	1fh
EE53: 47      		ld	b,a		;and now (b) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
EE54: 2AC2F5  		ld	hl,(alocvect)
EE57: 09      		add	hl,bc
EE58: 7E      		ld	a,(hl)		;now get correct byte.
EE59: 07      	ckbmap1:rlca			;get correct bit into position 0.
EE5A: 1D      		dec	e
EE5B: C259EE  		jp	nz,ckbmap1
EE5E: C9      		ret	
              	;
              	;   set or clear the bit map such that block number (bc) will be marked
              	; as used. on entry, if (e)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
EE5F: D5      	stbitmap: push	de
EE60: CD38EE  		call	ckbitmap	;get the byte of interest.
EE63: E6FE    		and	0feh		;clear the affected bit.
EE65: C1      		pop	bc
EE66: B1      		or	c		;and now set it acording to (c).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (a) contains the value, (d) contains the bit
              	; position (1-8), and (hl) points to the address within the
              	; space allocation table for this byte.
              	;
EE67: 0F      	stbmap1:rrca			;restore original bit position.
EE68: 15      		dec	d
EE69: C267EE  		jp	nz,stbmap1
EE6C: 77      		ld	(hl),a		;and stor byte in table.
EE6D: C9      		ret	
              	;
              	;   set/clear space used bits in allocation map for this file.
              	; on entry, (c)=1 to set the map and (c)=0 to clear it.
              	;
EE6E: CD61ED  	setfile:call	fcb2hl		;get address of fcb
EE71: 111000  		ld	de,16
EE74: 19      		add	hl,de		;get to block number bytes.
EE75: C5      		push	bc
EE76: 0E11    		ld	c,17		;check all 17 bytes (max) of table.
EE78: D1      	setfl1:	pop	de
EE79: 0D      		dec	c		;done all bytes yet?
EE7A: C8      		ret	z
EE7B: D5      		push	de
EE7C: 3AE0F5  		ld	a,(bigdisk)	;check disk size for 16 bit block numbers.
EE7F: B7      		or	a
EE80: CA8BEE  		jp	z,setfl2
EE83: C5      		push	bc		;only 8 bit numbers. set (bc) to this one.
EE84: E5      		push	hl
EE85: 4E      		ld	c,(hl)		;get low byte from table, always
EE86: 0600    		ld	b,0		;set high byte to zero.
EE88: C391EE  		jp	setfl3
EE8B: 0D      	setfl2:	dec	c		;for 16 bit block numbers, adjust counter.
EE8C: C5      		push	bc
EE8D: 4E      		ld	c,(hl)		;now get both the low and high bytes.
EE8E: 23      		inc	hl
EE8F: 46      		ld	b,(hl)
EE90: E5      		push	hl
EE91: 79      	setfl3:	ld	a,c		;block used?
EE92: B0      		or	b
EE93: CAA0EE  		jp	z,setfl4
EE96: 2AC9F5  		ld	hl,(dsksize)	;is this block number within the
EE99: 7D      		ld	a,l		;space on the disk?
EE9A: 91      		sub	c
EE9B: 7C      		ld	a,h
EE9C: 98      		sbc	a,b
EE9D: D45FEE  		call	nc,stbitmap	;yes, set the proper bit.
EEA0: E1      	setfl4:	pop	hl		;point to next block number in fcb.
EEA1: 23      		inc	hl
EEA2: C1      		pop	bc
EEA3: C378EE  		jp	setfl1
              	;
              	;   construct the space used allocation bit map for the active
              	; drive. if a file name starts with '$' and it is under the
              	; current user number, then (status) is set to minus 1. otherwise
              	; it is not set at all.
              	;
EEA6: 2AC9F5  	bitmap:	ld	hl,(dsksize)	;compute size of allocation table.
EEA9: 0E03    		ld	c,3
EEAB: CDEDEC  		call	shiftr		;(hl)=(hl)/8.
EEAE: 23      		inc	hl		;at lease 1 byte.
EEAF: 44      		ld	b,h
EEB0: 4D      		ld	c,l		;set (bc) to the allocation table length.
              	;
              	;   initialize the bitmap for this drive. right now, the first
              	; two bytes are specified by the disk parameter block. however
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. for example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
EEB1: 2AC2F5  		ld	hl,(alocvect)	;now zero out the table now.
EEB4: 3600    	bitmap1:ld	(hl),0
EEB6: 23      		inc	hl
EEB7: 0B      		dec	bc
EEB8: 78      		ld	a,b
EEB9: B1      		or	c
EEBA: C2B4EE  		jp	nz,bitmap1
EEBD: 2ACDF5  		ld	hl,(alloc0)	;get initial space used by directory.
EEC0: EB      		ex	de,hl
EEC1: 2AC2F5  		ld	hl,(alocvect)	;and put this into map.
EEC4: 73      		ld	(hl),e
EEC5: 23      		inc	hl
EEC6: 72      		ld	(hl),d
              	;
              	;   end of initialization portion.
              	;
EEC7: CDA4EB  		call	homedrv		;now home the drive.
EECA: 2AB6F5  		ld	hl,(scratch1)
EECD: 3603    		ld	(hl),3		;force next directory request to read
EECF: 23      		inc	hl		;in a sector.
EED0: 3600    		ld	(hl),0
EED2: CD01EE  		call	stfilpos	;clear initial file position also.
EED5: 0EFF    	bitmap2:ld	c,0ffh		;read next file name in directory
EED7: CD08EE  		call	nxentry		;and set checksum byte.
EEDA: CDF8ED  		call	ckfilpos	;is there another file?
EEDD: C8      		ret	z
EEDE: CD61ED  		call	fcb2hl		;yes, get its address.
EEE1: 3EE5    		ld	a,0e5h
EEE3: BE      		cp	(hl)		;empty file entry?
EEE4: CAD5EE  		jp	z,bitmap2
EEE7: 3A44EB  		ld	a,(userno)	;no, correct user number?
EEEA: BE      		cp	(hl)
EEEB: C2F9EE  		jp	nz,bitmap3
EEEE: 23      		inc	hl
EEEF: 7E      		ld	a,(hl)		;yes, does name start with a '$'?
EEF0: D624    		sub	'$'
EEF2: C2F9EE  		jp	nz,bitmap3
EEF5: 3D      		dec	a		;yes, set atatus to minus one.
EEF6: 3248EB  		ld	(status),a
EEF9: 0E01    	bitmap3:ld	c,1		;now set this file's space as used in bit map.
EEFB: CD6EEE  		call	setfile
EEFE: CD8FED  		call	chknmbr		;keep (scratch1) in bounds.
EF01: C3D5EE  		jp	bitmap2
              	;
              	;   set the status (status) and return.
              	;
EF04: 3AD7F5  	ststatus: ld	a,(fndstat)
EF07: C304EB  		jp	setstat
              	;
              	;   check extents in (a) and (c). set the zero flag if they
              	; are the same. the number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (extmask+1).
              	; no registers are modified.
              	;
EF0A: C5      	samext:	push	bc
EF0B: F5      		push	af
EF0C: 3AC8F5  		ld	a,(extmask)	;get extent mask and use it to
EF0F: 2F      		cpl			;to compare both extent numbers.
EF10: 47      		ld	b,a		;save resulting mask here.
EF11: 79      		ld	a,c		;mask first extent and save in (c).
EF12: A0      		and	b
EF13: 4F      		ld	c,a
EF14: F1      		pop	af		;now mask second extent and compare
EF15: A0      		and	b		;with the first one.
EF16: 91      		sub	c
EF17: E61F    		and	1fh		;(* only check buts 0-4 *)
EF19: C1      		pop	bc		;the zero flag is set if they are the same.
EF1A: C9      		ret			;restore (bc) and return.
              	;
              	;   search for the first occurence of a file name. on entry,
              	; register (c) should contain the number of bytes of the fcb
              	; that must match.
              	;
EF1B: 3EFF    	findfst:ld	a,0ffh
EF1D: 32D7F5  		ld	(fndstat),a
EF20: 21DBF5  		ld	hl,counter	;save character count.
EF23: 71      		ld	(hl),c
EF24: 2A46EB  		ld	hl,(params)	;get filename to match.
EF27: 22DCF5  		ld	(savefcb),hl	;and save.
EF2A: CD01EE  		call	stfilpos	;clear initial file position (set to 0ffffh).
EF2D: CDA4EB  		call	homedrv		;home the drive.
              	;
              	;   entry to locate the next occurence of a filename within the
              	; directory. the disk is not expected to have been changed. if
              	; it was, then it will be write protected.
              	;
EF30: 0E00    	findnxt:ld	c,0		;write protect the disk if changed.
EF32: CD08EE  		call	nxentry		;get next filename entry in directory.
EF35: CDF8ED  		call	ckfilpos	;is file position = 0ffffh?
EF38: CA97EF  		jp	z,fndnxt6	;yes, exit now then.
EF3B: 2ADCF5  		ld	hl,(savefcb)	;set (de) pointing to filename to match.
EF3E: EB      		ex	de,hl
EF3F: 1A      		ld	a,(de)
EF40: FEE5    		cp	0e5h		;empty directory entry?
EF42: CA4DEF  		jp	z,fndnxt1	;(* are we trying to reserect erased entries? *)
EF45: D5      		push	de
EF46: CD82ED  		call	morefls		;more files in directory?
EF49: D1      		pop	de
EF4A: D297EF  		jp	nc,fndnxt6	;no more. exit now.
EF4D: CD61ED  	fndnxt1:call	fcb2hl		;get address of this fcb in directory.
EF50: 3ADBF5  		ld	a,(counter)	;get number of bytes (characters) to check.
EF53: 4F      		ld	c,a
EF54: 0600    		ld	b,0		;initialize byte position counter.
EF56: 79      	fndnxt2:ld	a,c		;are we done with the compare?
EF57: B7      		or	a
EF58: CA86EF  		jp	z,fndnxt5
EF5B: 1A      		ld	a,(de)		;no, check next byte.
EF5C: FE3F    		cp	'?'		;don't care about this character?
EF5E: CA7FEF  		jp	z,fndnxt4
EF61: 78      		ld	a,b		;get bytes position in fcb.
EF62: FE0D    		cp	13		;don't care about the thirteenth byte either.
EF64: CA7FEF  		jp	z,fndnxt4
EF67: FE0C    		cp	12		;extent byte?
EF69: 1A      		ld	a,(de)
EF6A: CA76EF  		jp	z,fndnxt3
EF6D: 96      		sub	(hl)		;otherwise compare characters.
EF6E: E67F    		and	7fh
EF70: C230EF  		jp	nz,findnxt	;not the same, check next entry.
EF73: C37FEF  		jp	fndnxt4		;so far so good, keep checking.
EF76: C5      	fndnxt3:push	bc		;check the extent byte here.
EF77: 4E      		ld	c,(hl)
EF78: CD0AEF  		call	samext
EF7B: C1      		pop	bc
EF7C: C230EF  		jp	nz,findnxt	;not the same, look some more.
              	;
              	;   so far the names compare. bump pointers to the next byte
              	; and continue until all (c) characters have been checked.
              	;
EF7F: 13      	fndnxt4:inc	de		;bump pointers.
EF80: 23      		inc	hl
EF81: 04      		inc	b
EF82: 0D      		dec	c		;adjust character counter.
EF83: C356EF  		jp	fndnxt2
EF86: 3AEDF5  	fndnxt5:ld	a,(filepos)	;return the position of this entry.
EF89: E603    		and	03h
EF8B: 3248EB  		ld	(status),a
EF8E: 21D7F5  		ld	hl,fndstat
EF91: 7E      		ld	a,(hl)
EF92: 17      		rla	
EF93: D0      		ret	nc
EF94: AF      		xor	a
EF95: 77      		ld	(hl),a
EF96: C9      		ret	
              	;
              	;   filename was not found. set appropriate status.
              	;
EF97: CD01EE  	fndnxt6:call	stfilpos	;set (filepos) to 0ffffh.
EF9A: 3EFF    		ld	a,0ffh		;say not located.
EF9C: C304EB  		jp	setstat
              	;
              	;   erase files from the directory. only the first byte of the
              	; fcb will be affected. it is set to (e5).
              	;
EF9F: CD57ED  	erafile:call	chkwprt		;is disk write protected?
EFA2: 0E0C    		ld	c,12		;only compare file names.
EFA4: CD1BEF  		call	findfst		;get first file name.
EFA7: CDF8ED  	erafil1:call	ckfilpos	;any found?
EFAA: C8      		ret	z		;nope, we must be done.
EFAB: CD47ED  		call	chkrofl		;is file read only?
EFAE: CD61ED  		call	fcb2hl		;nope, get address of fcb and
EFB1: 36E5    		ld	(hl),0e5h	;set first byte to 'empty'.
EFB3: 0E00    		ld	c,0		;clear the space from the bit map.
EFB5: CD6EEE  		call	setfile
EFB8: CDC9ED  		call	dirwrite	;now write the directory sector back out.
EFBB: CD30EF  		call	findnxt		;find the next file name.
EFBE: C3A7EF  		jp	erafil1		;and repeat process.
              	;
              	;   look through the space allocation map (bit map) for the
              	; next available block. start searching at block number (bc-1).
              	; the search procedure is to look for an empty block that is
              	; before the starting block. if not empty, look at a later
              	; block number. in this way, we return the closest empty block
              	; on either side of the 'target' block number. this will speed
              	; access on random devices. for serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   on return, (de)= block number that is empty and (hl) =0
              	; if no empry block was found.
              	;
EFC1: 50      	fndspace: ld	d,b		;set (de) as the block that is checked.
EFC2: 59      		ld	e,c
              	;
              	;   look before target block. registers (bc) are used as the lower
              	; pointer and (de) as the upper pointer.
              	;
EFC3: 79      	fndspa1:ld	a,c		;is block 0 specified?
EFC4: B0      		or	b
EFC5: CAD4EF  		jp	z,fndspa2
EFC8: 0B      		dec	bc		;nope, check previous block.
EFC9: D5      		push	de
EFCA: C5      		push	bc
EFCB: CD38EE  		call	ckbitmap
EFCE: 1F      		rra			;is this block empty?
EFCF: D2EFEF  		jp	nc,fndspa3	;yes. use this.
              	;
              	;   note that the above logic gets the first block that it finds
              	; that is empty. thus a file could be written 'backward' making
              	; it very slow to access. this could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; this should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
EFD2: C1      		pop	bc		;nope, check some more.
EFD3: D1      		pop	de
              	;
              	;   now look after target block.
              	;
EFD4: 2AC9F5  	fndspa2:ld	hl,(dsksize)	;is block (de) within disk limits?
EFD7: 7B      		ld	a,e
EFD8: 95      		sub	l
EFD9: 7A      		ld	a,d
EFDA: 9C      		sbc	a,h
EFDB: D2F7EF  		jp	nc,fndspa4
EFDE: 13      		inc	de		;yes, move on to next one.
EFDF: C5      		push	bc
EFE0: D5      		push	de
EFE1: 42      		ld	b,d
EFE2: 4B      		ld	c,e
EFE3: CD38EE  		call	ckbitmap	;check it.
EFE6: 1F      		rra			;empty?
EFE7: D2EFEF  		jp	nc,fndspa3
EFEA: D1      		pop	de		;nope, continue searching.
EFEB: C1      		pop	bc
EFEC: C3C3EF  		jp	fndspa1
              	;
              	;   empty block found. set it as used and return with (hl)
              	; pointing to it (true?).
              	;
EFEF: 17      	fndspa3:rla			;reset byte.
EFF0: 3C      		inc	a		;and set bit 0.
EFF1: CD67EE  		call	stbmap1		;update bit map.
EFF4: E1      		pop	hl		;set return registers.
EFF5: D1      		pop	de
EFF6: C9      		ret	
              	;
              	;   free block was not found. if (bc) is not zero, then we have
              	; not checked all of the disk space.
              	;
EFF7: 79      	fndspa4:ld	a,c
EFF8: B0      		or	b
EFF9: C2C3EF  		jp	nz,fndspa1
EFFC: 210000  		ld	hl,0		;set 'not found' status.
EFFF: C9      		ret	
              	;
              	;   move a complete fcb entry into the directory and write it.
              	;
F000: 0E00    	fcbset:	ld	c,0
F002: 1E20    		ld	e,32		;length of each entry.
              	;
              	;   move (e) bytes from the fcb pointed to by (params) into
              	; fcb in directory starting at relative byte (c). this updated
              	; directory buffer is then written to the disk.
              	;
F004: D5      	update:	push	de
F005: 0600    		ld	b,0		;set (bc) to relative byte position.
F007: 2A46EB  		ld	hl,(params)	;get address of fcb.
F00A: 09      		add	hl,bc		;compute starting byte.
F00B: EB      		ex	de,hl
F00C: CD61ED  		call	fcb2hl		;get address of fcb to update in directory.
F00F: C1      		pop	bc		;set (c) to number of bytes to change.
F010: CD52EB  		call	de2hl
F013: CDC6EB  	update1:call	trksec		;determine the track and sector affected.
F016: C3C9ED  		jp	dirwrite	;then write this sector out.
              	;
              	;   routine to change the name of all files on the disk with a
              	; specified name. the fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
F019: CD57ED  	chgnames: call	chkwprt		;check for a write protected disk.
F01C: 0E0C    		ld	c,12		;match first 12 bytes of fcb only.
F01E: CD1BEF  		call	findfst		;get first name.
F021: 2A46EB  		ld	hl,(params)	;get address of fcb.
F024: 7E      		ld	a,(hl)		;get user number.
F025: 111000  		ld	de,16		;move over to desired name.
F028: 19      		add	hl,de
F029: 77      		ld	(hl),a		;keep same user number.
F02A: CDF8ED  	chgnam1:call	ckfilpos	;any matching file found?
F02D: C8      		ret	z		;no, we must be done.
F02E: CD47ED  		call	chkrofl		;check for read only file.
F031: 0E10    		ld	c,16		;start 16 bytes into fcb.
F033: 1E0C    		ld	e,12		;and update the first 12 bytes of directory.
F035: CD04F0  		call	update
F038: CD30EF  		call	findnxt		;get te next file name.
F03B: C32AF0  		jp	chgnam1		;and continue.
              	;
              	;   update a files attributes. the procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). no other changes
              	; are made.
              	;
F03E: 0E0C    	saveattr: ld	c,12		;match first 12 bytes.
F040: CD1BEF  		call	findfst		;look for first filename.
F043: CDF8ED  	savatr1:call	ckfilpos	;was one found?
F046: C8      		ret	z		;nope, we must be done.
F047: 0E00    		ld	c,0		;yes, update the first 12 bytes now.
F049: 1E0C    		ld	e,12
F04B: CD04F0  		call	update		;update filename and write directory.
F04E: CD30EF  		call	findnxt		;and get the next file.
F051: C343F0  		jp	savatr1		;then continue until done.
              	;
              	;  open a file (name specified in fcb).
              	;
F054: 0E0F    	openit:	ld	c,15		;compare the first 15 bytes.
F056: CD1BEF  		call	findfst		;get the first one in directory.
F059: CDF8ED  		call	ckfilpos	;any at all?
F05C: C8      		ret	z
F05D: CDA9EC  	openit1:call	setext		;point to extent byte within users fcb.
F060: 7E      		ld	a,(hl)		;and get it.
F061: F5      		push	af		;save it and address.
F062: E5      		push	hl
F063: CD61ED  		call	fcb2hl		;point to fcb in directory.
F066: EB      		ex	de,hl
F067: 2A46EB  		ld	hl,(params)	;this is the users copy.
F06A: 0E20    		ld	c,32		;move it into users space.
F06C: D5      		push	de
F06D: CD52EB  		call	de2hl
F070: CD7BED  		call	sets2b7		;set bit 7 in 's2' byte (unmodified).
F073: D1      		pop	de		;now get the extent byte from this fcb.
F074: 210C00  		ld	hl,12
F077: 19      		add	hl,de
F078: 4E      		ld	c,(hl)		;into (c).
F079: 210F00  		ld	hl,15		;now get the record count byte into (b).
F07C: 19      		add	hl,de
F07D: 46      		ld	b,(hl)
F07E: E1      		pop	hl		;keep the same extent as the user had originally.
F07F: F1      		pop	af
F080: 77      		ld	(hl),a
F081: 79      		ld	a,c		;is it the same as in the directory fcb?
F082: BE      		cp	(hl)
F083: 78      		ld	a,b		;if yes, then use the same record count.
F084: CA8EF0  		jp	z,openit2
F087: 3E00    		ld	a,0		;if the user specified an extent greater than
F089: DA8EF0  		jp	c,openit2	;the one in the directory, then set record count to 0.
F08C: 3E80    		ld	a,128		;otherwise set to maximum.
F08E: 2A46EB  	openit2:ld	hl,(params)	;set record count in users fcb to (a).
F091: 110F00  		ld	de,15
F094: 19      		add	hl,de		;compute relative position.
F095: 77      		ld	(hl),a		;and set the record count.
F096: C9      		ret	
              	;
              	;   move two bytes from (de) to (hl) if (and only if) (hl)
              	; point to a zero value (16 bit).
              	;   return with zero flag set it (de) was moved. registers (de)
              	; and (hl) are not changed. however (a) is.
              	;
F097: 7E      	moveword: ld	a,(hl)		;check for a zero word.
F098: 23      		inc	hl
F099: B6      		or	(hl)		;both bytes zero?
F09A: 2B      		dec	hl
F09B: C0      		ret	nz		;nope, just return.
F09C: 1A      		ld	a,(de)		;yes, move two bytes from (de) into
F09D: 77      		ld	(hl),a		;this zero space.
F09E: 13      		inc	de
F09F: 23      		inc	hl
F0A0: 1A      		ld	a,(de)
F0A1: 77      		ld	(hl),a
F0A2: 1B      		dec	de		;don't disturb these registers.
F0A3: 2B      		dec	hl
F0A4: C9      		ret	
              	;
              	;   get here to close a file specified by (fcb).
              	;
F0A5: AF      	closeit:xor	a		;clear status and file position bytes.
F0A6: 3248EB  		ld	(status),a
F0A9: 32EDF5  		ld	(filepos),a
F0AC: 32EEF5  		ld	(filepos+1),a
F0AF: CD21ED  		call	getwprt		;get write protect bit for this drive.
F0B2: C0      		ret	nz		;just return if it is set.
F0B3: CD6CED  		call	gets2		;else get the 's2' byte.
F0B6: E680    		and	80h		;and look at bit 7 (file unmodified?).
F0B8: C0      		ret	nz		;just return if set.
F0B9: 0E0F    		ld	c,15		;else look up this file in directory.
F0BB: CD1BEF  		call	findfst
F0BE: CDF8ED  		call	ckfilpos	;was it found?
F0C1: C8      		ret	z		;just return if not.
F0C2: 011000  		ld	bc,16		;set (hl) pointing to records used section.
F0C5: CD61ED  		call	fcb2hl
F0C8: 09      		add	hl,bc
F0C9: EB      		ex	de,hl
F0CA: 2A46EB  		ld	hl,(params)	;do the same for users specified fcb.
F0CD: 09      		add	hl,bc
F0CE: 0E10    		ld	c,16		;this many bytes are present in this extent.
F0D0: 3AE0F5  	closeit1: ld	a,(bigdisk)	;8 or 16 bit record numbers?
F0D3: B7      		or	a
F0D4: CAEBF0  		jp	z,closeit4
F0D7: 7E      		ld	a,(hl)		;just 8 bit. get one from users fcb.
F0D8: B7      		or	a
F0D9: 1A      		ld	a,(de)		;now get one from directory fcb.
F0DA: C2DEF0  		jp	nz,closeit2
F0DD: 77      		ld	(hl),a		;users byte was zero. update from directory.
F0DE: B7      	closeit2: or	a
F0DF: C2E4F0  		jp	nz,closeit3
F0E2: 7E      		ld	a,(hl)		;directories byte was zero, update from users fcb.
F0E3: 12      		ld	(de),a
F0E4: BE      	closeit3: cp	(hl)		;if neither one of these bytes were zero,
F0E5: C222F1  		jp	nz,closeit7	;then close error if they are not the same.
F0E8: C300F1  		jp	closeit5	;ok so far, get to next byte in fcbs.
F0EB: CD97F0  	closeit4: call	moveword	;update users fcb if it is zero.
F0EE: EB      		ex	de,hl
F0EF: CD97F0  		call	moveword	;update directories fcb if it is zero.
F0F2: EB      		ex	de,hl
F0F3: 1A      		ld	a,(de)		;if these two values are no different,
F0F4: BE      		cp	(hl)		;then a close error occured.
F0F5: C222F1  		jp	nz,closeit7
F0F8: 13      		inc	de		;check second byte.
F0F9: 23      		inc	hl
F0FA: 1A      		ld	a,(de)
F0FB: BE      		cp	(hl)
F0FC: C222F1  		jp	nz,closeit7
F0FF: 0D      		dec	c		;remember 16 bit values.
F100: 13      	closeit5: inc	de		;bump to next item in table.
F101: 23      		inc	hl
F102: 0D      		dec	c		;there are 16 entries only.
F103: C2D0F0  		jp	nz,closeit1	;continue if more to do.
F106: 01ECFF  		ld	bc,0ffech	;backup 20 places (extent byte).
F109: 09      		add	hl,bc
F10A: EB      		ex	de,hl
F10B: 09      		add	hl,bc
F10C: 1A      		ld	a,(de)
F10D: BE      		cp	(hl)		;directory's extent already greater than the
F10E: DA1AF1  		jp	c,closeit6	;users extent?
F111: 77      		ld	(hl),a		;no, update directory extent.
F112: 010300  		ld	bc,3		;and update the record count byte in
F115: 09      		add	hl,bc		;directories fcb.
F116: EB      		ex	de,hl
F117: 09      		add	hl,bc
F118: 7E      		ld	a,(hl)		;get from user.
F119: 12      		ld	(de),a		;and put in directory.
F11A: 3EFF    	closeit6: ld	a,0ffh		;set 'was open and is now closed' byte.
F11C: 32D5F5  		ld	(closeflg),a
F11F: C313F0  		jp	update1		;update the directory now.
F122: 2148EB  	closeit7: ld	hl,status	;set return status and then return.
F125: 35      		dec	(hl)
F126: C9      		ret	
              	;
              	;   routine to get the next empty space in the directory. it
              	; will then be cleared for use.
              	;
F127: CD57ED  	getempty: call	chkwprt		;make sure disk is not write protected.
F12A: 2A46EB  		ld	hl,(params)	;save current parameters (fcb).
F12D: E5      		push	hl
F12E: 21AFF5  		ld	hl,emptyfcb	;use special one for empty space.
F131: 2246EB  		ld	(params),hl
F134: 0E01    		ld	c,1		;search for first empty spot in directory.
F136: CD1BEF  		call	findfst		;(* only check first byte *)
F139: CDF8ED  		call	ckfilpos	;none?
F13C: E1      		pop	hl
F13D: 2246EB  		ld	(params),hl	;restore original fcb address.
F140: C8      		ret	z		;return if no more space.
F141: EB      		ex	de,hl
F142: 210F00  		ld	hl,15		;point to number of records for this file.
F145: 19      		add	hl,de
F146: 0E11    		ld	c,17		;and clear all of this space.
F148: AF      		xor	a
F149: 77      	getmt1:	ld	(hl),a
F14A: 23      		inc	hl
F14B: 0D      		dec	c
F14C: C249F1  		jp	nz,getmt1
F14F: 210D00  		ld	hl,13		;clear the 's1' byte also.
F152: 19      		add	hl,de
F153: 77      		ld	(hl),a
F154: CD8FED  		call	chknmbr		;keep (scratch1) within bounds.
F157: CD00F0  		call	fcbset		;write out this fcb entry to directory.
F15A: C37BED  		jp	sets2b7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   routine to close the current extent and open the next one
              	; for reading.
              	;
F15D: AF      	getnext:xor	a
F15E: 32D5F5  		ld	(closeflg),a	;clear close flag.
F161: CDA5F0  		call	closeit		;close this extent.
F164: CDF8ED  		call	ckfilpos
F167: C8      		ret	z		;not there???
F168: 2A46EB  		ld	hl,(params)	;get extent byte.
F16B: 010C00  		ld	bc,12
F16E: 09      		add	hl,bc
F16F: 7E      		ld	a,(hl)		;and increment it.
F170: 3C      		inc	a
F171: E61F    		and	1fh		;keep within range 0-31.
F173: 77      		ld	(hl),a
F174: CA86F1  		jp	z,gtnext1	;overflow?
F177: 47      		ld	b,a		;mask extent byte.
F178: 3AC8F5  		ld	a,(extmask)
F17B: A0      		and	b
F17C: 21D5F5  		ld	hl,closeflg	;check close flag (0ffh is ok).
F17F: A6      		and	(hl)
F180: CA91F1  		jp	z,gtnext2	;if zero, we must read in next extent.
F183: C3AFF1  		jp	gtnext3		;else, it is already in memory.
F186: 010200  	gtnext1:ld	bc,2		;point to the 's2' byte.
F189: 09      		add	hl,bc
F18A: 34      		inc	(hl)		;and bump it.
F18B: 7E      		ld	a,(hl)		;too many extents?
F18C: E60F    		and	0fh
F18E: CAB9F1  		jp	z,gtnext5	;yes, set error code.
              	;
              	;   get here to open the next extent.
              	;
F191: 0E0F    	gtnext2:ld	c,15		;set to check first 15 bytes of fcb.
F193: CD1BEF  		call	findfst		;find the first one.
F196: CDF8ED  		call	ckfilpos	;none available?
F199: C2AFF1  		jp	nz,gtnext3
F19C: 3AD6F5  		ld	a,(rdwrtflg)	;no extent present. can we open an empty one?
F19F: 3C      		inc	a		;0ffh means reading (so not possible).
F1A0: CAB9F1  		jp	z,gtnext5	;or an error.
F1A3: CD27F1  		call	getempty	;we are writing, get an empty entry.
F1A6: CDF8ED  		call	ckfilpos	;none?
F1A9: CAB9F1  		jp	z,gtnext5	;error if true.
F1AC: C3B2F1  		jp	gtnext4		;else we are almost done.
F1AF: CD5DF0  	gtnext3:call	openit1		;open this extent.
F1B2: CDBEEC  	gtnext4:call	strdata		;move in updated data (rec #, extent #, etc.)
F1B5: AF      		xor	a		;clear status and return.
F1B6: C304EB  		jp	setstat
              	;
              	;   error in extending the file. too many extents were needed
              	; or not enough space on the disk.
              	;
F1B9: CD08EB  	gtnext5:call	ioerr1		;set error code, clear bit 7 of 's2'
F1BC: C37BED  		jp	sets2b7		;so this is not written on a close.
              	;
              	;   read a sequential file.
              	;
F1BF: 3E01    	rdseq:	ld	a,1		;set sequential access mode.
F1C1: 32D8F5  		ld	(mode),a
F1C4: 3EFF    	rdseq1:	ld	a,0ffh		;don't allow reading unwritten space.
F1C6: 32D6F5  		ld	(rdwrtflg),a
F1C9: CDBEEC  		call	strdata		;put rec# and ext# into fcb.
F1CC: 3AE6F5  		ld	a,(savnrec)	;get next record to read.
F1CF: 21E4F5  		ld	hl,savnxt	;get number of records in extent.
F1D2: BE      		cp	(hl)		;within this extent?
F1D3: DAE9F1  		jp	c,rdseq2
F1D6: FE80    		cp	128		;no. is this extent fully used?
F1D8: C2FEF1  		jp	nz,rdseq3	;no. end-of-file.
F1DB: CD5DF1  		call	getnext		;yes, open the next one.
F1DE: AF      		xor	a		;reset next record to read.
F1DF: 32E6F5  		ld	(savnrec),a
F1E2: 3A48EB  		ld	a,(status)	;check on open, successful?
F1E5: B7      		or	a
F1E6: C2FEF1  		jp	nz,rdseq3	;no, error.
F1E9: CD7AEC  	rdseq2:	call	comblk		;ok. compute block number to read.
F1EC: CD87EC  		call	chkblk		;check it. within bounds?
F1EF: CAFEF1  		jp	z,rdseq3	;no, error.
F1F2: CD8DEC  		call	logical		;convert (blknmbr) to logical sector (128 byte).
F1F5: CDD4EB  		call	trksec1		;set the track and sector for this block #.
F1F8: CDB5EB  		call	doread		;and read it.
F1FB: C3D5EC  		jp	setnrec		;and set the next record to be accessed.
              	;
              	;   read error occured. set status and return.
              	;
F1FE: C308EB  	rdseq3:	jp	ioerr1
              	;
              	;   write the next sequential record.
              	;
F201: 3E01    	wtseq:	ld	a,1		;set sequential access mode.
F203: 32D8F5  		ld	(mode),a
F206: 3E00    	wtseq1:	ld	a,0		;allow an addition empty extent to be opened.
F208: 32D6F5  		ld	(rdwrtflg),a
F20B: CD57ED  		call	chkwprt		;check write protect status.
F20E: 2A46EB  		ld	hl,(params)
F211: CD4AED  		call	ckrof1		;check for read only file, (hl) already set to fcb.
F214: CDBEEC  		call	strdata		;put updated data into fcb.
F217: 3AE6F5  		ld	a,(savnrec)	;get record number to write.
F21A: FE80    		cp	128		;within range?
F21C: D208EB  		jp	nc,ioerr1	;no, error(?).
F21F: CD7AEC  		call	comblk		;compute block number.
F222: CD87EC  		call	chkblk		;check number.
F225: 0E00    		ld	c,0		;is there one to write to?
F227: C271F2  		jp	nz,wtseq6	;yes, go do it.
F22A: CD41EC  		call	getblock	;get next block number within fcb to use.
F22D: 32DAF5  		ld	(relblock),a	;and save.
F230: 010000  		ld	bc,0		;start looking for space from the start
F233: B7      		or	a		;if none allocated as yet.
F234: CA3EF2  		jp	z,wtseq2
F237: 4F      		ld	c,a		;extract previous block number from fcb
F238: 0B      		dec	bc		;so we can be closest to it.
F239: CD61EC  		call	extblk
F23C: 44      		ld	b,h
F23D: 4D      		ld	c,l
F23E: CDC1EF  	wtseq2:	call	fndspace	;find the next empty block nearest number (bc).
F241: 7D      		ld	a,l		;check for a zero number.
F242: B4      		or	h
F243: C24BF2  		jp	nz,wtseq3
F246: 3E02    		ld	a,2		;no more space?
F248: C304EB  		jp	setstat
F24B: 22E8F5  	wtseq3:	ld	(blknmbr),hl	;save block number to access.
F24E: EB      		ex	de,hl		;put block number into (de).
F24F: 2A46EB  		ld	hl,(params)	;now we must update the fcb for this
F252: 011000  		ld	bc,16		;newly allocated block.
F255: 09      		add	hl,bc
F256: 3AE0F5  		ld	a,(bigdisk)	;8 or 16 bit block numbers?
F259: B7      		or	a
F25A: 3ADAF5  		ld	a,(relblock)	;(* update this entry *)
F25D: CA67F2  		jp	z,wtseq4	;zero means 16 bit ones.
F260: CD67ED  		call	adda2hl		;(hl)=(hl)+(a)
F263: 73      		ld	(hl),e		;store new block number.
F264: C36FF2  		jp	wtseq5
F267: 4F      	wtseq4:	ld	c,a		;compute spot in this 16 bit table.
F268: 0600    		ld	b,0
F26A: 09      		add	hl,bc
F26B: 09      		add	hl,bc
F26C: 73      		ld	(hl),e		;stuff block number (de) there.
F26D: 23      		inc	hl
F26E: 72      		ld	(hl),d
F26F: 0E02    	wtseq5:	ld	c,2		;set (c) to indicate writing to un-used disk space.
F271: 3A48EB  	wtseq6:	ld	a,(status)	;are we ok so far?
F274: B7      		or	a
F275: C0      		ret	nz
F276: C5      		push	bc		;yes, save write flag for bios (register c).
F277: CD8DEC  		call	logical		;convert (blknmbr) over to loical sectors.
F27A: 3AD8F5  		ld	a,(mode)	;get access mode flag (1=sequential,
F27D: 3D      		dec	a		;0=random, 2=special?).
F27E: 3D      		dec	a
F27F: C2BEF2  		jp	nz,wtseq9
              	;
              	;   special random i/o from function #40. maybe for m/pm, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
F282: C1      		pop	bc
F283: C5      		push	bc
F284: 79      		ld	a,c		;get write status flag (2=writing unused space).
F285: 3D      		dec	a
F286: 3D      		dec	a
F287: C2BEF2  		jp	nz,wtseq9
F28A: E5      		push	hl
F28B: 2ABCF5  		ld	hl,(dirbuf)	;zero out the directory buffer.
F28E: 57      		ld	d,a		;note that (a) is zero here.
F28F: 77      	wtseq7:	ld	(hl),a
F290: 23      		inc	hl
F291: 14      		inc	d		;do 128 bytes.
F292: F28FF2  		jp	p,wtseq7
F295: CDE3ED  		call	dirdma		;tell the bios the dma address for directory access.
F298: 2AEAF5  		ld	hl,(logsect)	;get sector that starts current block.
F29B: 0E02    		ld	c,2		;set 'writing to unused space' flag.
F29D: 22E8F5  	wtseq8:	ld	(blknmbr),hl	;save sector to write.
F2A0: C5      		push	bc
F2A1: CDD4EB  		call	trksec1		;determine its track and sector numbers.
F2A4: C1      		pop	bc
F2A5: CDBBEB  		call	dowrite		;now write out 128 bytes of zeros.
F2A8: 2AE8F5  		ld	hl,(blknmbr)	;get sector number.
F2AB: 0E00    		ld	c,0		;set normal write flag.
F2AD: 3AC7F5  		ld	a,(blkmask)	;determine if we have written the entire
F2B0: 47      		ld	b,a		;physical block.
F2B1: A5      		and	l
F2B2: B8      		cp	b
F2B3: 23      		inc	hl		;prepare for the next one.
F2B4: C29DF2  		jp	nz,wtseq8	;continue until (blkmask+1) sectors written.
F2B7: E1      		pop	hl		;reset next sector number.
F2B8: 22E8F5  		ld	(blknmbr),hl
F2BB: CDDDED  		call	defdma		;and reset dma address.
              	;
              	;   normal disk write. set the desired track and sector then
              	; do the actual write.
              	;
F2BE: CDD4EB  	wtseq9:	call	trksec1		;determine track and sector for this write.
F2C1: C1      		pop	bc		;get write status flag.
F2C2: C5      		push	bc
F2C3: CDBBEB  		call	dowrite		;and write this out.
F2C6: C1      		pop	bc
F2C7: 3AE6F5  		ld	a,(savnrec)	;get number of records in file.
F2CA: 21E4F5  		ld	hl,savnxt	;get last record written.
F2CD: BE      		cp	(hl)
F2CE: DAD5F2  		jp	c,wtseq10
F2D1: 77      		ld	(hl),a		;we have to update record count.
F2D2: 34      		inc	(hl)
F2D3: 0E02    		ld	c,2
              	;
              	;*   this area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the bios.
              	;
F2D5: 00      	wtseq10:nop			;was 'dcr c'
F2D6: 00      		nop			;was 'dcr c'
F2D7: 210000  		ld	hl,0		;was 'jnz wtseq99'
              	;
              	; *   end of patch.
              	;
F2DA: F5      		push	af
F2DB: CD6CED  		call	gets2		;set 'extent written to' flag.
F2DE: E67F    		and	7fh		;(* clear bit 7 *)
F2E0: 77      		ld	(hl),a
F2E1: F1      		pop	af		;get record count for this extent.
F2E2: FE7F    	wtseq99:cp	127		;is it full?
F2E4: C203F3  		jp	nz,wtseq12
F2E7: 3AD8F5  		ld	a,(mode)	;yes, are we in sequential mode?
F2EA: FE01    		cp	1
F2EC: C203F3  		jp	nz,wtseq12
F2EF: CDD5EC  		call	setnrec		;yes, set next record number.
F2F2: CD5DF1  		call	getnext		;and get next empty space in directory.
F2F5: 2148EB  		ld	hl,status	;ok?
F2F8: 7E      		ld	a,(hl)
F2F9: B7      		or	a
F2FA: C201F3  		jp	nz,wtseq11
F2FD: 3D      		dec	a		;yes, set record count to -1.
F2FE: 32E6F5  		ld	(savnrec),a
F301: 3600    	wtseq11:ld	(hl),0		;clear status.
F303: C3D5EC  	wtseq12:jp	setnrec		;set next record to access.
              	;
              	;   for random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. these bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   on entry, register (c) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. otherwise,
              	; another extent will be opened (for writing) if required.
              	;
F306: AF      	position: xor	a		;set random i/o flag.
F307: 32D8F5  		ld	(mode),a
              	;
              	;   special entry (function #40). m/pm ?
              	;
F30A: C5      	positn1:push	bc		;save read/write flag.
F30B: 2A46EB  		ld	hl,(params)	;get address of fcb.
F30E: EB      		ex	de,hl
F30F: 212100  		ld	hl,33		;now get byte 'r0'.
F312: 19      		add	hl,de
F313: 7E      		ld	a,(hl)
F314: E67F    		and	7fh		;keep bits 0-6 for the record number to access.
F316: F5      		push	af
F317: 7E      		ld	a,(hl)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
F318: 17      		rla	
F319: 23      		inc	hl
F31A: 7E      		ld	a,(hl)
F31B: 17      		rla	
F31C: E61F    		and	1fh		;and save this in bits 0-4 of (c).
F31E: 4F      		ld	c,a		;this is the extent byte.
F31F: 7E      		ld	a,(hl)		;now get the extra extent byte.
F320: 1F      		rra	
F321: 1F      		rra	
F322: 1F      		rra	
F323: 1F      		rra	
F324: E60F    		and	0fh
F326: 47      		ld	b,a		;and save it in (b).
F327: F1      		pop	af		;get record number back to (a).
F328: 23      		inc	hl		;check overflow byte 'r2'.
F329: 6E      		ld	l,(hl)
F32A: 2C      		inc	l
F32B: 2D      		dec	l
F32C: 2E06    		ld	l,6		;prepare for error.
F32E: C28EF3  		jp	nz,positn5	;out of disk space error.
F331: 212000  		ld	hl,32		;store record number into fcb.
F334: 19      		add	hl,de
F335: 77      		ld	(hl),a
F336: 210C00  		ld	hl,12		;and now check the extent byte.
F339: 19      		add	hl,de
F33A: 79      		ld	a,c
F33B: 96      		sub	(hl)		;same extent as before?
F33C: C24AF3  		jp	nz,positn2
F33F: 210E00  		ld	hl,14		;yes, check extra extent byte 's2' also.
F342: 19      		add	hl,de
F343: 78      		ld	a,b
F344: 96      		sub	(hl)
F345: E67F    		and	7fh
F347: CA82F3  		jp	z,positn3	;same, we are almost done then.
              	;
              	;  get here when another extent is required.
              	;
F34A: C5      	positn2:push	bc
F34B: D5      		push	de
F34C: CDA5F0  		call	closeit		;close current extent.
F34F: D1      		pop	de
F350: C1      		pop	bc
F351: 2E03    		ld	l,3		;prepare for error.
F353: 3A48EB  		ld	a,(status)
F356: 3C      		inc	a
F357: CA87F3  		jp	z,positn4	;close error.
F35A: 210C00  		ld	hl,12		;put desired extent into fcb now.
F35D: 19      		add	hl,de
F35E: 71      		ld	(hl),c
F35F: 210E00  		ld	hl,14		;and store extra extent byte 's2'.
F362: 19      		add	hl,de
F363: 70      		ld	(hl),b
F364: CD54F0  		call	openit		;try and get this extent.
F367: 3A48EB  		ld	a,(status)	;was it there?
F36A: 3C      		inc	a
F36B: C282F3  		jp	nz,positn3
F36E: C1      		pop	bc		;no. can we create a new one (writing?).
F36F: C5      		push	bc
F370: 2E04    		ld	l,4		;prepare for error.
F372: 0C      		inc	c
F373: CA87F3  		jp	z,positn4	;nope, reading unwritten space error.
F376: CD27F1  		call	getempty	;yes we can, try to find space.
F379: 2E05    		ld	l,5		;prepare for error.
F37B: 3A48EB  		ld	a,(status)
F37E: 3C      		inc	a
F37F: CA87F3  		jp	z,positn4	;out of space?
              	;
              	;   normal return location. clear error code and return.
              	;
F382: C1      	positn3:pop	bc		;restore stack.
F383: AF      		xor	a		;and clear error code byte.
F384: C304EB  		jp	setstat
              	;
              	;   error. set the 's2' byte to indicate this (why?).
              	;
F387: E5      	positn4:push	hl
F388: CD6CED  		call	gets2
F38B: 36C0    		ld	(hl),0c0h
F38D: E1      		pop	hl
              	;
              	;   return with error code (presently in l).
              	;
F38E: C1      	positn5:pop	bc
F38F: 7D      		ld	a,l		;get error code.
F390: 3248EB  		ld	(status),a
F393: C37BED  		jp	sets2b7
              	;
              	;   read a random record.
              	;
F396: 0EFF    	readran:ld	c,0ffh		;set 'read' status.
F398: CD06F3  		call	position	;position the file to proper record.
F39B: CCC4F1  		call	z,rdseq1	;and read it as usual (if no errors).
F39E: C9      		ret	
              	;
              	;   write to a random record.
              	;
F39F: 0E00    	writeran: ld	c,0		;set 'writing' flag.
F3A1: CD06F3  		call	position	;position the file to proper record.
F3A4: CC06F2  		call	z,wtseq1	;and write as usual (if no errors).
F3A7: C9      		ret	
              	;
              	;   compute the random record number. enter with (hl) pointing
              	; to a fcb an (de) contains a relative location of a record
              	; number. on exit, (c) contains the 'r0' byte, (b) the 'r1'
              	; byte, and (a) the 'r2' byte.
              	;
              	;   on return, the zero flag is set if the record is within
              	; bounds. otherwise, an overflow occured.
              	;
F3A8: EB      	comprand: ex	de,hl		;save fcb pointer in (de).
F3A9: 19      		add	hl,de		;compute relative position of record #.
F3AA: 4E      		ld	c,(hl)		;get record number into (bc).
F3AB: 0600    		ld	b,0
F3AD: 210C00  		ld	hl,12		;now get extent.
F3B0: 19      		add	hl,de
F3B1: 7E      		ld	a,(hl)		;compute (bc)=(record #)+(extent)*128.
F3B2: 0F      		rrca			;move lower bit into bit 7.
F3B3: E680    		and	80h		;and ignore all other bits.
F3B5: 81      		add	a,c		;add to our record number.
F3B6: 4F      		ld	c,a
F3B7: 3E00    		ld	a,0		;take care of any carry.
F3B9: 88      		adc	a,b
F3BA: 47      		ld	b,a
F3BB: 7E      		ld	a,(hl)		;now get the upper bits of extent into
F3BC: 0F      		rrca			;bit positions 0-3.
F3BD: E60F    		and	0fh		;and ignore all others.
F3BF: 80      		add	a,b		;add this in to 'r1' byte.
F3C0: 47      		ld	b,a
F3C1: 210E00  		ld	hl,14		;get the 's2' byte (extra extent).
F3C4: 19      		add	hl,de
F3C5: 7E      		ld	a,(hl)
F3C6: 87      		add	a,a		;and shift it left 4 bits (bits 4-7).
F3C7: 87      		add	a,a
F3C8: 87      		add	a,a
F3C9: 87      		add	a,a
F3CA: F5      		push	af		;save carry flag (bit 0 of flag byte).
F3CB: 80      		add	a,b		;now add extra extent into 'r1'.
F3CC: 47      		ld	b,a
F3CD: F5      		push	af		;and save carry (overflow byte 'r2').
F3CE: E1      		pop	hl		;bit 0 of (l) is the overflow indicator.
F3CF: 7D      		ld	a,l
F3D0: E1      		pop	hl		;and same for first carry flag.
F3D1: B5      		or	l		;either one of these set?
F3D2: E601    		and	01h		;only check the carry flags.
F3D4: C9      		ret	
              	;
              	;   routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; this reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. this is used to compute the space used
              	; by a random file.
              	;
F3D5: 0E0C    	ransize:ld	c,12		;look thru directory for first entry with
F3D7: CD1BEF  		call	findfst		;this name.
F3DA: 2A46EB  		ld	hl,(params)	;zero out the 'r0, r1, r2' bytes.
F3DD: 112100  		ld	de,33
F3E0: 19      		add	hl,de
F3E1: E5      		push	hl
F3E2: 72      		ld	(hl),d		;note that (d)=0.
F3E3: 23      		inc	hl
F3E4: 72      		ld	(hl),d
F3E5: 23      		inc	hl
F3E6: 72      		ld	(hl),d
F3E7: CDF8ED  	ransiz1:call	ckfilpos	;is there an extent to process?
F3EA: CA0FF4  		jp	z,ransiz3	;no, we are done.
F3ED: CD61ED  		call	fcb2hl		;set (hl) pointing to proper fcb in dir.
F3F0: 110F00  		ld	de,15		;point to last record in extent.
F3F3: CDA8F3  		call	comprand	;and compute random parameters.
F3F6: E1      		pop	hl
F3F7: E5      		push	hl		;now check these values against those
F3F8: 5F      		ld	e,a		;already in fcb.
F3F9: 79      		ld	a,c		;the carry flag will be set if those
F3FA: 96      		sub	(hl)		;in the fcb represent a larger size than
F3FB: 23      		inc	hl		;this extent does.
F3FC: 78      		ld	a,b
F3FD: 9E      		sbc	a,(hl)
F3FE: 23      		inc	hl
F3FF: 7B      		ld	a,e
F400: 9E      		sbc	a,(hl)
F401: DA09F4  		jp	c,ransiz2
F404: 73      		ld	(hl),e		;we found a larger (in size) extent.
F405: 2B      		dec	hl		;stuff these values into fcb.
F406: 70      		ld	(hl),b
F407: 2B      		dec	hl
F408: 71      		ld	(hl),c
F409: CD30EF  	ransiz2:call	findnxt		;now get the next extent.
F40C: C3E7F3  		jp	ransiz1		;continue til all done.
F40F: E1      	ransiz3:pop	hl		;we are done, restore the stack and
F410: C9      		ret			;return.
              	;
              	;   function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
F411: 2A46EB  	setran:	ld	hl,(params)	;point to fcb.
F414: 112000  		ld	de,32		;and to last used record.
F417: CDA8F3  		call	comprand	;compute random position.
F41A: 212100  		ld	hl,33		;now stuff these values into fcb.
F41D: 19      		add	hl,de
F41E: 71      		ld	(hl),c		;move 'r0'.
F41F: 23      		inc	hl
F420: 70      		ld	(hl),b		;and 'r1'.
F421: 23      		inc	hl
F422: 77      		ld	(hl),a		;and lastly 'r2'.
F423: C9      		ret	
              	;
              	;   this routine select the drive specified in (active) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
F424: 2AB2F5  	logindrv: ld	hl,(login)	;get the login vector.
F427: 3A45EB  		ld	a,(active)	;get the default drive.
F42A: 4F      		ld	c,a
F42B: CDEDEC  		call	shiftr		;position active bit for this drive
F42E: E5      		push	hl		;into bit 0.
F42F: EB      		ex	de,hl
F430: CD5CEB  		call	select		;select this drive.
F433: E1      		pop	hl
F434: CC4AEB  		call	z,slcterr	;valid drive?
F437: 7D      		ld	a,l		;is this a newly activated drive?
F438: 1F      		rra	
F439: D8      		ret	c
F43A: 2AB2F5  		ld	hl,(login)	;yes, update the login vector.
F43D: 4D      		ld	c,l
F43E: 44      		ld	b,h
F43F: CD0EED  		call	setbit
F442: 22B2F5  		ld	(login),hl	;and save.
F445: C3A6EE  		jp	bitmap		;now update the bitmap.
              	;
              	;   function to set the active disk number.
              	;
F448: 3AD9F5  	setdsk:	ld	a,(eparam)	;get parameter passed and see if this
F44B: 2145EB  		ld	hl,active	;represents a change in drives.
F44E: BE      		cp	(hl)
F44F: C8      		ret	z
F450: 77      		ld	(hl),a		;yes it does, log it in.
F451: C324F4  		jp	logindrv
              	;
              	;   this is the 'auto disk select' routine. the firsst byte
              	; of the fcb is examined for a drive specification. if non
              	; zero then the drive will be selected and loged in.
              	;
F454: 3EFF    	autosel:ld	a,0ffh		;say 'auto-select activated'.
F456: 32E1F5  		ld	(auto),a
F459: 2A46EB  		ld	hl,(params)	;get drive specified.
F45C: 7E      		ld	a,(hl)
F45D: E61F    		and	1fh		;look at lower 5 bits.
F45F: 3D      		dec	a		;adjust for (1=a, 2=b) etc.
F460: 32D9F5  		ld	(eparam),a	;and save for the select routine.
F463: FE1E    		cp	1eh		;check for 'no change' condition.
F465: D278F4  		jp	nc,autosl1	;yes, don't change.
F468: 3A45EB  		ld	a,(active)	;we must change, save currently active
F46B: 32E2F5  		ld	(olddrv),a	;drive.
F46E: 7E      		ld	a,(hl)		;and save first byte of fcb also.
F46F: 32E3F5  		ld	(autoflag),a	;this must be non-zero.
F472: E6E0    		and	0e0h		;whats this for (bits 6,7 are used for
F474: 77      		ld	(hl),a		;something)?
F475: CD48F4  		call	setdsk		;select and log in this drive.
F478: 3A44EB  	autosl1:ld	a,(userno)	;move user number into fcb.
F47B: 2A46EB  		ld	hl,(params)	;(* upper half of first byte *)
F47E: B6      		or	(hl)
F47F: 77      		ld	(hl),a
F480: C9      		ret			;and return (all done).
              	;
              	;   function to return the current cp/m version number.
              	;
F481: 3E22    	getver:	ld	a,022h		;version 2.2
F483: C304EB  		jp	setstat
              	;
              	;   function to reset the disk system.
              	;
F486: 210000  	rstdsk:	ld	hl,0		;clear write protect status and log
F489: 22B0F5  		ld	(wrtprt),hl	;in vector.
F48C: 22B2F5  		ld	(login),hl
F48F: AF      		xor	a		;select drive 'a'.
F490: 3245EB  		ld	(active),a
F493: 218000  		ld	hl,tbuff	;setup default dma address.
F496: 22B4F5  		ld	(userdma),hl
F499: CDDDED  		call	defdma
F49C: C324F4  		jp	logindrv	;now log in drive 'a'.
              	;
              	;   function to open a specified file.
              	;
F49F: CD75ED  	openfil:call	clears2		;clear 's2' byte.
F4A2: CD54F4  		call	autosel		;select proper disk.
F4A5: C354F0  		jp	openit		;and open the file.
              	;
              	;   function to close a specified file.
              	;
F4A8: CD54F4  	closefil: call	autosel		;select proper disk.
F4AB: C3A5F0  		jp	closeit		;and close the file.
              	;
              	;   function to return the first occurence of a specified file
              	; name. if the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
F4AE: 0E00    	getfst:	ld	c,0		;prepare for special search.
F4B0: EB      		ex	de,hl
F4B1: 7E      		ld	a,(hl)		;is first byte a '?'?
F4B2: FE3F    		cp	'?'
F4B4: CAC5F4  		jp	z,getfst1	;yes, just get very first entry (zero length match).
F4B7: CDA9EC  		call	setext		;get the extension byte from fcb.
F4BA: 7E      		ld	a,(hl)		;is it '?'? if yes, then we want
F4BB: FE3F    		cp	'?'		;an entry with a specific 's2' byte.
F4BD: C475ED  		call	nz,clears2	;otherwise, look for a zero 's2' byte.
F4C0: CD54F4  		call	autosel		;select proper drive.
F4C3: 0E0F    		ld	c,15		;compare bytes 0-14 in fcb (12&13 excluded).
F4C5: CD1BEF  	getfst1:call	findfst		;find an entry and then move it into
F4C8: C3ECED  		jp	movedir		;the users dma space.
              	;
              	;   function to return the next occurence of a file name.
              	;
F4CB: 2ADCF5  	getnxt:	ld	hl,(savefcb)	;restore pointers. note that no
F4CE: 2246EB  		ld	(params),hl	;other dbos calls are allowed.
F4D1: CD54F4  		call	autosel		;no error will be returned, but the
F4D4: CD30EF  		call	findnxt		;results will be wrong.
F4D7: C3ECED  		jp	movedir
              	;
              	;   function to delete a file by name.
              	;
F4DA: CD54F4  	delfile:call	autosel		;select proper drive.
F4DD: CD9FEF  		call	erafile		;erase the file.
F4E0: C304EF  		jp	ststatus	;set status and return.
              	;
              	;   function to execute a sequential read of the specified
              	; record number.
              	;
F4E3: CD54F4  	readseq:call	autosel		;select proper drive then read.
F4E6: C3BFF1  		jp	rdseq
              	;
              	;   function to write the net sequential record.
              	;
F4E9: CD54F4  	wrtseq:	call	autosel		;select proper drive then write.
F4EC: C301F2  		jp	wtseq
              	;
              	;   create a file function.
              	;
F4EF: CD75ED  	fcreate:call	clears2		;clear the 's2' byte on all creates.
F4F2: CD54F4  		call	autosel		;select proper drive and get the next
F4F5: C327F1  		jp	getempty	;empty directory space.
              	;
              	;   function to rename a file.
              	;
F4F8: CD54F4  	renfile:call	autosel		;select proper drive and then switch
F4FB: CD19F0  		call	chgnames	;file names.
F4FE: C304EF  		jp	ststatus
              	;
              	;   function to return the login vector.
              	;
F501: 2AB2F5  	getlog:	ld	hl,(login)
F504: C32CF5  		jp	getprm1
              	;
              	;   function to return the current disk assignment.
              	;
F507: 3A45EB  	getcrnt:ld	a,(active)
F50A: C304EB  		jp	setstat
              	;
              	;   function to set the dma address.
              	;
F50D: EB      	putdma:	ex	de,hl
F50E: 22B4F5  		ld	(userdma),hl	;save in our space and then get to
F511: C3DDED  		jp	defdma		;the bios with this also.
              	;
              	;   function to return the allocation vector.
              	;
F514: 2AC2F5  	getaloc:ld	hl,(alocvect)
F517: C32CF5  		jp	getprm1
              	;
              	;   function to return the read-only status vector.
              	;
F51A: 2AB0F5  	getrov:	ld	hl,(wrtprt)
F51D: C32CF5  		jp	getprm1
              	;
              	;   function to set the file attributes (read-only, system).
              	;
F520: CD54F4  	setattr:call	autosel		;select proper drive then save attributes.
F523: CD3EF0  		call	saveattr
F526: C304EF  		jp	ststatus
              	;
              	;   function to return the address of the disk parameter block
              	; for the current drive.
              	;
F529: 2ABEF5  	getparm:ld	hl,(diskpb)
F52C: 2248EB  	getprm1:ld	(status),hl
F52F: C9      		ret	
              	;
              	;   function to get or set the user number. if (e) was (ff)
              	; then this is a request to return the current user number.
              	; else set the user number from (e).
              	;
F530: 3AD9F5  	getuser:ld	a,(eparam)	;get parameter.
F533: FEFF    		cp	0ffh		;get user number?
F535: C23EF5  		jp	nz,setuser
F538: 3A44EB  		ld	a,(userno)	;yes, just do it.
F53B: C304EB  		jp	setstat
F53E: E61F    	setuser:and	1fh		;no, we should set it instead. keep low
F540: 3244EB  		ld	(userno),a	;bits (0-4) only.
F543: C9      		ret	
              	;
              	;   function to read a random record from a file.
              	;
F544: CD54F4  	rdrandom: call	autosel		;select proper drive and read.
F547: C396F3  		jp	readran
              	;
              	;   function to compute the file size for random files.
              	;
F54A: CD54F4  	wtrandom: call	autosel		;select proper drive and write.
F54D: C39FF3  		jp	writeran
              	;
              	;   function to compute the size of a random file.
              	;
F550: CD54F4  	filesize: call	autosel		;select proper drive and check file length
F553: C3D5F3  		jp	ransize
              	;
              	;   function #37. this allows a program to log off any drives.
              	; on entry, set (de) to contain a word with bits set for those
              	; drives that are to be logged off. the log-in vector and the
              	; write protect vector will be updated. this must be a m/pm
              	; special function.
              	;
F556: 2A46EB  	logoff:	ld	hl,(params)	;get drives to log off.
F559: 7D      		ld	a,l		;for each bit that is set, we want
F55A: 2F      		cpl			;to clear that bit in (login)
F55B: 5F      		ld	e,a		;and (wrtprt).
F55C: 7C      		ld	a,h
F55D: 2F      		cpl	
F55E: 2AB2F5  		ld	hl,(login)	;reset the login vector.
F561: A4      		and	h
F562: 57      		ld	d,a
F563: 7D      		ld	a,l
F564: A3      		and	e
F565: 5F      		ld	e,a
F566: 2AB0F5  		ld	hl,(wrtprt)
F569: EB      		ex	de,hl
F56A: 22B2F5  		ld	(login),hl	;and save.
F56D: 7D      		ld	a,l		;now do the write protect vector.
F56E: A3      		and	e
F56F: 6F      		ld	l,a
F570: 7C      		ld	a,h
F571: A2      		and	d
F572: 67      		ld	h,a
F573: 22B0F5  		ld	(wrtprt),hl	;and save. all done.
F576: C9      		ret	
              	;
              	;   get here to return to the user.
              	;
F577: 3AE1F5  	goback:	ld	a,(auto)	;was auto select activated?
F57A: B7      		or	a
F57B: CA94F5  		jp	z,goback1
F57E: 2A46EB  		ld	hl,(params)	;yes, but was a change made?
F581: 3600    		ld	(hl),0		;(* reset first byte of fcb *)
F583: 3AE3F5  		ld	a,(autoflag)
F586: B7      		or	a
F587: CA94F5  		jp	z,goback1
F58A: 77      		ld	(hl),a		;yes, reset first byte properly.
F58B: 3AE2F5  		ld	a,(olddrv)	;and get the old drive and select it.
F58E: 32D9F5  		ld	(eparam),a
F591: CD48F4  		call	setdsk
F594: 2A12EB  	goback1:ld	hl,(usrstack)	;reset the users stack pointer.
F597: F9      		ld	sp,hl
F598: 2A48EB  		ld	hl,(status)	;get return status.
F59B: 7D      		ld	a,l		;force version 1.4 compatability.
F59C: 44      		ld	b,h
F59D: C9      		ret			;and go back to user.
              	;
              	;   function #40. this is a special entry to do random i/o.
              	; for the case where we are writing to unused disk space, this
              	; space will be zeroed out first. this must be a m/pm special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
F59E: CD54F4  	wtspecl:call	autosel		;select proper drive.
F5A1: 3E02    		ld	a,2		;use special write mode.
F5A3: 32D8F5  		ld	(mode),a
F5A6: 0E00    		ld	c,0		;set write indicator.
F5A8: CD0AF3  		call	positn1		;position the file.
F5AB: CC06F2  		call	z,wtseq1	;and write (if no errors).
F5AE: C9      		ret	
              	;
              	;**************************************************************
              	;*
              	;*     bdos data storage pool.
              	;*
              	;**************************************************************
              	;
F5AF: E5      	emptyfcb: defb	0e5h		;empty directory segment indicator.
F5B0: 0000    	wrtprt:	defw	0		;write protect status for all 16 drives.
F5B2: 0000    	login:	defw	0		;drive active word (1 bit per drive).
F5B4: 8000    	userdma:defw	080h		;user's dma address (defaults to 80h).
              	;
              	;   scratch areas from parameter block.
              	;
F5B6: 0000    	scratch1: defw	0		;relative position within dir segment for file (0-3).
F5B8: 0000    	scratch2: defw	0		;last selected track number.
F5BA: 0000    	scratch3: defw	0		;last selected sector number.
              	;
              	;   disk storage areas from parameter block.
              	;
F5BC: 0000    	dirbuf:	defw	0		;address of directory buffer to use.
F5BE: 0000    	diskpb:	defw	0		;contains address of disk parameter block.
F5C0: 0000    	chkvect:defw	0		;address of check vector.
F5C2: 0000    	alocvect: defw	0		;address of allocation vector (bit map).
              	;
              	;   parameter block returned from the bios.
              	;
F5C4: 0000    	sectors:defw	0		;sectors per track from bios.
F5C6: 00      	blkshft:defb	0		;block shift.
F5C7: 00      	blkmask:defb	0		;block mask.
F5C8: 00      	extmask:defb	0		;extent mask.
F5C9: 0000    	dsksize:defw	0		;disk size from bios (number of blocks-1).
F5CB: 0000    	dirsize:defw	0		;directory size.
F5CD: 0000    	alloc0:	defw	0		;storage for first bytes of bit map (dir space used).
F5CF: 0000    	alloc1:	defw	0
F5D1: 0000    	offset:	defw	0		;first usable track number.
F5D3: 0000    	xlate:	defw	0		;sector translation table address.
              	;
              	;
F5D5: 00      	closeflg: defb	0		;close flag (=0ffh is extent written ok).
F5D6: 00      	rdwrtflg: defb	0		;read/write flag (0ffh=read, 0=write).
F5D7: 00      	fndstat:defb	0		;filename found status (0=found first entry).
F5D8: 00      	mode:	defb	0		;i/o mode select (0=random, 1=sequential, 2=special random).
F5D9: 00      	eparam:	defb	0		;storage for register (e) on entry to bdos.
F5DA: 00      	relblock: defb	0		;relative position within fcb of block number written.
F5DB: 00      	counter:defb	0		;byte counter for directory name searches.
F5DC: 00000000	savefcb:defw	0,0		;save space for address of fcb (for directory searches).
F5E0: 00      	bigdisk:defb	0		;if =0 then disk is > 256 blocks long.
F5E1: 00      	auto:	defb	0		;if non-zero, then auto select activated.
F5E2: 00      	olddrv:	defb	0		;on auto select, storage for previous drive.
F5E3: 00      	autoflag: defb	0		;if non-zero, then auto select changed drives.
F5E4: 00      	savnxt:	defb	0		;storage for next record number to access.
F5E5: 00      	savext:	defb	0		;storage for extent number of file.
F5E6: 0000    	savnrec:defw	0		;storage for number of records in file.
F5E8: 0000    	blknmbr:defw	0		;block number (physical sector) used within a file or logical sect
F5EA: 0000    	logsect:defw	0		;starting logical (128 byte) sector of block (physical sector).
F5EC: 00      	fcbpos:	defb	0		;relative position within buffer for fcb of file of interest.
F5ED: 0000    	filepos:defw	0		;files position within directory (0 to max entries -1).
              	;
              	;   disk directory buffer checksum bytes. one for each of the
              	; 16 possible drives.
              	;
F5EF: 00000000	cksumtbl: defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F5F3: 00...   	
              	;
              	;   extra space ?
              	;
F5FF: 00      		defb	0
              		
              	#include "bios.asm"
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   B O O T   R O U T I N E S
              	;*
              	;**************************************************************
              	;
              	
              	; Cold boot routine
              	; Not much special happens here, so it jumps directly to wboot
F600: C303F6  	boot:	jp	wboot
              	
              	; Warm boot routine
              	; Sends init signal to device bus, loads CCP, and inits CP/M
F603: F3      	wboot:	di
F604: 3100E0  		ld	sp,cbase
              	
              		; Send init signals to all devices
F607: 2183F6  		ld	hl,bdevsw
F60A: 0610    		ld	b,16
F60C: E5      	wboot0:	push	hl
F60D: 5E      		ld	e,(hl)
F60E: 23      		inc	hl
F60F: 56      		ld	d,(hl)
F610: 23      		inc	hl
F611: 7A      		ld	a,d
F612: B3      		or	e
F613: 2809    		jr	z,wboot1
              		; Entry not 0, try to call it
F615: 7E      		ld	a,(hl)
F616: 23      		inc	hl
F617: 6E      		ld	l,(hl)
F618: EB      		ex	de,hl
F619: C5      		push	bc
F61A: CD52F6  		call	callhl
F61D: C1      		pop	bc
              		; Move on to next entry
F61E: E1      	wboot1:	pop	hl
F61F: 110400  		ld	de,4
F622: 19      		add	hl,de
F623: 10E7    		djnz	wboot0
              		
              		; Call init for all character devices
F625: 2A7DF6  		ld	hl,(consol)
F628: CD52F6  		call	callhl
F62B: 2A7FF6  		ld	hl,(printr)
F62E: 7C      		ld	a,h
F62F: B5      		or	l
F630: C452F6  		call	nz,callhl
F633: 2A81F6  		ld	hl,(auxsio)
F636: 7C      		ld	a,h
F637: B5      		or	l
F638: C452F6  		call	nz,callhl
              		
              		; Call config init
F63B: CD55F6  		call	cfinit
              		
              		; Load the CCP
F63E: CDC3F6  		call	resccp
              		
F641: 18FE    	infloop:jr	infloop
              	
              	
              	
F643: C9      	const:	ret
F644: C9      	conin:	ret
F645: C9      	conout:	ret
F646: C9      	list:	ret
F647: C9      	punch:	ret
F648: C9      	reader:	ret
F649: C9      	home:	ret
F64A: C9      	seldsk:	ret
F64B: C9      	settrk:	ret
F64C: C9      	setsec:	ret
F64D: C9      	setdma:	ret
F64E: C9      	read:	ret
F64F: C9      	write:	ret
F650: C9      	prstat:	ret
F651: C9      	sectrn:	ret
              	
              	; Small hook to call the (HL) register
F652:         	callhl:
F652: E9      		jp	(hl)
              	#include "config.asm"
              	;
              	;**************************************************************
              	;*
              	;*          I S H K U R   S Y S T E M   C O N F I G
              	;*
              	;*      This file contains points that should be modifed
              	;*      if new devices are to be added to IshkurCP/M. At
              	;*      a mimumum, they need to be included at the bottom
              	;*      of the file, and added to their appropriate dev
              	;*      switch. Some devices may need additional config
              	;*      directly in their source files
              	;*       
              	;*
              	;**************************************************************
              	;
              	;
              	;   Set memory base here. 
              	;
0038:         	mem	equ	56		; CP/M image starts at mem*1024
              	
              	;
              	;   General cache address
              	;
FC00:         	cache	equ	0xFC00		; Start of 1k cache memory
F653: 0000    	cache_o:defw	0		; Current owner of the cache
              	
              	;
              	;**************************************************************
              	;*
              	;*        W A R M   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function is called at the end of a warm boot
              	;*    to set up hardware-specific stuff. 
              	;*
              	;**************************************************************
              	;
              	
F655: 3E00    	cfinit:	ld	a,0x00		; Bank out ROM
F657: D300    		out	(0x00),a
              		
F659: 3EC3    		ld	a,0xC3		; Set up IRQ handler
F65B: 323800  		ld	(0x38),a	
F65E: 2170F6  		ld	hl,cfirq
F661: 223900  		ld	(0x39),hl
              		
F664: 3E10    		ld	a,16		; Enable clock
F666: D341    		out	(0x41),a
F668: 3E10    		ld	a,0x10
F66A: D340    		out	(0x40),a
              		
              		
F66C: ED56    		im	1		; Start interrupts
F66E: FB      		ei
F66F: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*            I N T E R R U P T   H A N D L I N G
              	;*
              	;*     This function will be called in order to handle an
              	;*     interrupt if the need arises. Hooking drivers up to
              	;*     this code may be a little bit more involved.
              	;*
              	;**************************************************************
              	;
              	
F670: F5      	cfirq:	push	af
F671: C5      		push	bc
F672: D5      		push	de
F673: E5      		push	hl
              		
F674: CD70F7  		call	tm_ucur
              		
F677: E1      		pop	hl
F678: D1      		pop	de
F679: C1      		pop	bc
F67A: F1      		pop	af
F67B: ED4D    		reti
              	
              	
              	;
              	;**************************************************************
              	;*
              	;*        C H A R A C T E R   D E V I C E   S W I T C H
              	;*
              	;*      Currently, 3 character devices are supported. These
              	;*	devices are the console, the printer, and the "punch"
              	;*      (can be thought of as an auxillary serial device).
              	;*      All character devices use the same interface
              	;*
              	;**************************************************************
              	;
              	
              	; Device console, for user interactions with system
F67D: C9F6    	consol:	defw	tmsdev	; TMS9918 is console
              	
              	; Printer, only the init and output functions can be used
F67F: 0000    	printr:	defw	0	; nulldev
              	
              	; Auxiliary SIO, interfaces with the read/punch calls
F681: 0000    	auxsio:	defw	0	; nulldev
              	
              	;
              	;**************************************************************
              	;*
              	;*           B L O C K   D E V I C E   S W I T C H
              	;*
              	;*       IshkurCP/M can support up to 16 logical disks
              	;*       A single driver can be mapped to a number of
              	;*       these disks. Each logical disk is defined by a
              	;*       4-byte record. The first 2 bytes are a pointer
              	;*       to the device entry, and the last 2 are passed
              	;*       as an argument to the device. Usually this 
              	;*       takes the form of a minor number for indexing
              	;*       sub-disks on the same driver
              	;*
              	;*
              	;**************************************************************
              	;
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times of it has multipe entires in this table.
F683: BFF70000	bdevsw:	defw	nfddev,	0	; 'A'
F687: BFF70100		defw	nfddev,	1	; 'B'
F68B: 00000000		defw	0,	0	; 'C'
F68F: 00000000		defw	0,	0	; 'D'
F693: 00000000		defw	0,	0	; 'E'
F697: 00000000		defw	0,	0	; 'F'
F69B: 00000000		defw	0,	0	; 'G'
F69F: 00000000		defw	0,	0	; 'H'
F6A3: 00000000		defw	0,	0	; 'I'
F6A7: 00000000		defw	0,	0	; 'J'
F6AB: 00000000		defw	0,	0	; 'K'
F6AF: 00000000		defw	0,	0	; 'L'
F6B3: 00000000		defw	0,	0	; 'M'
F6B7: 00000000		defw	0,	0	; 'N'
F6BB: 00000000		defw	0,	0	; 'O'
F6BF: 00000000		defw	0,	0	; 'P'
              		
              	; One of the block devices needs to have the responsibiliy
              	; of loading the CCP into memory. Define the jump vector here
F6C3: C30BF8  	resccp:	jp	nf_ccp
              	
              	; Additionally, if Ishkur is using a graphical device, that
              	; device may temporarily need to access the Graphical Resource
              	; Block (GRB) to load in fonts and such. This is up to 2k in
              	; size, and goes in the location that the CCP resides
F6C6: C304F8  	resgrb:	jp	nf_grb
              	
              	;
              	;**************************************************************
              	;*
              	;*        D E V I C E   D R I V E R   I N C L U D E S
              	;*
              	;**************************************************************
              	;
              	#include "tms9918.asm"
              	;
              	;**************************************************************
              	;*
              	;*      T M S 9 9 1 8   C H A R A C T E R   D E V I C E
              	;*
              	;*      This device emulated a VT52 terminal using the
              	;*      TMS9918A graphics chip. The 2kb font record is
              	;*      not resident is memory, and must be provided by
              	;*      a compatable block I/O device.
              	;* 
              	;**************************************************************
              	;
              	
              	; TMS9918 Configuration
00A0:         	tm_data	equ	0xA0	; TMS9918 data register (mode=0)
00A1:         	tm_latc	equ	0xA1	; TMS9917 latch register (mode=1)
              	
              	; Driver jump table
F6C9: C3D5F6  	tmsdev:	jp	tm_init
F6CC: C323F7  		jp	tm_stat
F6CF: C324F7  		jp	tm_read
F6D2: C325F7  		jp	tm_writ
              		
              	; TMS9918 init
              	; Load font record, set up terminal
F6D5: CDC6F6  	tm_init:call	resgrb
              	
              		; Set TMS to text mode
F6D8: DBA1    		in	a,(tm_latc)
F6DA: 3E00    		ld	a,0x00
F6DC: D3A1    		out	(tm_latc),a
F6DE: 3E80    		ld	a,0x80
F6E0: D3A1    		out	(tm_latc),a
F6E2: DBA1    		in	a,(tm_latc)
F6E4: 3ED0    		ld	a,0xD0
F6E6: D3A1    		out	(tm_latc),a
F6E8: 3E81    		ld	a,0x81
F6EA: D3A1    		out	(tm_latc),a
              		
              		; Set TMS name table to 0x0800
F6EC: DBA1    		in	a,(tm_latc)
F6EE: 3E02    		ld	a,0x02
F6F0: D3A1    		out	(tm_latc),a
F6F2: 3E82    		ld	a,0x82
F6F4: D3A1    		out	(tm_latc),a
              	
              		
              		; Set TMS pattern generator block to 0
F6F6: DBA1    		in	a,(tm_latc)
F6F8: AF      		xor	a
F6F9: D3A1    		out	(tm_latc),a
F6FB: 3E84    		ld	a,0x84
F6FD: D3A1    		out	(tm_latc),a
              		
              		; Write the GRB
F6FF: 010040  		ld	bc,0x4000
F702: CDB0F7  		call	tm_addr
F705: 2100E0  		ld	hl,cbase
F708: 0EA0    		ld	c,tm_data
F70A: 3E08    		ld	a,8	; Transfer 8*256 = 2048
F70C: 0600    	tm_ini0:ld	b,0
F70E: EDB3    		otir
F710: 3D      		dec	a
F711: 20F9    		jr	nz,tm_ini0
              		
              		; Clear the terminal
F713: CD9DF7  		call	tm_cls
F716: 210000  		ld	hl,0
F719: 22B9F7  		ld	(tm_curx),hl
F71C: 22BBF7  		ld	(tm_cura),hl
F71F: 22BDF7  		ld	(tm_escs),hl
              		
F722: C9      		ret
              	
              	
F723: C9      	tm_stat:ret
              	
              	
F724: C9      	tm_read:ret
              	
              	
F725: CD29F7  	tm_writ:call	tm_wri0
F728: C9      		ret
F729:         	tm_wri0:
              	
              	; Puts a character on the screen
              	; c = X position
              	; d = Y position
              	; e = Character to put
              	;
              	; uses: af, bc, de, hl
F729: 0600    	tm_putc:ld	b,0
F72B: 79      		ld	a,c
F72C: FE28    		cp	40
F72E: 210048  		ld	hl,0x4800	; Place in buffer 0x0800
F731: DC4EF7  		call	c,tm_put0	; 0-39 frame
F734: 79      		ld	a,c
F735: FE14    		cp	20
F737: D8      		ret	c
F738: D614    		sub	20
F73A: FE28    		cp	40
F73C: 21004C  		ld	hl,0x4C00	; Place in buffer 0x0800
F73F: DC4EF7  		call	c,tm_put0	; 20-59 frame
F742: 79      		ld	a,c
F743: FE28    		cp	40
F745: D8      		ret	c
F746: D628    		sub	40
F748: 4F      		ld	c,a
F749: 210050  		ld	hl,0x5000	; Place in buffer 0x1000
F74C: 1809    		jr	tm_put2
              	
F74E: C5      	tm_put0:push	bc		
F74F: D5      		push	de
F750: 4F      		ld	c,a
F751: CD57F7  		call	tm_put2
F754: D1      		pop	de
F755: C1      		pop	bc
F756: C9      		ret
              	
F757: E5      	tm_put2:push	hl
F758: AF      	tm_put3:xor	a
F759: BA      		cp	d
F75A: 2809    		jr	z,tm_put4
F75C: 15      		dec	d
F75D: 212800  		ld	hl,40
F760: 09      		add	hl,bc
F761: 44      		ld	b,h
F762: 4D      		ld	c,l
F763: 18F3    		jr	tm_put3
F765: E1      	tm_put4:pop	hl
F766: 09      		add	hl,bc
F767: 44      		ld	b,h
F768: 4D      		ld	c,l
F769: CDB0F7  		call	tm_addr
F76C: 7B      		ld	a,e
F76D: D3A0    		out	(tm_data),a
F76F: C9      		ret
              		
              	
              	; Updates the cursor animation, assumed 60hz
              	;
              	;
F770: 3ABBF7  	tm_ucur:ld	a,(tm_cura)
F773: B7      		or	a
F774: 201C    		jr	nz,tm_ucu3
F776: 3ABCF7  		ld	a,(tm_curc)
F779: 5F      		ld	e,a
F77A: 3AB9F7  	tm_ucu0:ld	a,(tm_curx)
F77D: 4F      		ld	c,a
F77E: 3ABAF7  		ld	a,(tm_cury)
F781: 57      		ld	d,a
F782: CD29F7  		call	tm_putc
F785: 3ABBF7  		ld	a,(tm_cura)
F788: 3C      	tm_ucu1:inc	a
F789: FE3C    		cp	60
F78B: 2001    		jr	nz,tm_ucu2
F78D: AF      		xor	a
F78E: 32BBF7  	tm_ucu2:ld	(tm_cura),a
F791: C9      		ret
F792: FE1E    	tm_ucu3:cp	30
F794: 20F2    		jr	nz,tm_ucu1
F796: 3ABCF7  		ld	a,(tm_curc)
F799: EE80    		xor	0x80
F79B: 18DD    		jr	tm_ucu0
              		
              	
              	; Clears out all 3 screen buffers
              	;
              	; uses: af, bc, de
F79D: 010048  	tm_cls:	ld	bc,0x4800
F7A0: CDB0F7  		call	tm_addr
F7A3: 0EA0    		ld	c,tm_data
F7A5: 11000C  		ld	de,0x0C00
F7A8: ED71    	tm_cls0:out	(c),0
F7AA: 1B      		dec	de
F7AB: 7A      		ld	a,d
F7AC: B3      		or	e
F7AD: 20F9    		jr	nz,tm_cls0
F7AF: C9      		ret
              	
              	; Sets the TMS address for either reading or writing
              	; bc = Address 
              	;
              	; uses: af, bc
F7B0: DBA1    	tm_addr:in	a,(tm_latc)
F7B2: 79      		ld	a,c
F7B3: D3A1    		out	(tm_latc),a
F7B5: 78      		ld	a,b
F7B6: D3A1    		out	(tm_latc),a
F7B8: C9      		ret
              		
              	; Variables
F7B9: 00      	tm_curx:defb	0	; Cursor X
F7BA: 00      	tm_cury:defb	0	; Cursor Y
F7BB: 00      	tm_cura:defb	0	; Cursor animation
F7BC: 00      	tm_curc:defb	0	; Cursor character
F7BD: 00      	tm_escs:defb	0	; Escape state
F7BE: 00      	tm_aaaa:defb	0	; Not defined yet
              	#include "nabu1797.asm"
              	;
              	;**************************************************************
              	;*
              	;*      N A B U   F D 1 7 9 7   F L O P P Y   D R I V E R
              	;*
              	;*      This driver interfaces the NABU FDC for use as a
              	;*      CP/M file system, graphical source, and boot device.
              	;*      The driver only supports double-density disks of 
              	;*      Osborne 1 format at the time, but this could be
              	;*      updated if it is needed. The directory table starts
              	;*      on track 2, the system sectors are as follows:
              	;*
              	;*      Track 0 Sector 1:	Boot Sector
              	;*      Track 0 Sector 2-3:	Graphical Resource Block
              	;*	Track 0 Sector 4-5:	CCP
              	;*	Track 1 Sector 1-5:	BDOS + BIOS Image
              	;* 
              	;**************************************************************
              	;
F7BF: C3D4F7  	nfddev:	jp	nf_init	
F7C2: C34FF8  		jp	nf_sel
F7C5: C350F8  		jp	nf_strk
F7C8: C351F8  		jp	nf_ssec
F7CB: C352F8  		jp	nf_sdma
F7CE: C353F8  		jp	nf_read
F7D1: C354F8  		jp	nf_writ
              		
              	; Initialize device
F7D4: AF      	nf_init:xor	a
F7D5: 328EF8  		ld	(nf_io),a
              	
              		; Look for the FDC
F7D8: 0ECF    		ld	c,0xCF
F7DA: ED78    	nf_ini1:in	a,(c)
F7DC: FE10    		cp	0x10
F7DE: 2808    		jr	z,nf_ini2
F7E0: 0C      		inc	c
F7E1: C8      		ret	z	; Should not be possible!
F7E2: 3E0F    		ld	a,0x0F
F7E4: 81      		add	a,c
F7E5: 4F      		ld	c,a
F7E6: 18F2    		jr	nf_ini1
              		
              		; Get command register
F7E8: 79      	nf_ini2:ld	a,c
F7E9: D60F    		sub	15
F7EB: 4F      		ld	c,a
F7EC: 328EF8  		ld	(nf_io),a
              		
              		; Select drive A
F7EF: 3E02    		ld	a,2
F7F1: CD71F8  		call	nf_dvsl
              		
              		; Force FDC interrupt
F7F4: 3ED0    		ld	a,0xD0
F7F6: ED79    		out	(c),a
              		
              		; Restore to track 0
F7F8: 3E09    		ld	a,0x09
F7FA: ED79    		out	(c),a 
F7FC: CD83F8  		call	nf_busy
              		
              		; Disable device
F7FF: AF      		xor	a
F800: CD71F8  		call	nf_dvsl
F803: C9      		ret
              		
              	; Loads the GRB into memory from sector 2-3
F804: 3E02    	nf_grb:	ld	a,2
F806: 328FF8  		ld	(nf_2ksc),a
F809: 1805    		jr	nf_r2k
              		
              	; Loads the CCP into memory from sectors 4-5
F80B: 3E04    	nf_ccp:	ld	a,4
F80D: 328FF8  		ld	(nf_2ksc),a
              	
              	; Reads in a 2K bytes, starting at track 0, sector (nf_2ksc)
              	; This is placed into the cbase
F810: 3E02    	nf_r2k: ld	a,2
F812: CD71F8  		call	nf_dvsl
              		
              		; Restore to track 0
F815: 3A8EF8  		ld	a,(nf_io)
F818: 4F      		ld	c,a
F819: 3E09    		ld	a,0x09
F81B: ED79    		out	(c),a 
F81D: CD83F8  		call	nf_busy
              		
              		; Set sector # to 4
F820: 3A8FF8  		ld	a,(nf_2ksc)
F823: 0C      		inc	c
F824: 0C      		inc	c
F825: ED79    		out	(c),a
F827: C5      		push	bc
F828: 0D      		dec	c
F829: 0D      		dec	c
              		
              		; Read into memory
F82A: 2100E0  		ld	hl,cbase
F82D: CD55F8  		call	nf_rphy
F830: C1      		pop	bc
F831: B7      		or	a
F832: 2805    		jr	z,nf_r2k0
F834: CDD4F7  		call	nf_init		; Error!
F837: 18D7    		jr	nf_r2k
              		
              		; Increment sector
F839: ED78    	nf_r2k0:in	a,(c)
F83B: 3C      		inc	a
F83C: ED79    		out	(c),a
F83E: 0D      		dec	c
F83F: 0D      		dec	c
              		
              		; Read into memory again
F840: CD55F8  		call	nf_rphy
F843: B7      		or	a
F844: C8      		ret	z
F845: CDD4F7  		call	nf_init		; Error!
F848: 18C6    		jr	nf_r2k
              		
              		; De-select drive
F84A: 3E00    	nf_r2k1:ld	a,0
F84C: C371F8  		jp	nf_dvsl
              	
F84F: C9      	nf_sel:	ret
F850: C9      	nf_strk:ret
F851: C9      	nf_ssec:ret
F852: C9      	nf_sdma:ret
F853: C9      	nf_read:ret
F854: C9      	nf_writ:ret
              	
              	; Reads a physical sector
              	; Track and sector should be set up
              	; c = FDC command address
              	; hl = memory location of result
              	;
              	; Returns a=0 if successful
              	; uses: af, bc, de, hl
F855: 51      	nf_rphy:ld	d,c
F856: 59      		ld	e,c
F857: 14      		inc	d
F858: 14      		inc	d
F859: 14      		inc	d
              		
              		; Read command
F85A: 3E88    		ld	a,0x88
F85C: ED79    		out	(c),a
F85E: ED78    	nf_rph1:in	a,(c)
F860: 1F      		rra	
F861: 3009    		jr	nc,nf_rph2
F863: 1F      		rra
F864: 30F8    		jr	nc,nf_rph1
F866: 4A      		ld	c,d
F867: EDA2    		ini
F869: 4B      		ld	c,e
F86A: 18F2    		jr	nf_rph1
F86C: ED78    	nf_rph2:in	a,(c)
F86E: E6FC    		and	0xFC
F870: C9      		ret
              	
              	; Selects or deselects a drive
              	; a = Drive density / selection
              	;
              	; uses: af
F871: C5      	nf_dvsl:push	bc
F872: 47      		ld	b,a
F873: 3A8EF8  		ld	a,(nf_io)
F876: C60F    		add	a,0x0F
F878: 4F      		ld	c,a
F879: 78      		ld	a,b
F87A: ED79    		out	(c),a
F87C: 06FF    		ld	b,0xFF
F87E: CD89F8  		call	nf_stal
F881: C1      		pop	bc
F882: C9      		ret
              		
              	
              	; Waits until FDC is not busy
              	; c = FDC command address
              	;
              	; uses: af
F883: ED78    	nf_busy:in	a,(c)
F885: 1F      		rra
F886: 38FB    		jr	c,nf_busy
F888: C9      		ret
              		
              	; Waits a little bit
              	;
              	; uses: b
F889: C5      	nf_stal:push	bc
F88A: C1      		pop	bc
F88B: 10FC    		djnz	nf_stal
F88D: C9      		ret
              	
              	
              	; Variables
F88E: 00      	nf_io:	defb	0	; FDC address
F88F: 00      	nf_2ksc:defb	0	; Start of 2K block to load in
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	


; +++ segments +++

#CODE          = $E000 = 57344,  size = $1890 =  6288

; +++ global symbols +++

_end     = $F890 = 63632          cpm22.asm:40 (unused)
_size    = $1890 =  6288          cpm22.asm:40 (unused)
active   = $EB45 = 60229          cpm22.asm:1698
adda2hl  = $ED67 = 60775          cpm22.asm:2127
addhl    = $E259 = 57945          cpm22.asm:429
alloc0   = $F5CD = 62925          cpm22.asm:3675
alloc1   = $F5CF = 62927          cpm22.asm:3676
alocvect = $F5C2 = 62914          cpm22.asm:3665
auto     = $F5E1 = 62945          cpm22.asm:3690
autoflag = $F5E3 = 62947          cpm22.asm:3692
autosel  = $F454 = 62548          cpm22.asm:3405
autosl1  = $F478 = 62584          cpm22.asm:3421
auxsio   = $F681 = 63105          config.asm:102
backup   = $E9A7 = 59815          cpm22.asm:1458
backup1  = $E9AF = 59823          cpm22.asm:1461
badload  = $E77A = 59258          cpm22.asm:1188
badsctr  = $E80C = 59404          cpm22.asm:1242
badsec   = $E8CD = 59597          cpm22.asm:1313
badsel   = $E8D8 = 59608          cpm22.asm:1314
badslct  = $E80E = 59406          cpm22.asm:1243
batch    = $E7AB = 59307          cpm22.asm:1211
batchfcb = $E7AC = 59308          cpm22.asm:1212
bdevsw   = $F683 = 63107          config.asm:125
bdosdrv  = $E8C9 = 59593          cpm22.asm:1312
bdoserr  = $E8BD = 59581          cpm22.asm:1311
bigdisk  = $F5E0 = 62944          cpm22.asm:3689
bitmap   = $EEA6 = 61094          cpm22.asm:2420
bitmap1  = $EEB4 = 61108          cpm22.asm:2435
bitmap2  = $EED5 = 61141          cpm22.asm:2456
bitmap3  = $EEF9 = 61177          cpm22.asm:2473
blkmask  = $F5C7 = 62919          cpm22.asm:3671
blknmbr  = $F5E8 = 62952          cpm22.asm:3696
blkshft  = $F5C6 = 62918          cpm22.asm:3670
boot     = $F600 = 62976          bios.asm:11
bs       = $0008 =     8          cpm22.asm:25
cache    = $FC00 = 64512          config.asm:24 (unused)
cache_o  = $F653 = 63059          config.asm:25 (unused)
callhl   = $F652 = 63058          bios.asm:82
cbase    = $E000 = 57344          cpm22.asm:42
ccpstack = $E7AB = 59307          cpm22.asm:1207
cdrive   = $E7EF = 59375          cpm22.asm:1218
cfinit   = $F655 = 63061          config.asm:38
cfirq    = $F670 = 63088          config.asm:68
charbuf  = $EB11 = 60177          cpm22.asm:1687
check    = $E230 = 57904          cpm22.asm:395
checkdir = $EDA1 = 60833          cpm22.asm:2200
checksum = $ECFA = 60666          cpm22.asm:2039
chgdrv   = $E7F0 = 59376          cpm22.asm:1219
chgnam1  = $F02A = 61482          cpm22.asm:2712
chgnames = $F019 = 61465          cpm22.asm:2704
chkblk   = $EC87 = 60551          cpm22.asm:1946
chkchar  = $E917 = 59671          cpm22.asm:1355
chkcon   = $E1C2 = 57794          cpm22.asm:320
chkdir1  = $EDC7 = 60871          cpm22.asm:2220
chknmbr  = $ED8F = 60815          cpm22.asm:2173
chkrofl  = $ED47 = 60743          cpm22.asm:2103
chksum1  = $ED00 = 60672          cpm22.asm:2042
chkvect  = $F5C0 = 62912          cpm22.asm:3664
chkwprt  = $ED57 = 60759          cpm22.asm:2114
ckbitmap = $EE38 = 60984          cpm22.asm:2314
ckbmap1  = $EE59 = 61017          cpm22.asm:2349
ckcon1   = $E945 = 59717          cpm22.asm:1385
ckcon2   = $E948 = 59720          cpm22.asm:1386
ckconsol = $E926 = 59686          cpm22.asm:1371
ckfilpos = $EDF8 = 60920          cpm22.asm:2263
ckrof1   = $ED4A = 60746          cpm22.asm:2104
cksumtbl = $F5EF = 62959          cpm22.asm:3704
clearbuf = $E358 = 58200          cpm22.asm:595
clears2  = $ED75 = 60789          cpm22.asm:2144
close    = $E0DA = 57562          cpm22.asm:135
closefil = $F4A8 = 62632          cpm22.asm:3452
closeflg = $F5D5 = 62933          cpm22.asm:3681
closeit  = $F0A5 = 61605          cpm22.asm:2798
closeit1 = $F0D0 = 61648          cpm22.asm:2818
closeit2 = $F0DE = 61662          cpm22.asm:2826
closeit3 = $F0E4 = 61668          cpm22.asm:2830
closeit4 = $F0EB = 61675          cpm22.asm:2833
closeit5 = $F100 = 61696          cpm22.asm:2846
closeit6 = $F11A = 61722          cpm22.asm:2864
closeit7 = $F122 = 61730          cpm22.asm:2867
cmdadr   = $E3C1 = 58305          cpm22.asm:667
cmdtbl   = $E310 = 58128          cpm22.asm:549
cmmnd1   = $E382 = 58242          cpm22.asm:628
cmmnd2   = $E398 = 58264          cpm22.asm:639
cntrlc   = $0003 =     3          cpm22.asm:23
cntrle   = $0005 =     5          cpm22.asm:24
cntrlp   = $0010 =    16          cpm22.asm:30
cntrlr   = $0012 =    18          cpm22.asm:31
cntrls   = $0013 =    19          cpm22.asm:32
cntrlu   = $0015 =    21          cpm22.asm:33
cntrlx   = $0018 =    24          cpm22.asm:34
cntrlz   = $001A =    26          cpm22.asm:35
comblk   = $EC7A = 60538          cpm22.asm:1937
comfile  = $E783 = 59267          cpm22.asm:1189
command  = $E35C = 58204          cpm22.asm:605
comprand = $F3A8 = 62376          cpm22.asm:3271
conin    = $F644 = 63044          bios.asm:66
conout   = $F645 = 63045          bios.asm:67
consol   = $F67D = 63101          config.asm:96
const    = $F643 = 63043          bios.asm:65
convert  = $E260 = 57952          cpm22.asm:443
convfst  = $E25E = 57950          cpm22.asm:437
convrt1  = $E289 = 57993          cpm22.asm:466
convrt2  = $E290 = 58000          cpm22.asm:469
convrt3  = $E296 = 58006          cpm22.asm:476
convrt4  = $E298 = 58008          cpm22.asm:477
convrt5  = $E2A9 = 58025          cpm22.asm:484
convrt6  = $E2AB = 58027          cpm22.asm:486
convrt7  = $E2AF = 58031          cpm22.asm:488
convrt8  = $E2B9 = 58041          cpm22.asm:492
counter  = $F5DB = 62939          cpm22.asm:3687
cr       = $000D =    13          cpm22.asm:29
create   = $E109 = 57609          cpm22.asm:185
crlf     = $E098 = 57496          cpm22.asm:77
curpos   = $EB0F = 60175          cpm22.asm:1685
de2hl    = $EB52 = 60242          cpm22.asm:1716
de2hl1   = $EB53 = 60243          cpm22.asm:1717
decode   = $E3F8 = 58360          cpm22.asm:694
decode1  = $E408 = 58376          cpm22.asm:700
decode2  = $E42A = 58410          cpm22.asm:720 (unused)
decode3  = $E433 = 58419          cpm22.asm:725
decode4  = $E43A = 58426          cpm22.asm:729 (unused)
defdma   = $EDDD = 60893          cpm22.asm:2238
del      = $007F =   127          cpm22.asm:36
delbatch = $E1DD = 57821          cpm22.asm:345
delete   = $E0EF = 57583          cpm22.asm:156
delfile  = $F4DA = 62682          cpm22.asm:3483
dirbuf   = $F5BC = 62908          cpm22.asm:3662
dirc1    = $EAE3 = 60131          cpm22.asm:1643
dircio   = $EAD7 = 60119          cpm22.asm:1637
dirdma   = $EDE3 = 60899          cpm22.asm:2243
dirdma1  = $EDE6 = 60902          cpm22.asm:2248
direct   = $E477 = 58487          cpm22.asm:791
direct1  = $E488 = 58504          cpm22.asm:798
direct2  = $E48F = 58511          cpm22.asm:802
direct3  = $E498 = 58520          cpm22.asm:806
direct4  = $E4CC = 58572          cpm22.asm:833
direct5  = $E4D4 = 58580          cpm22.asm:836
direct6  = $E4D9 = 58585          cpm22.asm:838
direct7  = $E50E = 58638          cpm22.asm:862
direct8  = $E50F = 58639          cpm22.asm:863
direct9  = $E51B = 58651          cpm22.asm:867
dirread  = $EDD7 = 60887          cpm22.asm:2233
dirsize  = $F5CB = 62923          cpm22.asm:3674
dirwrite = $EDC9 = 60873          cpm22.asm:2225
diskpb   = $F5BE = 62910          cpm22.asm:3663
diskro   = $E8E4 = 59620          cpm22.asm:1316
dmaset   = $E1D8 = 57816          cpm22.asm:340
doread   = $EBB5 = 60341          cpm22.asm:1787
dowrite  = $EBBB = 60347          cpm22.asm:1792
drect63  = $E4F7 = 58615          cpm22.asm:852
drect65  = $E4F9 = 58617          cpm22.asm:853
dselect  = $E454 = 58452          cpm22.asm:761
dsksel   = $E0BD = 57533          cpm22.asm:109
dsksize  = $F5C9 = 62921          cpm22.asm:3673
emptyfcb = $F5AF = 62895          cpm22.asm:3649
entry    = $0005 =     5          cpm22.asm:16
entry1   = $E0C3 = 57539          cpm22.asm:116
entry2   = $E0F4 = 57588          cpm22.asm:162
eparam   = $F5D9 = 62937          cpm22.asm:3685
erafil1  = $EFA7 = 61351          cpm22.asm:2590
erafile  = $EF9F = 61343          cpm22.asm:2587
erase    = $E51F = 58655          cpm22.asm:876
erase1   = $E542 = 58690          cpm22.asm:891
error1   = $E89C = 59548          cpm22.asm:1294
error2   = $E8A8 = 59560          cpm22.asm:1300
error3   = $E8AE = 59566          cpm22.asm:1303
error4   = $E8B4 = 59572          cpm22.asm:1306
error5   = $E8B7 = 59575          cpm22.asm:1308
exists   = $E682 = 59010          cpm22.asm:1053
extblk   = $EC61 = 60513          cpm22.asm:1918
extblk1  = $EC74 = 60532          cpm22.asm:1928
extmask  = $F5C8 = 62920          cpm22.asm:3672
extract  = $E44B = 58443          cpm22.asm:751
fbase    = $E806 = 59398          cpm22.asm:1237 (unused)
fbase1   = $E814 = 59412          cpm22.asm:1250
fcb      = $E7CD = 59341          cpm22.asm:1216
fcb2hl   = $ED61 = 60769          cpm22.asm:2122
fcbpos   = $F5EC = 62956          cpm22.asm:3698
fcbset   = $F000 = 61440          cpm22.asm:2682
fcreate  = $F4EF = 62703          cpm22.asm:3500
ff       = $000C =    12          cpm22.asm:28 (unused)
filepos  = $F5ED = 62957          cpm22.asm:3699
filero   = $E8DF = 59615          cpm22.asm:1315
filesize = $F550 = 62800          cpm22.asm:3574
findfst  = $EF1B = 61211          cpm22.asm:2507
findnxt  = $EF30 = 61232          cpm22.asm:2520
fndnxt1  = $EF4D = 61261          cpm22.asm:2533
fndnxt2  = $EF56 = 61270          cpm22.asm:2537
fndnxt3  = $EF76 = 61302          cpm22.asm:2553
fndnxt4  = $EF7F = 61311          cpm22.asm:2562
fndnxt5  = $EF86 = 61318          cpm22.asm:2567
fndnxt6  = $EF97 = 61335          cpm22.asm:2580
fndspa1  = $EFC3 = 61379          cpm22.asm:2620
fndspa2  = $EFD4 = 61396          cpm22.asm:2643
fndspa3  = $EFEF = 61423          cpm22.asm:2664
fndspa4  = $EFF7 = 61431          cpm22.asm:2674
fndspace = $EFC1 = 61377          cpm22.asm:2614
fndstat  = $F5D7 = 62935          cpm22.asm:3683
functns  = $E84A = 59466          cpm22.asm:1285
getaloc  = $F514 = 62740          cpm22.asm:3528
getback  = $E786 = 59270          cpm22.asm:1195
getback1 = $E789 = 59273          cpm22.asm:1196
getblk1  = $EC48 = 60488          cpm22.asm:1896
getblk2  = $EC56 = 60502          cpm22.asm:1905
getblk3  = $EC5F = 60511          cpm22.asm:1910
getblock = $EC41 = 60481          cpm22.asm:1893
getchar  = $E8FE = 59646          cpm22.asm:1333
getcon   = $EACB = 60107          cpm22.asm:1625
getcrnt  = $F507 = 62727          cpm22.asm:3517
getcsts  = $EB01 = 60161          cpm22.asm:1670
getdsk   = $E1D0 = 57808          cpm22.asm:331
getecho  = $E909 = 59657          cpm22.asm:1342
getempty = $F127 = 61735          cpm22.asm:2874
getext   = $E2C0 = 58048          cpm22.asm:499
getext1  = $E2C8 = 58056          cpm22.asm:503
getext2  = $E2D9 = 58073          cpm22.asm:510
getext3  = $E2DB = 58075          cpm22.asm:512
getext4  = $E2DF = 58079          cpm22.asm:514
getext5  = $E2E9 = 58089          cpm22.asm:518
getext6  = $E2F0 = 58096          cpm22.asm:522
getext7  = $E2F2 = 58098          cpm22.asm:523
getext8  = $E301 = 58113          cpm22.asm:535
getext9  = $E309 = 58121          cpm22.asm:540
getfst   = $F4AE = 62638          cpm22.asm:3459
getfst1  = $F4C5 = 62661          cpm22.asm:3470
getinp   = $E139 = 57657          cpm22.asm:236
getinp1  = $E196 = 57750          cpm22.asm:292
getinp2  = $E1A7 = 57767          cpm22.asm:301
getinp3  = $E1AB = 57771          cpm22.asm:303
getinp4  = $E1BA = 57786          cpm22.asm:312
getiob   = $EAF0 = 60144          cpm22.asm:1651
getlog   = $F501 = 62721          cpm22.asm:3512
getmt1   = $F149 = 61769          cpm22.asm:2890
getnext  = $F15D = 61789          cpm22.asm:2904
getnxt   = $F4CB = 62667          cpm22.asm:3475
getparm  = $F529 = 62761          cpm22.asm:3545
getprm1  = $F52C = 62764          cpm22.asm:3546
getrdr   = $EAD1 = 60113          cpm22.asm:1630
getrov   = $F51A = 62746          cpm22.asm:3533
gets2    = $ED6C = 60780          cpm22.asm:2136
getsetuc = $E115 = 57621          cpm22.asm:201
getuser  = $F530 = 62768          cpm22.asm:3553
getusr   = $E113 = 57619          cpm22.asm:196
getver   = $F481 = 62593          cpm22.asm:3429
getwprt  = $ED21 = 60705          cpm22.asm:2076
goback   = $F577 = 62839          cpm22.asm:3609
goback1  = $F594 = 62868          cpm22.asm:3621
gtnext1  = $F186 = 61830          cpm22.asm:2924
gtnext2  = $F191 = 61841          cpm22.asm:2933
gtnext3  = $F1AF = 61871          cpm22.asm:2944
gtnext4  = $F1B2 = 61874          cpm22.asm:2945
gtnext5  = $F1B9 = 61881          cpm22.asm:2952
halt     = $E3CF = 58319          cpm22.asm:672
hl2de    = $E442 = 58434          cpm22.asm:741
home     = $F649 = 63049          bios.asm:71
homedrv  = $EBA4 = 60324          cpm22.asm:1773
inbuff   = $E006 = 57350          cpm22.asm:49
infloop  = $F641 = 63041          bios.asm:61
inpoint  = $E088 = 57480          cpm22.asm:57
iobyte   = $0003 =     3          cpm22.asm:14
ioerr1   = $EB08 = 60168          cpm22.asm:1680
ioret    = $EBBE = 60350          cpm22.asm:1793
jumphl   = $EB4D = 60237          cpm22.asm:1708
lf       = $000A =    10          cpm22.asm:27
list     = $F646 = 63046          bios.asm:68
logical  = $EC8D = 60557          cpm22.asm:1957
logicl1  = $EC93 = 60563          cpm22.asm:1959
login    = $F5B2 = 62898          cpm22.asm:3651
logindrv = $F424 = 62500          cpm22.asm:3373
logoff   = $F556 = 62806          cpm22.asm:3583
logsect  = $F5EA = 62954          cpm22.asm:3697
mem      = $0038 =    56          config.asm:19
mode     = $F5D8 = 62936          cpm22.asm:3684
morefls  = $ED82 = 60802          cpm22.asm:2160
move3    = $E440 = 58432          cpm22.asm:737
movecd   = $E129 = 57641          cpm22.asm:218
movedir  = $EDEC = 60908          cpm22.asm:2255
moveword = $F097 = 61591          cpm22.asm:2781
namepnt  = $E08A = 57482          cpm22.asm:58
nbytes   = $E7F1 = 59377          cpm22.asm:1220
newline  = $E9B4 = 59828          cpm22.asm:1467
newln1   = $E9BC = 59836          cpm22.asm:1470
nf_2ksc  = $F88F = 63631          nabu1797.asm:198
nf_busy  = $F883 = 63619          nabu1797.asm:182
nf_ccp   = $F80B = 63499          nabu1797.asm:74
nf_dvsl  = $F871 = 63601          nabu1797.asm:165
nf_grb   = $F804 = 63492          nabu1797.asm:69
nf_ini1  = $F7DA = 63450          nabu1797.asm:34
nf_ini2  = $F7E8 = 63464          nabu1797.asm:45
nf_init  = $F7D4 = 63444          nabu1797.asm:29
nf_io    = $F88E = 63630          nabu1797.asm:197
nf_r2k   = $F810 = 63504          nabu1797.asm:79
nf_r2k0  = $F839 = 63545          nabu1797.asm:108
nf_r2k1  = $F84A = 63562          nabu1797.asm:122 (unused)
nf_read  = $F853 = 63571          nabu1797.asm:129
nf_rph1  = $F85E = 63582          nabu1797.asm:148
nf_rph2  = $F86C = 63596          nabu1797.asm:157
nf_rphy  = $F855 = 63573          nabu1797.asm:139
nf_sdma  = $F852 = 63570          nabu1797.asm:128
nf_sel   = $F84F = 63567          nabu1797.asm:125
nf_ssec  = $F851 = 63569          nabu1797.asm:127
nf_stal  = $F889 = 63625          nabu1797.asm:190
nf_strk  = $F850 = 63568          nabu1797.asm:126
nf_writ  = $F854 = 63572          nabu1797.asm:130
nfddev   = $F7BF = 63423          nabu1797.asm:20
nfuncts  = $0029 =    41          cpm22.asm:1283
nofile   = $E3F0 = 58352          cpm22.asm:687
nonblank = $E24F = 57935          cpm22.asm:419
none     = $E3EA = 58346          cpm22.asm:685
nospace  = $E607 = 58887          cpm22.asm:995
numcmds  = $0006 =     6          cpm22.asm:548
nxent1   = $EE1C = 60956          cpm22.asm:2293
nxent2   = $EE23 = 60963          cpm22.asm:2296
nxentry  = $EE08 = 60936          cpm22.asm:2285
offset   = $F5D1 = 62929          cpm22.asm:3677
olddrv   = $F5E2 = 62946          cpm22.asm:3691
open     = $E0CB = 57547          cpm22.asm:123
openfcb  = $E0D0 = 57552          cpm22.asm:128
openfil  = $F49F = 62623          cpm22.asm:3446
openit   = $F054 = 61524          cpm22.asm:2738
openit1  = $F05D = 61533          cpm22.asm:2742
openit2  = $F08E = 61582          cpm22.asm:2770
outchar  = $E94B = 59723          cpm22.asm:1393
outchr1  = $E965 = 59749          cpm22.asm:1407
outchr2  = $E97C = 59772          cpm22.asm:1423
outcon   = $E993 = 59795          cpm22.asm:1444
outcon1  = $E999 = 59801          cpm22.asm:1447
outcrlf  = $E9CC = 59852          cpm22.asm:1480
outflag  = $EB0D = 60173          cpm22.asm:1683
params   = $EB46 = 60230          cpm22.asm:1699
pattrn1  = $E328 = 58152          cpm22.asm:559
pattrn2  = $E800 = 59392          cpm22.asm:1229
pline    = $E0A7 = 57511          cpm22.asm:90
pline2   = $E0AC = 57516          cpm22.asm:93
position = $F306 = 62214          cpm22.asm:3148
positn1  = $F30A = 62218          cpm22.asm:3153
positn2  = $F34A = 62282          cpm22.asm:3199
positn3  = $F382 = 62338          cpm22.asm:3231
positn4  = $F387 = 62343          cpm22.asm:3237
positn5  = $F38E = 62350          cpm22.asm:3244
print    = $E08C = 57484          cpm22.asm:63
printb   = $E092 = 57490          cpm22.asm:69
printr   = $F67F = 63103          config.asm:99
prstat   = $F650 = 63056          bios.asm:78 (unused)
prterr   = $E8E8 = 59624          cpm22.asm:1320
prtflag  = $EB10 = 60176          cpm22.asm:1686
prtmesg  = $E9D6 = 59862          cpm22.asm:1487
prtstr   = $EAFB = 60155          cpm22.asm:1663
punch    = $F647 = 63047          bios.asm:69
putdma   = $F50D = 62733          cpm22.asm:3522
ransiz1  = $F3E7 = 62439          cpm22.asm:3327
ransiz2  = $F409 = 62473          cpm22.asm:3349
ransiz3  = $F40F = 62479          cpm22.asm:3351
ransize  = $F3D5 = 62421          cpm22.asm:3316
rdbuf1   = $E9F2 = 59890          cpm22.asm:1506
rdbuf10  = $EA73 = 60019          cpm22.asm:1568
rdbuf11  = $EA7B = 60027          cpm22.asm:1574
rdbuf12  = $EA8D = 60045          cpm22.asm:1586
rdbuf13  = $EA9C = 60060          cpm22.asm:1593
rdbuf14  = $EAA9 = 60073          cpm22.asm:1601
rdbuf15  = $EAAC = 60076          cpm22.asm:1604
rdbuf16  = $EAC0 = 60096          cpm22.asm:1616
rdbuf17  = $EAC4 = 60100          cpm22.asm:1618
rdbuf2   = $E9F4 = 59892          cpm22.asm:1508
rdbuf3   = $EA19 = 59929          cpm22.asm:1525
rdbuf4   = $EA29 = 59945          cpm22.asm:1534
rdbuf5   = $EA3A = 59962          cpm22.asm:1542
rdbuf6   = $EA4B = 59979          cpm22.asm:1551
rdbuf7   = $EA51 = 59985          cpm22.asm:1554
rdbuf8   = $EA62 = 60002          cpm22.asm:1561
rdbuf9   = $EA6E = 60014          cpm22.asm:1566
rdbuff   = $E9E4 = 59876          cpm22.asm:1499
rderr    = $E3DF = 58335          cpm22.asm:681
rderror  = $E3D9 = 58329          cpm22.asm:679
rdrandom = $F544 = 62788          cpm22.asm:3564
rdrec    = $E0F9 = 57593          cpm22.asm:169
rdseq    = $F1BF = 61887          cpm22.asm:2957
rdseq1   = $F1C4 = 61892          cpm22.asm:2959
rdseq2   = $F1E9 = 61929          cpm22.asm:2974
rdseq3   = $F1FE = 61950          cpm22.asm:2984
rdwrtflg = $F5D6 = 62934          cpm22.asm:3682
read     = $F64E = 63054          bios.asm:76
reader   = $F648 = 63048          bios.asm:70
readfcb  = $E0FE = 57598          cpm22.asm:174
readran  = $F396 = 62358          cpm22.asm:3251
readseq  = $F4E3 = 62691          cpm22.asm:3490
relblock = $F5DA = 62938          cpm22.asm:3686
renam    = $E10E = 57614          cpm22.asm:191
rename   = $E610 = 58896          cpm22.asm:1003
rename1  = $E63F = 58943          cpm22.asm:1021
rename2  = $E659 = 58969          cpm22.asm:1035
rename3  = $E65E = 58974          cpm22.asm:1038 (unused)
rename4  = $E66D = 58989          cpm22.asm:1046
rename5  = $E673 = 58995          cpm22.asm:1048
rename6  = $E679 = 59001          cpm22.asm:1050
renfile  = $F4F8 = 62712          cpm22.asm:3506
resccp   = $F6C3 = 63171          config.asm:144
resdsk   = $E0B8 = 57528          cpm22.asm:104
resetdr  = $E466 = 58470          cpm22.asm:775
resgrb   = $F6C6 = 63174          config.asm:150
rodisk   = $E810 = 59408          cpm22.asm:1244
rofile   = $E812 = 59410          cpm22.asm:1245
rstdsk   = $F486 = 62598          cpm22.asm:3434
rtn      = $EB07 = 60167          cpm22.asm:1676
rtncode  = $E7EE = 59374          cpm22.asm:1217
samext   = $EF0A = 61194          cpm22.asm:2488
savatr1  = $F043 = 61507          cpm22.asm:2728
save     = $E5AD = 58797          cpm22.asm:948
save1    = $E5D4 = 58836          cpm22.asm:966
save2    = $E5F1 = 58865          cpm22.asm:984
save3    = $E5FB = 58875          cpm22.asm:991
save4    = $E601 = 58881          cpm22.asm:993
saveattr = $F03E = 61502          cpm22.asm:2726
savefcb  = $F5DC = 62940          cpm22.asm:3688
savext   = $F5E5 = 62949          cpm22.asm:3694
savnrec  = $F5E6 = 62950          cpm22.asm:3695
savnxt   = $F5E4 = 62948          cpm22.asm:3693
scratch1 = $F5B6 = 62902          cpm22.asm:3656
scratch2 = $F5B8 = 62904          cpm22.asm:3657
scratch3 = $F5BA = 62906          cpm22.asm:3658
search   = $E32E = 58158          cpm22.asm:567
search1  = $E333 = 58163          cpm22.asm:569
search2  = $E33C = 58172          cpm22.asm:574
search3  = $E34F = 58191          cpm22.asm:586
search4  = $E354 = 58196          cpm22.asm:589
sectors  = $F5C4 = 62916          cpm22.asm:3669
sectrn   = $F651 = 63057          bios.asm:79
seldsk   = $F64A = 63050          bios.asm:72
select   = $EB5C = 60252          cpm22.asm:1727
select1  = $EBA0 = 60320          cpm22.asm:1767
setattr  = $F520 = 62752          cpm22.asm:3538
setbit   = $ED0E = 60686          cpm22.asm:2059
setcdrv  = $E11A = 57626          cpm22.asm:206
setdir   = $ED9F = 60831          cpm22.asm:2193
setdma   = $F64D = 63053          bios.asm:75
setdsk   = $F448 = 62536          cpm22.asm:3394
setext   = $ECA9 = 60585          cpm22.asm:1974
setfile  = $EE6E = 61038          cpm22.asm:2378
setfl1   = $EE78 = 61048          cpm22.asm:2383
setfl2   = $EE8B = 61067          cpm22.asm:2395
setfl3   = $EE91 = 61073          cpm22.asm:2401
setfl4   = $EEA0 = 61088          cpm22.asm:2410
sethlde  = $ECB1 = 60593          cpm22.asm:1982
setiob   = $EAF6 = 60150          cpm22.asm:1656
setnrec  = $ECD5 = 60629          cpm22.asm:2008
setran   = $F411 = 62481          cpm22.asm:3357
sets2b7  = $ED7B = 60795          cpm22.asm:2150
setsec   = $F64C = 63052          bios.asm:74
setstat  = $EB04 = 60164          cpm22.asm:1675
settrk   = $F64B = 63051          bios.asm:73
setuser  = $F53E = 62782          cpm22.asm:3558
shiftl   = $ED07 = 60679          cpm22.asm:2050
shiftl1  = $ED08 = 60680          cpm22.asm:2051
shiftr   = $ECED = 60653          cpm22.asm:2024
shiftr1  = $ECEE = 60654          cpm22.asm:2025
showit   = $E982 = 59778          cpm22.asm:1431
slcterr  = $EB4A = 60234          cpm22.asm:1704
space    = $E0A2 = 57506          cpm22.asm:84
srchfcb  = $E0E9 = 57577          cpm22.asm:151
srchfst  = $E0DF = 57567          cpm22.asm:141
srchnxt  = $E0E4 = 57572          cpm22.asm:146
starting = $EB0E = 60174          cpm22.asm:1684
status   = $EB48 = 60232          cpm22.asm:1700
stbitmap = $EE5F = 61023          cpm22.asm:2358
stbmap1  = $EE67 = 61031          cpm22.asm:2369
stddma   = $E1D5 = 57813          cpm22.asm:336
stfilpos = $EE01 = 60929          cpm22.asm:2273
stkarea  = $EB44 = 60228          cpm22.asm:1695
stnrec1  = $ECE1 = 60641          cpm22.asm:2013
strdata  = $ECBE = 60606          cpm22.asm:1992
ststatus = $EF04 = 61188          cpm22.asm:2480
subhl    = $ED98 = 60824          cpm22.asm:2183
synerr   = $E209 = 57865          cpm22.asm:374
synerr1  = $E20F = 57871          cpm22.asm:376
synerr2  = $E222 = 57890          cpm22.asm:386
tab      = $0009 =     9          cpm22.asm:26
tbase    = $0100 =   256          cpm22.asm:19
tbuff    = $0080 =   128          cpm22.asm:18
tdrive   = $0004 =     4          cpm22.asm:15
tfcb     = $005C =    92          cpm22.asm:17
tm_aaaa  = $F7BE = 63422          tms9918.asm:198 (unused)
tm_addr  = $F7B0 = 63408          tms9918.asm:185
tm_cls   = $F79D = 63389          tms9918.asm:170
tm_cls0  = $F7A8 = 63400          tms9918.asm:174
tm_cura  = $F7BB = 63419          tms9918.asm:195
tm_curc  = $F7BC = 63420          tms9918.asm:196
tm_curx  = $F7B9 = 63417          tms9918.asm:193
tm_cury  = $F7BA = 63418          tms9918.asm:194
tm_data  = $00A0 =   160          tms9918.asm:15
tm_escs  = $F7BD = 63421          tms9918.asm:197
tm_ini0  = $F70C = 63244          tms9918.asm:61
tm_init  = $F6D5 = 63189          tms9918.asm:26
tm_latc  = $00A1 =   161          tms9918.asm:16
tm_put0  = $F74E = 63310          tms9918.asm:112
tm_put2  = $F757 = 63319          tms9918.asm:120
tm_put3  = $F758 = 63320          tms9918.asm:121
tm_put4  = $F765 = 63333          tms9918.asm:130
tm_putc  = $F729 = 63273          tms9918.asm:92
tm_read  = $F724 = 63268          tms9918.asm:79
tm_stat  = $F723 = 63267          tms9918.asm:76
tm_ucu0  = $F77A = 63354          tms9918.asm:148
tm_ucu1  = $F788 = 63368          tms9918.asm:154
tm_ucu2  = $F78E = 63374          tms9918.asm:158
tm_ucu3  = $F792 = 63378          tms9918.asm:160
tm_ucur  = $F770 = 63344          tms9918.asm:143
tm_wri0  = $F729 = 63273          tms9918.asm:84
tm_writ  = $F725 = 63269          tms9918.asm:82
tmsdev   = $F6C9 = 63177          tms9918.asm:19
trksec   = $EBC6 = 60358          cpm22.asm:1801
trksec1  = $EBD4 = 60372          cpm22.asm:1810
trksec2  = $EBE7 = 60391          cpm22.asm:1823
trksec3  = $EBFD = 60413          cpm22.asm:1839
trksec4  = $EC12 = 60434          cpm22.asm:1856
type     = $E55D = 58717          cpm22.asm:905
type1    = $E574 = 58740          cpm22.asm:913
type2    = $E577 = 58743          cpm22.asm:914 (unused)
type3    = $E587 = 58759          cpm22.asm:923
type4    = $E5A0 = 58784          cpm22.asm:936
type5    = $E5A7 = 58791          cpm22.asm:939
unknown  = $E6A5 = 59045          cpm22.asm:1077
unkwn0   = $E771 = 59249          cpm22.asm:1185
unkwn1   = $E6C4 = 59076          cpm22.asm:1092
unkwn2   = $E6CD = 59085          cpm22.asm:1096 (unused)
unkwn3   = $E6E1 = 59105          cpm22.asm:1107
unkwn4   = $E701 = 59137          cpm22.asm:1126
unkwn5   = $E730 = 59184          cpm22.asm:1147
unkwn6   = $E73E = 59198          cpm22.asm:1157
unkwn7   = $E743 = 59203          cpm22.asm:1159
unkwn8   = $E74F = 59215          cpm22.asm:1167
unkwn9   = $E76B = 59243          cpm22.asm:1183
update   = $F004 = 61444          cpm22.asm:2689
update1  = $F013 = 61459          cpm22.asm:2697
upper    = $E130 = 57648          cpm22.asm:225
user     = $E68E = 59022          cpm22.asm:1061
userdma  = $F5B4 = 62900          cpm22.asm:3652
userno   = $EB44 = 60228          cpm22.asm:1697
usrstack = $EB12 = 60178          cpm22.asm:1691
verify   = $E1F5 = 57845          cpm22.asm:360
verify1  = $E1FD = 57853          cpm22.asm:363
wboot    = $F603 = 62979          bios.asm:15
wboot0   = $F60C = 62988          bios.asm:21
wboot1   = $F61E = 63006          bios.asm:38
write    = $F64F = 63055          bios.asm:77
writeran = $F39F = 62367          cpm22.asm:3258
wrtprt   = $F5B0 = 62896          cpm22.asm:3650
wrtprtd  = $ED2F = 60719          cpm22.asm:2086
wrtrec   = $E104 = 57604          cpm22.asm:180
wrtseq   = $F4E9 = 62697          cpm22.asm:3495
wtrandom = $F54A = 62794          cpm22.asm:3569
wtseq    = $F201 = 61953          cpm22.asm:2988
wtseq1   = $F206 = 61958          cpm22.asm:2990
wtseq10  = $F2D5 = 62165          cpm22.asm:3105
wtseq11  = $F301 = 62209          cpm22.asm:3129
wtseq12  = $F303 = 62211          cpm22.asm:3130
wtseq2   = $F23E = 62014          cpm22.asm:3013
wtseq3   = $F24B = 62027          cpm22.asm:3019
wtseq4   = $F267 = 62055          cpm22.asm:3031
wtseq5   = $F26F = 62063          cpm22.asm:3038
wtseq6   = $F271 = 62065          cpm22.asm:3039
wtseq7   = $F28F = 62095          cpm22.asm:3062
wtseq8   = $F29D = 62109          cpm22.asm:3069
wtseq9   = $F2BE = 62142          cpm22.asm:3089
wtseq99  = $F2E2 = 62178          cpm22.asm:3116 (unused)
wtspecl  = $F59E = 62878          cpm22.asm:3635
xlate    = $F5D3 = 62931          cpm22.asm:3678
yesno    = $E552 = 58706          cpm22.asm:897


total time: 0.0350 sec.
no errors
