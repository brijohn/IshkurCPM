              	; --------------------------------------
              	; zasm: assemble "cpm22.asm"
              	; date: 2023-03-08 10:48:13
              	; --------------------------------------


              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;*      Modified to build as single image from source
              	;*
              	;**************************************************************
              	
              	
0003:         	iobyte	equ	3		;i/o definition byte.
0004:         	tdrive	equ	4		;current drive name and user number.
0005:         	entry	equ	5		;entry point for the cp/m bdos.
005C:         	tfcb	equ	5ch		;default file control block.
0080:         	tbuff	equ	80h		;i/o buffer and command line storage.
0100:         	tbase	equ	100h		;transiant program storage area.
              	;
              	;   set control character equates.
              	;
0003:         	cntrlc	equ	3		;control-c
0005:         	cntrle	equ	05h		;control-e
0008:         	bs	equ	08h		;backspace
0009:         	tab	equ	09h		;tab
000A:         	lf	equ	0ah		;line feed
000C:         	ff	equ	0ch		;form feed
000D:         	cr	equ	0dh		;carriage return
0010:         	cntrlp	equ	10h		;control-p
0012:         	cntrlr	equ	12h		;control-r
0013:         	cntrls	equ	13h		;control-s
0015:         	cntrlu	equ	15h		;control-u
0018:         	cntrlx	equ	18h		;control-x
001A:         	cntrlz	equ	1ah		;control-z (end-of-file mark)
007F:         	del	equ	7fh		;rubout
              	;
              	;   set origin for cp/m
              	;
DC00:         		org	(mem)*1024
              	;
DC00: C35CDF  	cbase:	jp	command		;execute command processor (ccp).
DC03: C358DF  		jp	clearbuf	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   standard cp/m ccp input buffer. format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
DC06: 7F      	inbuff:	defb	127		;length of input buffer.
DC07: 00      		defb	0		;current length of contents.
DC08: 494E4954		defb	'INIT     '
DC0C: 20202020	
DC10: 20      	
DC11: 20313937		defb	' 1979 (c) by Digital Research      '
DC15: 39202863	
DC19: 29206279	
DC1D: 20446967	
DC21: 6974616C	
DC25: 20526573	
DC29: 65617263	
DC2D: 68202020	
DC31: 202020  	
DC34: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC38: 00...   	
DC4B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC4F: 00...   	
DC62: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC66: 00...   	
DC79: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC7D: 00...   	
DC88: 08DC    	inpoint:defw	inbuff+2	;input line pointer
DC8A: 0000    	namepnt:defw	0		;input line pointer used for error message. points to
              	;			;start of name in error.
              	;
              	;   routine to print (a) on the console. all registers used.
              	;
DC8C: 5F      	print:	ld	e,a		;setup bdos call.
DC8D: 0E02    		ld	c,2
DC8F: C30500  		jp	entry
              	;
              	;   routine to print (a) on the console and to save (bc).
              	;
DC92: C5      	printb:	push	bc
DC93: CD8CDC  		call	print
DC96: C1      		pop	bc
DC97: C9      		ret	
              	;
              	;   routine to send a carriage return, line feed combination
              	; to the console.
              	;
DC98: 3E0D    	crlf:	ld	a,cr
DC9A: CD92DC  		call	printb
DC9D: 3E0A    		ld	a,lf
DC9F: C392DC  		jp	printb
              	;
              	;   routine to send one space to the console and save (bc).
              	;
DCA2: 3E20    	space:	ld	a,' '
DCA4: C392DC  		jp	printb
              	;
              	;   routine to print character string pointed to be (bc) on the
              	; console. it must terminate with a null byte.
              	;
DCA7: C5      	pline:	push	bc
DCA8: CD98DC  		call	crlf
DCAB: E1      		pop	hl
DCAC: 7E      	pline2:	ld	a,(hl)
DCAD: B7      		or	a
DCAE: C8      		ret	z
DCAF: 23      		inc	hl
DCB0: E5      		push	hl
DCB1: CD8CDC  		call	print
DCB4: E1      		pop	hl
DCB5: C3ACDC  		jp	pline2
              	;
              	;   routine to reset the disk system.
              	;
DCB8: 0E0D    	resdsk:	ld	c,13
DCBA: C30500  		jp	entry
              	;
              	;   routine to select disk (a).
              	;
DCBD: 5F      	dsksel:	ld	e,a
DCBE: 0E0E    		ld	c,14
DCC0: C30500  		jp	entry
              	;
              	;   routine to call bdos and save the return code. the zero
              	; flag is set on a return of 0ffh.
              	;
DCC3: CD0500  	entry1:	call	entry
DCC6: 32EEE3  		ld	(rtncode),a	;save return code.
DCC9: 3C      		inc	a		;set zero if 0ffh returned.
DCCA: C9      		ret	
              	;
              	;   routine to open a file. (de) must point to the fcb.
              	;
DCCB: 0E0F    	open:	ld	c,15
DCCD: C3C3DC  		jp	entry1
              	;
              	;   routine to open file at (fcb).
              	;
DCD0: AF      	openfcb:xor	a		;clear the record number byte at fcb+32
DCD1: 32EDE3  		ld	(fcb+32),a
DCD4: 11CDE3  		ld	de,fcb
DCD7: C3CBDC  		jp	open
              	;
              	;   routine to close a file. (de) points to fcb.
              	;
DCDA: 0E10    	close:	ld	c,16
DCDC: C3C3DC  		jp	entry1
              	;
              	;   routine to search for the first file with ambigueous name
              	; (de).
              	;
DCDF: 0E11    	srchfst:ld	c,17
DCE1: C3C3DC  		jp	entry1
              	;
              	;   search for the next ambigeous file name.
              	;
DCE4: 0E12    	srchnxt:ld	c,18
DCE6: C3C3DC  		jp	entry1
              	;
              	;   search for file at (fcb).
              	;
DCE9: 11CDE3  	srchfcb:ld	de,fcb
DCEC: C3DFDC  		jp	srchfst
              	;
              	;   routine to delete a file pointed to by (de).
              	;
DCEF: 0E13    	delete:	ld	c,19
DCF1: C30500  		jp	entry
              	;
              	;   routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
DCF4: CD0500  	entry2:	call	entry
DCF7: B7      		or	a		;set zero flag if appropriate.
DCF8: C9      		ret	
              	;
              	;   routine to read the next record from a sequential file.
              	; (de) points to the fcb.
              	;
DCF9: 0E14    	rdrec:	ld	c,20
DCFB: C3F4DC  		jp	entry2
              	;
              	;   routine to read file at (fcb).
              	;
DCFE: 11CDE3  	readfcb:ld	de,fcb
DD01: C3F9DC  		jp	rdrec
              	;
              	;   routine to write the next record of a sequential file.
              	; (de) points to the fcb.
              	;
DD04: 0E15    	wrtrec:	ld	c,21
DD06: C3F4DC  		jp	entry2
              	;
              	;   routine to create the file pointed to by (de).
              	;
DD09: 0E16    	create:	ld	c,22
DD0B: C3C3DC  		jp	entry1
              	;
              	;   routine to rename the file pointed to by (de). note that
              	; the new name starts at (de+16).
              	;
DD0E: 0E17    	renam:	ld	c,23
DD10: C30500  		jp	entry
              	;
              	;   get the current user code.
              	;
DD13: 1EFF    	getusr:	ld	e,0ffh
              	;
              	;   routne to get or set the current user code.
              	; if (e) is ff then this is a get, else it is a set.
              	;
DD15: 0E20    	getsetuc: ld	c,32
DD17: C30500  		jp	entry
              	;
              	;   routine to set the current drive byte at (tdrive).
              	;
DD1A: CD13DD  	setcdrv:call	getusr		;get user number
DD1D: 87      		add	a,a		;and shift into the upper 4 bits.
DD1E: 87      		add	a,a
DD1F: 87      		add	a,a
DD20: 87      		add	a,a
DD21: 21EFE3  		ld	hl,cdrive	;now add in the current drive number.
DD24: B6      		or	(hl)
DD25: 320400  		ld	(tdrive),a	;and save.
DD28: C9      		ret	
              	;
              	;   move currently active drive down to (tdrive).
              	;
DD29: 3AEFE3  	movecd:	ld	a,(cdrive)
DD2C: 320400  		ld	(tdrive),a
DD2F: C9      		ret	
              	;
              	;   routine to convert (a) into upper case ascii. only letters
              	; are affected.
              	;
DD30: FE61    	upper:	cp	'a'		;check for letters in the range of 'a' to 'z'.
DD32: D8      		ret	c
DD33: FE7B    		cp	'{'
DD35: D0      		ret	nc
DD36: E65F    		and	5fh		;convert it if found.
DD38: C9      		ret	
              	;
              	;   routine to get a line of input. we must check to see if the
              	; user is in (batch) mode. if so, then read the input from file
              	; ($$$.sub). at the end, reset to console input.
              	;
DD39: 3AABE3  	getinp:	ld	a,(batch)	;if =0, then use console input.
DD3C: B7      		or	a
DD3D: CA96DD  		jp	z,getinp1
              	;
              	;   use the submit file ($$$.sub) which is prepared by a
              	; submit run. it must be on drive (a) and it will be deleted
              	; if and error occures (like eof).
              	;
DD40: 3AEFE3  		ld	a,(cdrive)	;select drive 0 if need be.
DD43: B7      		or	a
DD44: 3E00    		ld	a,0		;always use drive a for submit.
DD46: C4BDDC  		call	nz,dsksel	;select it if required.
DD49: 11ACE3  		ld	de,batchfcb
DD4C: CDCBDC  		call	open		;look for it.
DD4F: CA96DD  		jp	z,getinp1	;if not there, use normal input.
DD52: 3ABBE3  		ld	a,(batchfcb+15)	;get last record number+1.
DD55: 3D      		dec	a
DD56: 32CCE3  		ld	(batchfcb+32),a
DD59: 11ACE3  		ld	de,batchfcb
DD5C: CDF9DC  		call	rdrec		;read last record.
DD5F: C296DD  		jp	nz,getinp1	;quit on end of file.
              	;
              	;   move this record into input buffer.
              	;
DD62: 1107DC  		ld	de,inbuff+1
DD65: 218000  		ld	hl,tbuff	;data was read into buffer here.
DD68: 0680    		ld	b,128		;all 128 characters may be used.
DD6A: CD42E0  		call	hl2de		;(hl) to (de), (b) bytes.
DD6D: 21BAE3  		ld	hl,batchfcb+14
DD70: 3600    		ld	(hl),0		;zero out the 's2' byte.
DD72: 23      		inc	hl		;and decrement the record count.
DD73: 35      		dec	(hl)
DD74: 11ACE3  		ld	de,batchfcb	;close the batch file now.
DD77: CDDADC  		call	close
DD7A: CA96DD  		jp	z,getinp1	;quit on an error.
DD7D: 3AEFE3  		ld	a,(cdrive)	;re-select previous drive if need be.
DD80: B7      		or	a
DD81: C4BDDC  		call	nz,dsksel	;don't do needless selects.
              	;
              	;   print line just read on console.
              	;
DD84: 2108DC  		ld	hl,inbuff+2
DD87: CDACDC  		call	pline2
DD8A: CDC2DD  		call	chkcon		;check console, quit on a key.
DD8D: CAA7DD  		jp	z,getinp2	;jump if no key is pressed.
              	;
              	;   terminate the submit job on any keyboard input. delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
DD90: CDDDDD  		call	delbatch	;delete the batch file.
DD93: C382DF  		jp	cmmnd1		;and restart command input.
              	;
              	;   get here for normal keyboard input. delete the submit file
              	; incase there was one.
              	;
DD96: CDDDDD  	getinp1:call	delbatch	;delete file ($$$.sub).
DD99: CD1ADD  		call	setcdrv		;reset active disk.
DD9C: 0E0A    		ld	c,10		;get line from console device.
DD9E: 1106DC  		ld	de,inbuff
DDA1: CD0500  		call	entry
DDA4: CD29DD  		call	movecd		;reset current drive (again).
              	;
              	;   convert input line to upper case.
              	;
DDA7: 2107DC  	getinp2:ld	hl,inbuff+1
DDAA: 46      		ld	b,(hl)		;(b)=character counter.
DDAB: 23      	getinp3:inc	hl
DDAC: 78      		ld	a,b		;end of the line?
DDAD: B7      		or	a
DDAE: CABADD  		jp	z,getinp4
DDB1: 7E      		ld	a,(hl)		;convert to upper case.
DDB2: CD30DD  		call	upper
DDB5: 77      		ld	(hl),a
DDB6: 05      		dec	b		;adjust character count.
DDB7: C3ABDD  		jp	getinp3
DDBA: 77      	getinp4:ld	(hl),a		;add trailing null.
DDBB: 2108DC  		ld	hl,inbuff+2
DDBE: 2288DC  		ld	(inpoint),hl	;reset input line pointer.
DDC1: C9      		ret	
              	;
              	;   routine to check the console for a key pressed. the zero
              	; flag is set is none, else the character is returned in (a).
              	;
DDC2: 0E0B    	chkcon:	ld	c,11		;check console.
DDC4: CD0500  		call	entry
DDC7: B7      		or	a
DDC8: C8      		ret	z		;return if nothing.
DDC9: 0E01    		ld	c,1		;else get character.
DDCB: CD0500  		call	entry
DDCE: B7      		or	a		;clear zero flag and return.
DDCF: C9      		ret	
              	;
              	;   routine to get the currently active drive number.
              	;
DDD0: 0E19    	getdsk:	ld	c,25
DDD2: C30500  		jp	entry
              	;
              	;   set the stabdard dma address.
              	;
DDD5: 118000  	stddma:	ld	de,tbuff
              	;
              	;   routine to set the dma address to (de).
              	;
DDD8: 0E1A    	dmaset:	ld	c,26
DDDA: C30500  		jp	entry
              	;
              	;  delete the batch file created by submit.
              	;
DDDD: 21ABE3  	delbatch: ld	hl,batch	;is batch active?
DDE0: 7E      		ld	a,(hl)
DDE1: B7      		or	a
DDE2: C8      		ret	z
DDE3: 3600    		ld	(hl),0		;yes, de-activate it.
DDE5: AF      		xor	a
DDE6: CDBDDC  		call	dsksel		;select drive 0 for sure.
DDE9: 11ACE3  		ld	de,batchfcb	;and delete this file.
DDEC: CDEFDC  		call	delete
DDEF: 3AEFE3  		ld	a,(cdrive)	;reset current drive.
DDF2: C3BDDC  		jp	dsksel
              	;
              	;   check to two strings at (pattrn1) and (pattrn2). they must be
              	; the same or we halt....
              	;
DDF5: 1128DF  	verify:	ld	de,pattrn1	;these are the serial number bytes.
DDF8: 2100E4  		ld	hl,pattrn2	;ditto, but how could they be different?
DDFB: 0606    		ld	b,6		;6 bytes each.
DDFD: 1A      	verify1:ld	a,(de)
DDFE: BE      		cp	(hl)
DDFF: C2CFDF  		jp	nz,halt		;jump to halt routine.
DE02: 13      		inc	de
DE03: 23      		inc	hl
DE04: 05      		dec	b
DE05: C2FDDD  		jp	nz,verify1
DE08: C9      		ret	
              	;
              	;   print back file name with a '?' to indicate a syntax error.
              	;
DE09: CD98DC  	synerr:	call	crlf		;end current line.
DE0C: 2A8ADC  		ld	hl,(namepnt)	;this points to name in error.
DE0F: 7E      	synerr1:ld	a,(hl)		;print it until a space or null is found.
DE10: FE20    		cp	' '
DE12: CA22DE  		jp	z,synerr2
DE15: B7      		or	a
DE16: CA22DE  		jp	z,synerr2
DE19: E5      		push	hl
DE1A: CD8CDC  		call	print
DE1D: E1      		pop	hl
DE1E: 23      		inc	hl
DE1F: C30FDE  		jp	synerr1
DE22: 3E3F    	synerr2:ld	a,'?'		;add trailing '?'.
DE24: CD8CDC  		call	print
DE27: CD98DC  		call	crlf
DE2A: CDDDDD  		call	delbatch	;delete any batch file.
DE2D: C382DF  		jp	cmmnd1		;and restart from console input.
              	;
              	;   check character at (de) for legal command input. note that the
              	; zero flag is set if the character is a delimiter.
              	;
DE30: 1A      	check:	ld	a,(de)
DE31: B7      		or	a
DE32: C8      		ret	z
DE33: FE20    		cp	' '		;control characters are not legal here.
DE35: DA09DE  		jp	c,synerr
DE38: C8      		ret	z		;check for valid delimiter.
DE39: FE3D    		cp	'='
DE3B: C8      		ret	z
DE3C: FE5F    		cp	'_'
DE3E: C8      		ret	z
DE3F: FE2E    		cp	'.'
DE41: C8      		ret	z
DE42: FE3A    		cp	':'
DE44: C8      		ret	z
DE45: FE3B    		cp	';'
DE47: C8      		ret	z
DE48: FE3C    		cp	'<'
DE4A: C8      		ret	z
DE4B: FE3E    		cp	'>'
DE4D: C8      		ret	z
DE4E: C9      		ret	
              	;
              	;   get the next non-blank character from (de).
              	;
DE4F: 1A      	nonblank: ld	a,(de)
DE50: B7      		or	a		;string ends with a null.
DE51: C8      		ret	z
DE52: FE20    		cp	' '
DE54: C0      		ret	nz
DE55: 13      		inc	de
DE56: C34FDE  		jp	nonblank
              	;
              	;   add (hl)=(hl)+(a)
              	;
DE59: 85      	addhl:	add	a,l
DE5A: 6F      		ld	l,a
DE5B: D0      		ret	nc		;take care of any carry.
DE5C: 24      		inc	h
DE5D: C9      		ret	
              	;
              	;   convert the first name in (fcb).
              	;
DE5E: 3E00    	convfst:ld	a,0
              	;
              	;   format a file name (convert * to '?', etc.). on return,
              	; (a)=0 is an unambigeous name was specified. enter with (a) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
DE60: 21CDE3  	convert:ld	hl,fcb
DE63: CD59DE  		call	addhl
DE66: E5      		push	hl
DE67: E5      		push	hl
DE68: AF      		xor	a
DE69: 32F0E3  		ld	(chgdrv),a	;initialize drive change flag.
DE6C: 2A88DC  		ld	hl,(inpoint)	;set (hl) as pointer into input line.
DE6F: EB      		ex	de,hl
DE70: CD4FDE  		call	nonblank	;get next non-blank character.
DE73: EB      		ex	de,hl
DE74: 228ADC  		ld	(namepnt),hl	;save pointer here for any error message.
DE77: EB      		ex	de,hl
DE78: E1      		pop	hl
DE79: 1A      		ld	a,(de)		;get first character.
DE7A: B7      		or	a
DE7B: CA89DE  		jp	z,convrt1
DE7E: DE40    		sbc	a,'A'-1		;might be a drive name, convert to binary.
DE80: 47      		ld	b,a		;and save.
DE81: 13      		inc	de		;check next character for a ':'.
DE82: 1A      		ld	a,(de)
DE83: FE3A    		cp	':'
DE85: CA90DE  		jp	z,convrt2
DE88: 1B      		dec	de		;nope, move pointer back to the start of the line.
DE89: 3AEFE3  	convrt1:ld	a,(cdrive)
DE8C: 77      		ld	(hl),a
DE8D: C396DE  		jp	convrt3
DE90: 78      	convrt2:ld	a,b
DE91: 32F0E3  		ld	(chgdrv),a	;set change in drives flag.
DE94: 70      		ld	(hl),b
DE95: 13      		inc	de
              	;
              	;   convert the basic file name.
              	;
DE96: 0608    	convrt3:ld	b,08h
DE98: CD30DE  	convrt4:call	check
DE9B: CAB9DE  		jp	z,convrt8
DE9E: 23      		inc	hl
DE9F: FE2A    		cp	'*'		;note that an '*' will fill the remaining
DEA1: C2A9DE  		jp	nz,convrt5	;field with '?'.
DEA4: 363F    		ld	(hl),'?'
DEA6: C3ABDE  		jp	convrt6
DEA9: 77      	convrt5:ld	(hl),a
DEAA: 13      		inc	de
DEAB: 05      	convrt6:dec	b
DEAC: C298DE  		jp	nz,convrt4
DEAF: CD30DE  	convrt7:call	check		;get next delimiter.
DEB2: CAC0DE  		jp	z,getext
DEB5: 13      		inc	de
DEB6: C3AFDE  		jp	convrt7
DEB9: 23      	convrt8:inc	hl		;blank fill the file name.
DEBA: 3620    		ld	(hl),' '
DEBC: 05      		dec	b
DEBD: C2B9DE  		jp	nz,convrt8
              	;
              	;   get the extension and convert it.
              	;
DEC0: 0603    	getext:	ld	b,03h
DEC2: FE2E    		cp	'.'
DEC4: C2E9DE  		jp	nz,getext5
DEC7: 13      		inc	de
DEC8: CD30DE  	getext1:call	check
DECB: CAE9DE  		jp	z,getext5
DECE: 23      		inc	hl
DECF: FE2A    		cp	'*'
DED1: C2D9DE  		jp	nz,getext2
DED4: 363F    		ld	(hl),'?'
DED6: C3DBDE  		jp	getext3
DED9: 77      	getext2:ld	(hl),a
DEDA: 13      		inc	de
DEDB: 05      	getext3:dec	b
DEDC: C2C8DE  		jp	nz,getext1
DEDF: CD30DE  	getext4:call	check
DEE2: CAF0DE  		jp	z,getext6
DEE5: 13      		inc	de
DEE6: C3DFDE  		jp	getext4
DEE9: 23      	getext5:inc	hl
DEEA: 3620    		ld	(hl),' '
DEEC: 05      		dec	b
DEED: C2E9DE  		jp	nz,getext5
DEF0: 0603    	getext6:ld	b,3
DEF2: 23      	getext7:inc	hl
DEF3: 3600    		ld	(hl),0
DEF5: 05      		dec	b
DEF6: C2F2DE  		jp	nz,getext7
DEF9: EB      		ex	de,hl
DEFA: 2288DC  		ld	(inpoint),hl	;save input line pointer.
DEFD: E1      		pop	hl
              	;
              	;   check to see if this is an ambigeous file name specification.
              	; set the (a) register to non zero if it is.
              	;
DEFE: 010B00  		ld	bc,11		;set name length.
DF01: 23      	getext8:inc	hl
DF02: 7E      		ld	a,(hl)
DF03: FE3F    		cp	'?'		;any question marks?
DF05: C209DF  		jp	nz,getext9
DF08: 04      		inc	b		;count them.
DF09: 0D      	getext9:dec	c
DF0A: C201DF  		jp	nz,getext8
DF0D: 78      		ld	a,b
DF0E: B7      		or	a
DF0F: C9      		ret	
              	;
              	;   cp/m command table. note commands can be either 3 or 4 characters long.
              	;
0006:         	numcmds equ	6		;number of commands
DF10: 44495220	cmdtbl:	defb	'DIR '
DF14: 45524120		defb	'ERA '
DF18: 54595045		defb	'TYPE'
DF1C: 53415645		defb	'SAVE'
DF20: 52454E20		defb	'REN '
DF24: 55534552		defb	'USER'
              	;
              	;   the following six bytes must agree with those at (pattrn2)
              	; or cp/m will halt. why?
              	;
DF28: 00160000	pattrn1:defb	0,22,0,0,0,0	;(* serial number bytes *).
DF2C: 0000    	
              	;
              	;   search the command table for a match with what has just
              	; been entered. if a match is found, then we jump to the
              	; proper section. else jump to (unknown).
              	; on return, the (c) register is set to the command number
              	; that matched (or numcmds+1 if no match).
              	;
DF2E: 2110DF  	search:	ld	hl,cmdtbl
DF31: 0E00    		ld	c,0
DF33: 79      	search1:ld	a,c
DF34: FE06    		cp	numcmds		;this commands exists.
DF36: D0      		ret	nc
DF37: 11CEE3  		ld	de,fcb+1	;check this one.
DF3A: 0604    		ld	b,4		;max command length.
DF3C: 1A      	search2:ld	a,(de)
DF3D: BE      		cp	(hl)
DF3E: C24FDF  		jp	nz,search3	;not a match.
DF41: 13      		inc	de
DF42: 23      		inc	hl
DF43: 05      		dec	b
DF44: C23CDF  		jp	nz,search2
DF47: 1A      		ld	a,(de)		;allow a 3 character command to match.
DF48: FE20    		cp	' '
DF4A: C254DF  		jp	nz,search4
DF4D: 79      		ld	a,c		;set return register for this command.
DF4E: C9      		ret	
DF4F: 23      	search3:inc	hl
DF50: 05      		dec	b
DF51: C24FDF  		jp	nz,search3
DF54: 0C      	search4:inc	c
DF55: C333DF  		jp	search1
              	;
              	;   set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
DF58: AF      	clearbuf: xor	a
DF59: 3207DC  		ld	(inbuff+1),a	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
DF5C: 31ABE3  	command:ld	sp,ccpstack	;setup stack area.
DF5F: C5      		push	bc		;note that (c) should be equal to:
DF60: 79      		ld	a,c		;(uuuudddd) where 'uuuu' is the user number
DF61: 1F      		rra			;and 'dddd' is the drive number.
DF62: 1F      		rra	
DF63: 1F      		rra	
DF64: 1F      		rra	
DF65: E60F    		and	0fh		;isolate the user number.
DF67: 5F      		ld	e,a
DF68: CD15DD  		call	getsetuc	;and set it.
DF6B: CDB8DC  		call	resdsk		;reset the disk system.
DF6E: 32ABE3  		ld	(batch),a	;clear batch mode flag.
DF71: C1      		pop	bc
DF72: 79      		ld	a,c
DF73: E60F    		and	0fh		;isolate the drive number.
DF75: 32EFE3  		ld	(cdrive),a	;and save.
DF78: CDBDDC  		call	dsksel		;...and select.
DF7B: 3A07DC  		ld	a,(inbuff+1)
DF7E: B7      		or	a		;anything in input buffer already?
DF7F: C298DF  		jp	nz,cmmnd2	;yes, we just process it.
              	;
              	;   entry point to get a command line from the console.
              	;
DF82: 31ABE3  	cmmnd1:	ld	sp,ccpstack	;set stack straight.
DF85: CD98DC  		call	crlf		;start a new line on the screen.
DF88: CDD0DD  		call	getdsk		;get current drive.
DF8B: C641    		add	a,'A'
DF8D: CD8CDC  		call	print		;print current drive.
DF90: 3E3E    		ld	a,'>'
DF92: CD8CDC  		call	print		;and add prompt.
DF95: CD39DD  		call	getinp		;get line from user.
              	;
              	;   process command line here.
              	;
DF98: 118000  	cmmnd2:	ld	de,tbuff
DF9B: CDD8DD  		call	dmaset		;set standard dma address.
DF9E: CDD0DD  		call	getdsk
DFA1: 32EFE3  		ld	(cdrive),a	;set current drive.
DFA4: CD5EDE  		call	convfst		;convert name typed in.
DFA7: C409DE  		call	nz,synerr	;wild cards are not allowed.
DFAA: 3AF0E3  		ld	a,(chgdrv)	;if a change in drives was indicated,
DFAD: B7      		or	a		;then treat this as an unknown command
DFAE: C2A5E2  		jp	nz,unknown	;which gets executed.
DFB1: CD2EDF  		call	search		;else search command table for a match.
              	;
              	;   note that an unknown command returns
              	; with (a) pointing to the last address
              	; in our table which is (unknown).
              	;
DFB4: 21C1DF  		ld	hl,cmdadr	;now, look thru our address table for command (a).
DFB7: 5F      		ld	e,a		;set (de) to command number.
DFB8: 1600    		ld	d,0
DFBA: 19      		add	hl,de
DFBB: 19      		add	hl,de		;(hl)=(cmdadr)+2*(command number).
DFBC: 7E      		ld	a,(hl)		;now pick out this address.
DFBD: 23      		inc	hl
DFBE: 66      		ld	h,(hl)
DFBF: 6F      		ld	l,a
DFC0: E9      		jp	(hl)		;now execute it.
              	;
              	;   cp/m command address table.
              	;
DFC1: 77E01FE1	cmdadr:	defw	direct,erase,type,save
DFC5: 5DE1ADE1	
DFC9: 10E28EE2		defw	rename,user,unknown
DFCD: A5E2    	
              	;
              	;   halt the system. reason for this is unknown at present.
              	;
DFCF: 21F376  	halt:	ld	hl,76f3h	;'di hlt' instructions.
DFD2: 2200DC  		ld	(cbase),hl
DFD5: 2100DC  		ld	hl,cbase
DFD8: E9      		jp	(hl)
              	;
              	;   read error while typeing a file.
              	;
DFD9: 01DFDF  	rderror:ld	bc,rderr
DFDC: C3A7DC  		jp	pline
DFDF: 72656164	rderr:	defb	'read error',0
DFE3: 20657272	
DFE7: 6F7200  	
              	;
              	;   required file was not located.
              	;
DFEA: 01F0DF  	none:	ld	bc,nofile
DFED: C3A7DC  		jp	pline
DFF0: 6E6F2066	nofile:	defb	'no file',0
DFF4: 696C6500	
              	;
              	;   decode a command of the form 'a>filename number{ filename}.
              	; note that a drive specifier is not allowed on the first file
              	; name. on return, the number is in register (a). any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
DFF8: CD5EDE  	decode:	call	convfst		;convert filename.
DFFB: 3AF0E3  		ld	a,(chgdrv)	;do not allow a drive to be specified.
DFFE: B7      		or	a
DFFF: C209DE  		jp	nz,synerr
E002: 21CEE3  		ld	hl,fcb+1	;convert number now.
E005: 010B00  		ld	bc,11		;(b)=sum register, (c)=max digit count.
E008: 7E      	decode1:ld	a,(hl)
E009: FE20    		cp	' '		;a space terminates the numeral.
E00B: CA33E0  		jp	z,decode3
E00E: 23      		inc	hl
E00F: D630    		sub	'0'		;make binary from ascii.
E011: FE0A    		cp	10		;legal digit?
E013: D209DE  		jp	nc,synerr
E016: 57      		ld	d,a		;yes, save it in (d).
E017: 78      		ld	a,b		;compute (b)=(b)*10 and check for overflow.
E018: E6E0    		and	0e0h
E01A: C209DE  		jp	nz,synerr
E01D: 78      		ld	a,b
E01E: 07      		rlca	
E01F: 07      		rlca	
E020: 07      		rlca			;(a)=(b)*8
E021: 80      		add	a,b		;.......*9
E022: DA09DE  		jp	c,synerr
E025: 80      		add	a,b		;.......*10
E026: DA09DE  		jp	c,synerr
E029: 82      		add	a,d		;add in new digit now.
E02A: DA09DE  	decode2:jp	c,synerr
E02D: 47      		ld	b,a		;and save result.
E02E: 0D      		dec	c		;only look at 11 digits.
E02F: C208E0  		jp	nz,decode1
E032: C9      		ret	
E033: 7E      	decode3:ld	a,(hl)		;spaces must follow (why?).
E034: FE20    		cp	' '
E036: C209DE  		jp	nz,synerr
E039: 23      		inc	hl
E03A: 0D      	decode4:dec	c
E03B: C233E0  		jp	nz,decode3
E03E: 78      		ld	a,b		;set (a)=the numeric value entered.
E03F: C9      		ret	
              	;
              	;   move 3 bytes from (hl) to (de). note that there is only
              	; one reference to this at (a2d5h).
              	;
E040: 0603    	move3:	ld	b,3
              	;
              	;   move (b) bytes from (hl) to (de).
              	;
E042: 7E      	hl2de:	ld	a,(hl)
E043: 12      		ld	(de),a
E044: 23      		inc	hl
E045: 13      		inc	de
E046: 05      		dec	b
E047: C242E0  		jp	nz,hl2de
E04A: C9      		ret	
              	;
              	;   compute (hl)=(tbuff)+(a)+(c) and get the byte that's here.
              	;
E04B: 218000  	extract:ld	hl,tbuff
E04E: 81      		add	a,c
E04F: CD59DE  		call	addhl
E052: 7E      		ld	a,(hl)
E053: C9      		ret	
              	;
              	;  check drive specified. if it means a change, then the new
              	; drive will be selected. in any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
E054: AF      	dselect:xor	a		;null out first byte of fcb.
E055: 32CDE3  		ld	(fcb),a
E058: 3AF0E3  		ld	a,(chgdrv)	;a drive change indicated?
E05B: B7      		or	a
E05C: C8      		ret	z
E05D: 3D      		dec	a		;yes, is it the same as the current drive?
E05E: 21EFE3  		ld	hl,cdrive
E061: BE      		cp	(hl)
E062: C8      		ret	z
E063: C3BDDC  		jp	dsksel		;no. select it then.
              	;
              	;   check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
E066: 3AF0E3  	resetdr:ld	a,(chgdrv)	;drive change indicated?
E069: B7      		or	a
E06A: C8      		ret	z
E06B: 3D      		dec	a		;yes, was it a different drive?
E06C: 21EFE3  		ld	hl,cdrive
E06F: BE      		cp	(hl)
E070: C8      		ret	z
E071: 3AEFE3  		ld	a,(cdrive)	;yes, re-select our old drive.
E074: C3BDDC  		jp	dsksel
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
E077: CD5EDE  	direct:	call	convfst		;convert file name.
E07A: CD54E0  		call	dselect		;select indicated drive.
E07D: 21CEE3  		ld	hl,fcb+1	;was any file indicated?
E080: 7E      		ld	a,(hl)
E081: FE20    		cp	' '
E083: C28FE0  		jp	nz,direct2
E086: 060B    		ld	b,11		;no. fill field with '?' - same as *.*.
E088: 363F    	direct1:ld	(hl),'?'
E08A: 23      		inc	hl
E08B: 05      		dec	b
E08C: C288E0  		jp	nz,direct1
E08F: 1E00    	direct2:ld	e,0		;set initial cursor position.
E091: D5      		push	de
E092: CDE9DC  		call	srchfcb		;get first file name.
E095: CCEADF  		call	z,none		;none found at all?
E098: CA1BE1  	direct3:jp	z,direct9	;terminate if no more names.
E09B: 3AEEE3  		ld	a,(rtncode)	;get file's position in segment (0-3).
E09E: 0F      		rrca	
E09F: 0F      		rrca	
E0A0: 0F      		rrca	
E0A1: E660    		and	60h		;(a)=position*32
E0A3: 4F      		ld	c,a
E0A4: 3E0A    		ld	a,10
E0A6: CD4BE0  		call	extract		;extract the tenth entry in fcb.
E0A9: 17      		rla			;check system file status bit.
E0AA: DA0FE1  		jp	c,direct8	;we don't list them.
E0AD: D1      		pop	de
E0AE: 7B      		ld	a,e		;bump name count.
E0AF: 1C      		inc	e
E0B0: D5      		push	de
E0B1: E603    		and	03h		;at end of line?
E0B3: F5      		push	af
E0B4: C2CCE0  		jp	nz,direct4
E0B7: CD98DC  		call	crlf		;yes, end this line and start another.
E0BA: C5      		push	bc
E0BB: CDD0DD  		call	getdsk		;start line with ('a:').
E0BE: C1      		pop	bc
E0BF: C641    		add	a,'A'
E0C1: CD92DC  		call	printb
E0C4: 3E3A    		ld	a,':'
E0C6: CD92DC  		call	printb
E0C9: C3D4E0  		jp	direct5
E0CC: CDA2DC  	direct4:call	space		;add seperator between file names.
E0CF: 3E3A    		ld	a,':'
E0D1: CD92DC  		call	printb
E0D4: CDA2DC  	direct5:call	space
E0D7: 0601    		ld	b,1		;'extract' each file name character at a time.
E0D9: 78      	direct6:ld	a,b
E0DA: CD4BE0  		call	extract
E0DD: E67F    		and	7fh		;strip bit 7 (status bit).
E0DF: FE20    		cp	' '		;are we at the end of the name?
E0E1: C2F9E0  		jp	nz,drect65
E0E4: F1      		pop	af		;yes, don't print spaces at the end of a line.
E0E5: F5      		push	af
E0E6: FE03    		cp	3
E0E8: C2F7E0  		jp	nz,drect63
E0EB: 3E09    		ld	a,9		;first check for no extension.
E0ED: CD4BE0  		call	extract
E0F0: E67F    		and	7fh
E0F2: FE20    		cp	' '
E0F4: CA0EE1  		jp	z,direct7	;don't print spaces.
E0F7: 3E20    	drect63:ld	a,' '		;else print them.
E0F9: CD92DC  	drect65:call	printb
E0FC: 04      		inc	b		;bump to next character psoition.
E0FD: 78      		ld	a,b
E0FE: FE0C    		cp	12		;end of the name?
E100: D20EE1  		jp	nc,direct7
E103: FE09    		cp	9		;nope, starting extension?
E105: C2D9E0  		jp	nz,direct6
E108: CDA2DC  		call	space		;yes, add seperating space.
E10B: C3D9E0  		jp	direct6
E10E: F1      	direct7:pop	af		;get the next file name.
E10F: CDC2DD  	direct8:call	chkcon		;first check console, quit on anything.
E112: C21BE1  		jp	nz,direct9
E115: CDE4DC  		call	srchnxt		;get next name.
E118: C398E0  		jp	direct3		;and continue with our list.
E11B: D1      	direct9:pop	de		;restore the stack and return to command level.
E11C: C386E3  		jp	getback
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E11F: CD5EDE  	erase:	call	convfst		;convert file name.
E122: FE0B    		cp	11		;was '*.*' entered?
E124: C242E1  		jp	nz,erase1
E127: 0152E1  		ld	bc,yesno	;yes, ask for confirmation.
E12A: CDA7DC  		call	pline
E12D: CD39DD  		call	getinp
E130: 2107DC  		ld	hl,inbuff+1
E133: 35      		dec	(hl)		;must be exactly 'y'.
E134: C282DF  		jp	nz,cmmnd1
E137: 23      		inc	hl
E138: 7E      		ld	a,(hl)
E139: FE79    		cp	'y'
E13B: C282DF  		jp	nz,cmmnd1
E13E: 23      		inc	hl
E13F: 2288DC  		ld	(inpoint),hl	;save input line pointer.
E142: CD54E0  	erase1:	call	dselect		;select desired disk.
E145: 11CDE3  		ld	de,fcb
E148: CDEFDC  		call	delete		;delete the file.
E14B: 3C      		inc	a
E14C: CCEADF  		call	z,none		;not there?
E14F: C386E3  		jp	getback		;return to command level now.
E152: 616C6C20	yesno:	defb	'all (y/n)?',0
E156: 28792F6E	
E15A: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E15D: CD5EDE  	type:	call	convfst		;convert file name.
E160: C209DE  		jp	nz,synerr	;wild cards not allowed.
E163: CD54E0  		call	dselect		;select indicated drive.
E166: CDD0DC  		call	openfcb		;open the file.
E169: CAA7E1  		jp	z,type5		;not there?
E16C: CD98DC  		call	crlf		;ok, start a new line on the screen.
E16F: 21F1E3  		ld	hl,nbytes	;initialize byte counter.
E172: 36FF    		ld	(hl),0ffh	;set to read first sector.
E174: 21F1E3  	type1:	ld	hl,nbytes
E177: 7E      	type2:	ld	a,(hl)		;have we written the entire sector?
E178: FE80    		cp	128
E17A: DA87E1  		jp	c,type3
E17D: E5      		push	hl		;yes, read in the next one.
E17E: CDFEDC  		call	readfcb
E181: E1      		pop	hl
E182: C2A0E1  		jp	nz,type4	;end or error?
E185: AF      		xor	a		;ok, clear byte counter.
E186: 77      		ld	(hl),a
E187: 34      	type3:	inc	(hl)		;count this byte.
E188: 218000  		ld	hl,tbuff	;and get the (a)th one from the buffer (tbuff).
E18B: CD59DE  		call	addhl
E18E: 7E      		ld	a,(hl)
E18F: FE1A    		cp	cntrlz		;end of file mark?
E191: CA86E3  		jp	z,getback
E194: CD8CDC  		call	print		;no, print it.
E197: CDC2DD  		call	chkcon		;check console, quit if anything ready.
E19A: C286E3  		jp	nz,getback
E19D: C374E1  		jp	type1
              	;
              	;   get here on an end of file or read error.
              	;
E1A0: 3D      	type4:	dec	a		;read error?
E1A1: CA86E3  		jp	z,getback
E1A4: CDD9DF  		call	rderror		;yes, print message.
E1A7: CD66E0  	type5:	call	resetdr		;and reset proper drive
E1AA: C309DE  		jp	synerr		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E1AD: CDF8DF  	save:	call	decode		;get numeric number that follows save.
E1B0: F5      		push	af		;save number of pages to write.
E1B1: CD5EDE  		call	convfst		;convert file name.
E1B4: C209DE  		jp	nz,synerr	;wild cards not allowed.
E1B7: CD54E0  		call	dselect		;select specified drive.
E1BA: 11CDE3  		ld	de,fcb		;now delete this file.
E1BD: D5      		push	de
E1BE: CDEFDC  		call	delete
E1C1: D1      		pop	de
E1C2: CD09DD  		call	create		;and create it again.
E1C5: CAFBE1  		jp	z,save3		;can't create?
E1C8: AF      		xor	a		;clear record number byte.
E1C9: 32EDE3  		ld	(fcb+32),a
E1CC: F1      		pop	af		;convert pages to sectors.
E1CD: 6F      		ld	l,a
E1CE: 2600    		ld	h,0
E1D0: 29      		add	hl,hl		;(hl)=number of sectors to write.
E1D1: 110001  		ld	de,tbase	;and we start from here.
E1D4: 7C      	save1:	ld	a,h		;done yet?
E1D5: B5      		or	l
E1D6: CAF1E1  		jp	z,save2
E1D9: 2B      		dec	hl		;nope, count this and compute the start
E1DA: E5      		push	hl		;of the next 128 byte sector.
E1DB: 218000  		ld	hl,128
E1DE: 19      		add	hl,de
E1DF: E5      		push	hl		;save it and set the transfer address.
E1E0: CDD8DD  		call	dmaset
E1E3: 11CDE3  		ld	de,fcb		;write out this sector now.
E1E6: CD04DD  		call	wrtrec
E1E9: D1      		pop	de		;reset (de) to the start of the last sector.
E1EA: E1      		pop	hl		;restore sector count.
E1EB: C2FBE1  		jp	nz,save3	;write error?
E1EE: C3D4E1  		jp	save1
              	;
              	;   get here after writing all of the file.
              	;
E1F1: 11CDE3  	save2:	ld	de,fcb		;now close the file.
E1F4: CDDADC  		call	close
E1F7: 3C      		inc	a		;did it close ok?
E1F8: C201E2  		jp	nz,save4
              	;
              	;   print out error message (no space).
              	;
E1FB: 0107E2  	save3:	ld	bc,nospace
E1FE: CDA7DC  		call	pline
E201: CDD5DD  	save4:	call	stddma		;reset the standard dma address.
E204: C386E3  		jp	getback
E207: 6E6F2073	nospace:defb	'no space',0
E20B: 70616365	
E20F: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E210: CD5EDE  	rename:	call	convfst		;convert first file name.
E213: C209DE  		jp	nz,synerr	;wild cards not allowed.
E216: 3AF0E3  		ld	a,(chgdrv)	;remember any change in drives specified.
E219: F5      		push	af
E21A: CD54E0  		call	dselect		;and select this drive.
E21D: CDE9DC  		call	srchfcb		;is this file present?
E220: C279E2  		jp	nz,rename6	;yes, print error message.
E223: 21CDE3  		ld	hl,fcb		;yes, move this name into second slot.
E226: 11DDE3  		ld	de,fcb+16
E229: 0610    		ld	b,16
E22B: CD42E0  		call	hl2de
E22E: 2A88DC  		ld	hl,(inpoint)	;get input pointer.
E231: EB      		ex	de,hl
E232: CD4FDE  		call	nonblank	;get next non blank character.
E235: FE3D    		cp	'='		;only allow an '=' or '_' seperator.
E237: CA3FE2  		jp	z,rename1
E23A: FE5F    		cp	'_'
E23C: C273E2  		jp	nz,rename5
E23F: EB      	rename1:ex	de,hl
E240: 23      		inc	hl		;ok, skip seperator.
E241: 2288DC  		ld	(inpoint),hl	;save input line pointer.
E244: CD5EDE  		call	convfst		;convert this second file name now.
E247: C273E2  		jp	nz,rename5	;again, no wild cards.
E24A: F1      		pop	af		;if a drive was specified, then it
E24B: 47      		ld	b,a		;must be the same as before.
E24C: 21F0E3  		ld	hl,chgdrv
E24F: 7E      		ld	a,(hl)
E250: B7      		or	a
E251: CA59E2  		jp	z,rename2
E254: B8      		cp	b
E255: 70      		ld	(hl),b
E256: C273E2  		jp	nz,rename5	;they were different, error.
E259: 70      	rename2:ld	(hl),b		;	reset as per the first file specification.
E25A: AF      		xor	a
E25B: 32CDE3  		ld	(fcb),a		;clear the drive byte of the fcb.
E25E: CDE9DC  	rename3:call	srchfcb		;and go look for second file.
E261: CA6DE2  		jp	z,rename4	;doesn't exist?
E264: 11CDE3  		ld	de,fcb
E267: CD0EDD  		call	renam		;ok, rename the file.
E26A: C386E3  		jp	getback
              	;
              	;   process rename errors here.
              	;
E26D: CDEADF  	rename4:call	none		;file not there.
E270: C386E3  		jp	getback
E273: CD66E0  	rename5:call	resetdr		;bad command format.
E276: C309DE  		jp	synerr
E279: 0182E2  	rename6:ld	bc,exists	;destination file already exists.
E27C: CDA7DC  		call	pline
E27F: C386E3  		jp	getback
E282: 66696C65	exists:	defb	'file exists',0
E286: 20657869	
E28A: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
E28E: CDF8DF  	user:	call	decode		;get numeric value following command.
E291: FE10    		cp	16		;legal user number?
E293: D209DE  		jp	nc,synerr
E296: 5F      		ld	e,a		;yes but is there anything else?
E297: 3ACEE3  		ld	a,(fcb+1)
E29A: FE20    		cp	' '
E29C: CA09DE  		jp	z,synerr	;yes, that is not allowed.
E29F: CD15DD  		call	getsetuc	;ok, set user code.
E2A2: C389E3  		jp	getback1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
E2A5: CDF5DD  	unknown:call	verify		;check for valid system (why?).
E2A8: 3ACEE3  		ld	a,(fcb+1)	;anything to execute?
E2AB: FE20    		cp	' '
E2AD: C2C4E2  		jp	nz,unkwn1
E2B0: 3AF0E3  		ld	a,(chgdrv)	;nope, only a drive change?
E2B3: B7      		or	a
E2B4: CA89E3  		jp	z,getback1	;neither???
E2B7: 3D      		dec	a
E2B8: 32EFE3  		ld	(cdrive),a	;ok, store new drive.
E2BB: CD29DD  		call	movecd		;set (tdrive) also.
E2BE: CDBDDC  		call	dsksel		;and select this drive.
E2C1: C389E3  		jp	getback1	;then return.
              	;
              	;   here a file name was typed. prepare to execute it.
              	;
E2C4: 11D6E3  	unkwn1:	ld	de,fcb+9	;an extension specified?
E2C7: 1A      		ld	a,(de)
E2C8: FE20    		cp	' '
E2CA: C209DE  		jp	nz,synerr	;yes, not allowed.
E2CD: D5      	unkwn2:	push	de
E2CE: CD54E0  		call	dselect		;select specified drive.
E2D1: D1      		pop	de
E2D2: 2183E3  		ld	hl,comfile	;set the extension to 'com'.
E2D5: CD40E0  		call	move3
E2D8: CDD0DC  		call	openfcb		;and open this file.
E2DB: CA6BE3  		jp	z,unkwn9	;not present?
              	;
              	;   load in the program.
              	;
E2DE: 210001  		ld	hl,tbase	;store the program starting here.
E2E1: E5      	unkwn3:	push	hl
E2E2: EB      		ex	de,hl
E2E3: CDD8DD  		call	dmaset		;set transfer address.
E2E6: 11CDE3  		ld	de,fcb		;and read the next record.
E2E9: CDF9DC  		call	rdrec
E2EC: C201E3  		jp	nz,unkwn4	;end of file or read error?
E2EF: E1      		pop	hl		;nope, bump pointer for next sector.
E2F0: 118000  		ld	de,128
E2F3: 19      		add	hl,de
E2F4: 1100DC  		ld	de,cbase	;enough room for the whole file?
E2F7: 7D      		ld	a,l
E2F8: 93      		sub	e
E2F9: 7C      		ld	a,h
E2FA: 9A      		sbc	a,d
E2FB: D271E3  		jp	nc,unkwn0	;no, it can't fit.
E2FE: C3E1E2  		jp	unkwn3
              	;
              	;   get here after finished reading.
              	;
E301: E1      	unkwn4:	pop	hl
E302: 3D      		dec	a		;normal end of file?
E303: C271E3  		jp	nz,unkwn0
E306: CD66E0  		call	resetdr		;yes, reset previous drive.
E309: CD5EDE  		call	convfst		;convert the first file name that follows
E30C: 21F0E3  		ld	hl,chgdrv	;command name.
E30F: E5      		push	hl
E310: 7E      		ld	a,(hl)		;set drive code in default fcb.
E311: 32CDE3  		ld	(fcb),a
E314: 3E10    		ld	a,16		;put second name 16 bytes later.
E316: CD60DE  		call	convert		;convert second file name.
E319: E1      		pop	hl
E31A: 7E      		ld	a,(hl)		;and set the drive for this second file.
E31B: 32DDE3  		ld	(fcb+16),a
E31E: AF      		xor	a		;clear record byte in fcb.
E31F: 32EDE3  		ld	(fcb+32),a
E322: 115C00  		ld	de,tfcb		;move it into place at(005ch).
E325: 21CDE3  		ld	hl,fcb
E328: 0621    		ld	b,33
E32A: CD42E0  		call	hl2de
E32D: 2108DC  		ld	hl,inbuff+2	;now move the remainder of the input
E330: 7E      	unkwn5:	ld	a,(hl)		;line down to (0080h). look for a non blank.
E331: B7      		or	a		;or a null.
E332: CA3EE3  		jp	z,unkwn6
E335: FE20    		cp	' '
E337: CA3EE3  		jp	z,unkwn6
E33A: 23      		inc	hl
E33B: C330E3  		jp	unkwn5
              	;
              	;   do the line move now. it ends in a null byte.
              	;
E33E: 0600    	unkwn6:	ld	b,0		;keep a character count.
E340: 118100  		ld	de,tbuff+1	;data gets put here.
E343: 7E      	unkwn7:	ld	a,(hl)		;move it now.
E344: 12      		ld	(de),a
E345: B7      		or	a
E346: CA4FE3  		jp	z,unkwn8
E349: 04      		inc	b
E34A: 23      		inc	hl
E34B: 13      		inc	de
E34C: C343E3  		jp	unkwn7
E34F: 78      	unkwn8:	ld	a,b		;now store the character count.
E350: 328000  		ld	(tbuff),a
E353: CD98DC  		call	crlf		;clean up the screen.
E356: CDD5DD  		call	stddma		;set standard transfer address.
E359: CD1ADD  		call	setcdrv		;reset current drive.
E35C: CD0001  		call	tbase		;and execute the program.
              	;
              	;   transiant programs return here (or reboot).
              	;
E35F: 31ABE3  		ld	sp,batch	;set stack first off.
E362: CD29DD  		call	movecd		;move current drive into place (tdrive).
E365: CDBDDC  		call	dsksel		;and reselect it.
E368: C382DF  		jp	cmmnd1		;back to comand mode.
              	;
              	;   get here if some error occured.
              	;
E36B: CD66E0  	unkwn9:	call	resetdr		;inproper format.
E36E: C309DE  		jp	synerr
E371: 017AE3  	unkwn0:	ld	bc,badload	;read error or won't fit.
E374: CDA7DC  		call	pline
E377: C386E3  		jp	getback
E37A: 42616420	badload:defb	'Bad load',0
E37E: 6C6F6164	
E382: 00      	
E383: 434F4D  	comfile:defb	'COM'		;command file extension.
              	;
              	;   get here to return to command level. we will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
E386: CD66E0  	getback:call	resetdr		;reset previous drive.
E389: CD5EDE  	getback1: call	convfst		;convert first name in (fcb).
E38C: 3ACEE3  		ld	a,(fcb+1)	;if this was just a drive change request,
E38F: D620    		sub	' '		;make sure it was valid.
E391: 21F0E3  		ld	hl,chgdrv
E394: B6      		or	(hl)
E395: C209DE  		jp	nz,synerr
E398: C382DF  		jp	cmmnd1		;ok, return to command level.
              	;
              	;   ccp stack area.
              	;
E39B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E39F: 00...   	
E3AB:         	ccpstack equ	$	;end of ccp stack area.
              	;
              	;   batch (or submit) processing information storage.
              	;
E3AB: 00      	batch:	defb	0		;batch mode flag (0=not active).
E3AC: 00242424	batchfcb: defb	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E3B0: 20202020	
E3B4: 20535542	
E3B8: 00000000	
E3BC: 00...   	
              	;
              	;   file control block setup by the ccp.
              	;
E3CD: 00202020	fcb:	defb	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
E3D1: 20202020	
E3D5: 20202020	
E3D9: 00000000	
E3DD: 00202020	
E3E1: 20202020	
E3E5: 20202020	
E3E9: 00000000	
E3ED: 00      	
E3EE: 00      	rtncode:defb	0		;status returned from bdos call.
E3EF: 00      	cdrive:	defb	0		;currently active drive.
E3F0: 00      	chgdrv:	defb	0		;change in drives flag (0=no change).
E3F1: 0000    	nbytes:	defw	0		;byte counter used by type.
              	;
              	;   room for expansion?
              	;
E3F3: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0
E3F7: 00...   	
              	;
              	;   note that the following six bytes must match those at
              	; (pattrn1) or cp/m will halt. why?
              	;
E400: 00160000	pattrn2:defb	0,22,0,0,0,0	;(* serial number bytes *).
E404: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
E406: C314E4  	fbase:	jp	fbase1
E409: C333F2  		jp	boot
              	;
              	;   bdos error table.
              	;
E40C: 9CE4    	badsctr:defw	error1		;bad sector on read or write.
E40E: A8E4    	badslct:defw	error2		;bad disk select.
E410: AEE4    	rodisk:	defw	error3		;disk is read only.
E412: B4E4    	rofile:	defw	error4		;file is read only.
              	;
              	;   entry into bdos. (de) or (e) are the parameters passed. the
              	; function number desired is in register (c).
              	;
E414: EB      	fbase1:	ex	de,hl		;save the (de) parameters.
E415: 2246E7  		ld	(params),hl
E418: EB      		ex	de,hl
E419: 7B      		ld	a,e		;and save register (e) in particular.
E41A: 32D9F1  		ld	(eparam),a
E41D: 210000  		ld	hl,0
E420: 2248E7  		ld	(status),hl	;clear return status.
E423: 39      		add	hl,sp
E424: 2212E7  		ld	(usrstack),hl	;save users stack pointer.
E427: 3144E7  		ld	sp,stkarea	;and set our own.
E42A: AF      		xor	a		;clear auto select storage space.
E42B: 32E3F1  		ld	(autoflag),a
E42E: 32E1F1  		ld	(auto),a
E431: 2177F1  		ld	hl,goback	;set return address.
E434: E5      		push	hl
E435: 79      		ld	a,c		;get function number.
E436: FE29    		cp	nfuncts		;valid function number?
E438: D0      		ret	nc
E439: 4B      		ld	c,e		;keep single register function here.
E43A: 214AE4  		ld	hl,functns	;now look thru the function table.
E43D: 5F      		ld	e,a
E43E: 1600    		ld	d,0		;(de)=function number.
E440: 19      		add	hl,de
E441: 19      		add	hl,de		;(hl)=(start of table)+2*(function number).
E442: 5E      		ld	e,(hl)
E443: 23      		inc	hl
E444: 56      		ld	d,(hl)		;now (de)=address for this function.
E445: 2A46E7  		ld	hl,(params)	;retrieve parameters.
E448: EB      		ex	de,hl		;now (de) has the original parameters.
E449: E9      		jp	(hl)		;execute desired function.
              	;
              	;   bdos function jump table.
              	;
0029:         	nfuncts equ	41		;number of functions in followin table.
              	;
E44A: 41F2CBE6	functns:defw	wboot,getcon,outcon,getrdr,punch,list,dircio,getiob
E44E: 93E5D1E6	
E452: A9F2A8F2	
E456: D7E6F0E6	
E45A: F6E6FBE6		defw	setiob,prtstr,rdbuff,getcsts,getver,rstdsk,setdsk,openfil
E45E: E4E501E7	
E462: 81F086F0	
E466: 48F09FF0	
E46A: A8F0AEF0		defw	closefil,getfst,getnxt,delfile,readseq,wrtseq,fcreate
E46E: CBF0DAF0	
E472: E3F0E9F0	
E476: EFF0    	
E478: F8F001F1		defw	renfile,getlog,getcrnt,putdma,getaloc,wrtprtd,getrov,setattr
E47C: 07F10DF1	
E480: 14F12FE9	
E484: 1AF120F1	
E488: 29F130F1		defw	getparm,getuser,rdrandom,wtrandom,filesize,setran,logoff,rtn
E48C: 44F14AF1	
E490: 50F111F0	
E494: 56F107E7	
E498: 07E79EF1		defw	rtn,wtspecl
              	;
              	;   bdos error message section.
              	;
E49C: 21CDE4  	error1:	ld	hl,badsec	;bad sector message.
E49F: CDE8E4  		call	prterr		;print it and get a 1 char responce.
E4A2: FE03    		cp	cntrlc		;re-boot request (control-c)?
E4A4: CA0000  		jp	z,0		;yes.
E4A7: C9      		ret			;no, return to retry i/o function.
              	;
E4A8: 21D8E4  	error2:	ld	hl,badsel	;bad drive selected.
E4AB: C3B7E4  		jp	error5
              	;
E4AE: 21E4E4  	error3:	ld	hl,diskro	;disk is read only.
E4B1: C3B7E4  		jp	error5
              	;
E4B4: 21DFE4  	error4:	ld	hl,filero	;file is read only.
              	;
E4B7: CDE8E4  	error5:	call	prterr
E4BA: C30000  		jp	0		;always reboot on these errors.
              	;
E4BD: 42646F73	bdoserr:defb	'Bdos Err on '
E4C1: 20457272	
E4C5: 206F6E20	
E4C9: 203A2024	bdosdrv:defb	' : $'
E4CD: 42616420	badsec:	defb	'Bad Sector$'
E4D1: 53656374	
E4D5: 6F7224  	
E4D8: 53656C65	badsel:	defb	'Select$'
E4DC: 637424  	
E4DF: 46696C65	filero:	defb	'File '
E4E3: 20      	
E4E4: 522F4F24	diskro:	defb	'R/O$'
              	;
              	;   print bdos error message.
              	;
E4E8: E5      	prterr:	push	hl		;save second message pointer.
E4E9: CDCCE5  		call	outcrlf		;send (cr)(lf).
E4EC: 3A45E7  		ld	a,(active)	;get active drive.
E4EF: C641    		add	a,'A'		;make ascii.
E4F1: 32C9E4  		ld	(bdosdrv),a	;and put in message.
E4F4: 01BDE4  		ld	bc,bdoserr	;and print it.
E4F7: CDD6E5  		call	prtmesg
E4FA: C1      		pop	bc		;print second message line now.
E4FB: CDD6E5  		call	prtmesg
              	;
              	;   get an input character. we will check our 1 character
              	; buffer first. this may be set by the console status routine.
              	;
E4FE: 2111E7  	getchar:ld	hl,charbuf	;check character buffer.
E501: 7E      		ld	a,(hl)		;anything present already?
E502: 3600    		ld	(hl),0		;...either case clear it.
E504: B7      		or	a
E505: C0      		ret	nz		;yes, use it.
E506: C392F2  		jp	conin		;nope, go get a character responce.
              	;
              	;   input and echo a character.
              	;
E509: CDFEE4  	getecho:call	getchar		;input a character.
E50C: CD17E5  		call	chkchar		;carriage control?
E50F: D8      		ret	c		;no, a regular control char so don't echo.
E510: F5      		push	af		;ok, save character now.
E511: 4F      		ld	c,a
E512: CD93E5  		call	outcon		;and echo it.
E515: F1      		pop	af		;get character and return.
E516: C9      		ret	
              	;
              	;   check character in (a). set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
E517: FE0D    	chkchar:cp	cr		;check for carriage return, line feed, backspace,
E519: C8      		ret	z		;or a tab.
E51A: FE0A    		cp	lf
E51C: C8      		ret	z
E51D: FE09    		cp	tab
E51F: C8      		ret	z
E520: FE08    		cp	bs
E522: C8      		ret	z
E523: FE20    		cp	' '		;other control char? set carry flag.
E525: C9      		ret	
              	;
              	;   check the console during output. halt on a control-s, then
              	; reboot on a control-c. if anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
E526: 3A11E7  	ckconsol: ld	a,(charbuf)	;check buffer.
E529: B7      		or	a		;if anything, just return without checking.
E52A: C248E5  		jp	nz,ckcon2
E52D: CD88F2  		call	const		;nothing in buffer. check console.
E530: E601    		and	01h		;look at bit 0.
E532: C8      		ret	z		;return if nothing.
E533: CD92F2  		call	conin		;ok, get it.
E536: FE13    		cp	cntrls		;if not control-s, return with zero cleared.
E538: C245E5  		jp	nz,ckcon1
E53B: CD92F2  		call	conin		;halt processing until another char
E53E: FE03    		cp	cntrlc		;is typed. control-c?
E540: CA0000  		jp	z,0		;yes, reboot now.
E543: AF      		xor	a		;no, just pretend nothing was ever ready.
E544: C9      		ret	
E545: 3211E7  	ckcon1:	ld	(charbuf),a	;save character in buffer for later processing.
E548: 3E01    	ckcon2:	ld	a,1		;set (a) to non zero to mean something is ready.
E54A: C9      		ret	
              	;
              	;   output (c) to the screen. if the printer flip-flop flag
              	; is set, we will send character to printer also. the console
              	; will be checked in the process.
              	;
E54B: 3A0DE7  	outchar:ld	a,(outflag)	;check output flag.
E54E: B7      		or	a		;anything and we won't generate output.
E54F: C265E5  		jp	nz,outchr1
E552: C5      		push	bc
E553: CD26E5  		call	ckconsol	;check console (we don't care whats there).
E556: C1      		pop	bc
E557: C5      		push	bc
E558: CD9DF2  		call	conout		;output (c) to the screen.
E55B: C1      		pop	bc
E55C: C5      		push	bc
E55D: 3A10E7  		ld	a,(prtflag)	;check printer flip-flop flag.
E560: B7      		or	a
E561: C4A8F2  		call	nz,list		;print it also if non-zero.
E564: C1      		pop	bc
E565: 79      	outchr1:ld	a,c		;update cursors position.
E566: 210FE7  		ld	hl,curpos
E569: FE7F    		cp	del		;rubouts don't do anything here.
E56B: C8      		ret	z
E56C: 34      		inc	(hl)		;bump line pointer.
E56D: FE20    		cp	' '		;and return if a normal character.
E56F: D0      		ret	nc
E570: 35      		dec	(hl)		;restore and check for the start of the line.
E571: 7E      		ld	a,(hl)
E572: B7      		or	a
E573: C8      		ret	z		;ingnore control characters at the start of the line.
E574: 79      		ld	a,c
E575: FE08    		cp	bs		;is it a backspace?
E577: C27CE5  		jp	nz,outchr2
E57A: 35      		dec	(hl)		;yes, backup pointer.
E57B: C9      		ret	
E57C: FE0A    	outchr2:cp	lf		;is it a line feed?
E57E: C0      		ret	nz		;ignore anything else.
E57F: 3600    		ld	(hl),0		;reset pointer to start of line.
E581: C9      		ret	
              	;
              	;   output (a) to the screen. if it is a control character
              	; (other than carriage control), use ^x format.
              	;
E582: 79      	showit:	ld	a,c
E583: CD17E5  		call	chkchar		;check character.
E586: D293E5  		jp	nc,outcon	;not a control, use normal output.
E589: F5      		push	af
E58A: 0E5E    		ld	c,'^'		;for a control character, preceed it with '^'.
E58C: CD4BE5  		call	outchar
E58F: F1      		pop	af
E590: F640    		or	'@'		;and then use the letter equivelant.
E592: 4F      		ld	c,a
              	;
              	;   function to output (c) to the console device and expand tabs
              	; if necessary.
              	;
E593: 79      	outcon:	ld	a,c
E594: FE09    		cp	tab		;is it a tab?
E596: C24BE5  		jp	nz,outchar	;use regular output.
E599: 0E20    	outcon1:ld	c,' '		;yes it is, use spaces instead.
E59B: CD4BE5  		call	outchar
E59E: 3A0FE7  		ld	a,(curpos)	;go until the cursor is at a multiple of 8
              	
E5A1: E607    		and	07h		;position.
E5A3: C299E5  		jp	nz,outcon1
E5A6: C9      		ret	
              	;
              	;   echo a backspace character. erase the prevoius character
              	; on the screen.
              	;
E5A7: CDAFE5  	backup:	call	backup1		;backup the screen 1 place.
E5AA: 0E20    		ld	c,' '		;then blank that character.
E5AC: CD9DF2  		call	conout
E5AF: 0E08    	backup1:ld	c,bs		;then back space once more.
E5B1: C39DF2  		jp	conout
              	;
              	;   signal a deleted line. print a '#' at the end and start
              	; over.
              	;
E5B4: 0E23    	newline:ld	c,'#'
E5B6: CD4BE5  		call	outchar		;print this.
E5B9: CDCCE5  		call	outcrlf		;start new line.
E5BC: 3A0FE7  	newln1:	ld	a,(curpos)	;move the cursor to the starting position.
E5BF: 210EE7  		ld	hl,starting
E5C2: BE      		cp	(hl)
E5C3: D0      		ret	nc		;there yet?
E5C4: 0E20    		ld	c,' '
E5C6: CD4BE5  		call	outchar		;nope, keep going.
E5C9: C3BCE5  		jp	newln1
              	;
              	;   output a (cr) (lf) to the console device (screen).
              	;
E5CC: 0E0D    	outcrlf:ld	c,cr
E5CE: CD4BE5  		call	outchar
E5D1: 0E0A    		ld	c,lf
E5D3: C34BE5  		jp	outchar
              	;
              	;   print message pointed to by (bc). it will end with a '$'.
              	;
E5D6: 0A      	prtmesg:ld	a,(bc)		;check for terminating character.
E5D7: FE24    		cp	'$'
E5D9: C8      		ret	z
E5DA: 03      		inc	bc
E5DB: C5      		push	bc		;otherwise, bump pointer and print it.
E5DC: 4F      		ld	c,a
E5DD: CD93E5  		call	outcon
E5E0: C1      		pop	bc
E5E1: C3D6E5  		jp	prtmesg
              	;
              	;   function to execute a buffered read.
              	;
E5E4: 3A0FE7  	rdbuff:	ld	a,(curpos)	;use present location as starting one.
E5E7: 320EE7  		ld	(starting),a
E5EA: 2A46E7  		ld	hl,(params)	;get the maximum buffer space.
E5ED: 4E      		ld	c,(hl)
E5EE: 23      		inc	hl		;point to first available space.
E5EF: E5      		push	hl		;and save.
E5F0: 0600    		ld	b,0		;keep a character count.
E5F2: C5      	rdbuf1:	push	bc
E5F3: E5      		push	hl
E5F4: CDFEE4  	rdbuf2:	call	getchar		;get the next input character.
E5F7: E67F    		and	7fh		;strip bit 7.
E5F9: E1      		pop	hl		;reset registers.
E5FA: C1      		pop	bc
E5FB: FE0D    		cp	cr		;en of the line?
E5FD: CAC4E6  		jp	z,rdbuf17
E600: FE0A    		cp	lf
E602: CAC4E6  		jp	z,rdbuf17
E605: FE08    		cp	bs		;how about a backspace?
E607: C219E6  		jp	nz,rdbuf3
E60A: 78      		ld	a,b		;yes, but ignore at the beginning of the line.
E60B: B7      		or	a
E60C: CAF2E5  		jp	z,rdbuf1
E60F: 05      		dec	b		;ok, update counter.
E610: 3A0FE7  		ld	a,(curpos)	;if we backspace to the start of the line,
E613: 320DE7  		ld	(outflag),a	;treat as a cancel (control-x).
E616: C373E6  		jp	rdbuf10
E619: FE7F    	rdbuf3:	cp	del		;user typed a rubout?
E61B: C229E6  		jp	nz,rdbuf4
E61E: 78      		ld	a,b		;ignore at the start of the line.
E61F: B7      		or	a
E620: CAF2E5  		jp	z,rdbuf1
E623: 7E      		ld	a,(hl)		;ok, echo the prevoius character.
E624: 05      		dec	b		;and reset pointers (counters).
E625: 2B      		dec	hl
E626: C3ACE6  		jp	rdbuf15
E629: FE05    	rdbuf4:	cp	cntrle		;physical end of line?
E62B: C23AE6  		jp	nz,rdbuf5
E62E: C5      		push	bc		;yes, do it.
E62F: E5      		push	hl
E630: CDCCE5  		call	outcrlf
E633: AF      		xor	a		;and update starting position.
E634: 320EE7  		ld	(starting),a
E637: C3F4E5  		jp	rdbuf2
E63A: FE10    	rdbuf5:	cp	cntrlp		;control-p?
E63C: C24BE6  		jp	nz,rdbuf6
E63F: E5      		push	hl		;yes, flip the print flag filp-flop byte.
E640: 2110E7  		ld	hl,prtflag
E643: 3E01    		ld	a,1		;prtflag=1-prtflag
E645: 96      		sub	(hl)
E646: 77      		ld	(hl),a
E647: E1      		pop	hl
E648: C3F2E5  		jp	rdbuf1
E64B: FE18    	rdbuf6:	cp	cntrlx		;control-x (cancel)?
E64D: C262E6  		jp	nz,rdbuf8
E650: E1      		pop	hl
E651: 3A0EE7  	rdbuf7:	ld	a,(starting)	;yes, backup the cursor to here.
E654: 210FE7  		ld	hl,curpos
E657: BE      		cp	(hl)
E658: D2E4E5  		jp	nc,rdbuff	;done yet?
E65B: 35      		dec	(hl)		;no, decrement pointer and output back up one space.
E65C: CDA7E5  		call	backup
E65F: C351E6  		jp	rdbuf7
E662: FE15    	rdbuf8:	cp	cntrlu		;cntrol-u (cancel line)?
E664: C26EE6  		jp	nz,rdbuf9
E667: CDB4E5  		call	newline		;start a new line.
E66A: E1      		pop	hl
E66B: C3E4E5  		jp	rdbuff
E66E: FE12    	rdbuf9:	cp	cntrlr		;control-r?
E670: C2A9E6  		jp	nz,rdbuf14
E673: C5      	rdbuf10:push	bc		;yes, start a new line and retype the old one.
E674: CDB4E5  		call	newline
E677: C1      		pop	bc
E678: E1      		pop	hl
E679: E5      		push	hl
E67A: C5      		push	bc
E67B: 78      	rdbuf11:ld	a,b		;done whole line yet?
E67C: B7      		or	a
E67D: CA8DE6  		jp	z,rdbuf12
E680: 23      		inc	hl		;nope, get next character.
E681: 4E      		ld	c,(hl)
E682: 05      		dec	b		;count it.
E683: C5      		push	bc
E684: E5      		push	hl
E685: CD82E5  		call	showit		;and display it.
E688: E1      		pop	hl
E689: C1      		pop	bc
E68A: C37BE6  		jp	rdbuf11
E68D: E5      	rdbuf12:push	hl		;done with line. if we were displaying
E68E: 3A0DE7  		ld	a,(outflag)	;then update cursor position.
E691: B7      		or	a
E692: CAF4E5  		jp	z,rdbuf2
E695: 210FE7  		ld	hl,curpos	;because this line is shorter, we must
E698: 96      		sub	(hl)		;back up the cursor (not the screen however)
E699: 320DE7  		ld	(outflag),a	;some number of positions.
E69C: CDA7E5  	rdbuf13:call	backup		;note that as long as (outflag) is non
E69F: 210DE7  		ld	hl,outflag	;zero, the screen will not be changed.
E6A2: 35      		dec	(hl)
E6A3: C29CE6  		jp	nz,rdbuf13
E6A6: C3F4E5  		jp	rdbuf2		;now just get the next character.
              	;
              	;   just a normal character, put this in our buffer and echo.
              	;
E6A9: 23      	rdbuf14:inc	hl
E6AA: 77      		ld	(hl),a		;store character.
E6AB: 04      		inc	b		;and count it.
E6AC: C5      	rdbuf15:push	bc
E6AD: E5      		push	hl
E6AE: 4F      		ld	c,a		;echo it now.
E6AF: CD82E5  		call	showit
E6B2: E1      		pop	hl
E6B3: C1      		pop	bc
E6B4: 7E      		ld	a,(hl)		;was it an abort request?
E6B5: FE03    		cp	cntrlc		;control-c abort?
E6B7: 78      		ld	a,b
E6B8: C2C0E6  		jp	nz,rdbuf16
E6BB: FE01    		cp	1		;only if at start of line.
E6BD: CA0000  		jp	z,0
E6C0: B9      	rdbuf16:cp	c		;nope, have we filled the buffer?
E6C1: DAF2E5  		jp	c,rdbuf1
E6C4: E1      	rdbuf17:pop	hl		;yes end the line and return.
E6C5: 70      		ld	(hl),b
E6C6: 0E0D    		ld	c,cr
E6C8: C34BE5  		jp	outchar		;output (cr) and return.
              	;
              	;   function to get a character from the console device.
              	;
E6CB: CD09E5  	getcon:	call	getecho		;get and echo.
E6CE: C304E7  		jp	setstat		;save status and return.
              	;
              	;   function to get a character from the tape reader device.
              	;
E6D1: CDAAF2  	getrdr:	call	reader		;get a character from reader, set status and return.
E6D4: C304E7  		jp	setstat
              	;
              	;  function to perform direct console i/o. if (c) contains (ff)
              	; then this is an input request. if (c) contains (fe) then
              	; this is a status request. otherwise we are to output (c).
              	;
E6D7: 79      	dircio:	ld	a,c		;test for (ff).
E6D8: 3C      		inc	a
E6D9: CAE3E6  		jp	z,dirc1
E6DC: 3C      		inc	a		;test for (fe).
E6DD: CA88F2  		jp	z,const
E6E0: C39DF2  		jp	conout		;just output (c).
E6E3: CD88F2  	dirc1:	call	const		;this is an input request.
E6E6: B7      		or	a
E6E7: CA94F1  		jp	z,goback1	;not ready? just return (directly).
E6EA: CD92F2  		call	conin		;yes, get character.
E6ED: C304E7  		jp	setstat		;set status and return.
              	;
              	;   function to return the i/o byte.
              	;
E6F0: 3A0300  	getiob:	ld	a,(iobyte)
E6F3: C304E7  		jp	setstat
              	;
              	;   function to set the i/o byte.
              	;
E6F6: 210300  	setiob:	ld	hl,iobyte
E6F9: 71      		ld	(hl),c
E6FA: C9      		ret	
              	;
              	;   function to print the character string pointed to by (de)
              	; on the console device. the string ends with a '$'.
              	;
E6FB: EB      	prtstr:	ex	de,hl
E6FC: 4D      		ld	c,l
E6FD: 44      		ld	b,h		;now (bc) points to it.
E6FE: C3D6E5  		jp	prtmesg
              	;
              	;   function to interigate the console device.
              	;
E701: CD26E5  	getcsts:call	ckconsol
              	;
              	;   get here to set the status and return to the cleanup
              	; section. then back to the user.
              	;
E704: 3248E7  	setstat:ld	(status),a
E707: C9      	rtn:	ret	
              	;
              	;   set the status to 1 (read or write error code).
              	;
E708: 3E01    	ioerr1:	ld	a,1
E70A: C304E7  		jp	setstat
              	;
E70D: 00      	outflag:defb	0		;output flag (non zero means no output).
E70E: 02      	starting: defb	2		;starting position for cursor.
E70F: 00      	curpos:	defb	0		;cursor position (0=start of line).
E710: 00      	prtflag:defb	0		;printer flag (control-p toggle). list if non zero.
E711: 00      	charbuf:defb	0		;single input character buffer.
              	;
              	;   stack area for bdos calls.
              	;
E712: 0000    	usrstack: defw	0		;save users stack pointer here.
              	;
E714: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E718: 00...   	
E72C: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E730: 00...   	
E744:         	stkarea equ	$		;end of stack area.
              	;
E744: 00      	userno:	defb	0		;current user number.
E745: 00      	active:	defb	0		;currently active drive.
E746: 0000    	params:	defw	0		;save (de) parameters here on entry.
E748: 0000    	status:	defw	0		;status returned from bdos function.
              	;
              	;   select error occured, jump to error routine.
              	;
E74A: 210EE4  	slcterr:ld	hl,badslct
              	;
              	;   jump to (hl) indirectly.
              	;
E74D: 5E      	jumphl:	ld	e,(hl)
E74E: 23      		inc	hl
E74F: 56      		ld	d,(hl)		;now (de) contain the desired address.
E750: EB      		ex	de,hl
E751: E9      		jp	(hl)
              	;
              	;   block move. (de) to (hl), (c) bytes total.
              	;
E752: 0C      	de2hl:	inc	c		;is count down to zero?
E753: 0D      	de2hl1:	dec	c
E754: C8      		ret	z		;yes, we are done.
E755: 1A      		ld	a,(de)		;no, move one more byte.
E756: 77      		ld	(hl),a
E757: 13      		inc	de
E758: 23      		inc	hl
E759: C353E7  		jp	de2hl1		;and repeat.
              	;
              	;   select the desired drive.
              	;
E75C: 3A45E7  	select:	ld	a,(active)	;get active disk.
E75F: 4F      		ld	c,a
E760: CDB2F2  		call	seldsk		;select it.
E763: 7C      		ld	a,h		;valid drive?
E764: B5      		or	l		;valid drive?
E765: C8      		ret	z		;return if not.
              	;
              	;   here, the bios returned the address of the parameter block
              	; in (hl). we will extract the necessary pointers and save them.
              	;
E766: 5E      		ld	e,(hl)		;yes, get address of translation table into (de).
E767: 23      		inc	hl
E768: 56      		ld	d,(hl)
E769: 23      		inc	hl
E76A: 22B6F1  		ld	(scratch1),hl	;save pointers to scratch areas.
E76D: 23      		inc	hl
E76E: 23      		inc	hl
E76F: 22B8F1  		ld	(scratch2),hl	;ditto.
E772: 23      		inc	hl
E773: 23      		inc	hl
E774: 22BAF1  		ld	(scratch3),hl	;ditto.
E777: 23      		inc	hl
E778: 23      		inc	hl
E779: EB      		ex	de,hl		;now save the translation table address.
E77A: 22D3F1  		ld	(xlate),hl
E77D: 21BCF1  		ld	hl,dirbuf	;put the next 8 bytes here.
E780: 0E08    		ld	c,8		;they consist of the directory buffer
E782: CD52E7  		call	de2hl		;pointer, parameter block pointer,
E785: 2ABEF1  		ld	hl,(diskpb)	;check and allocation vectors.
E788: EB      		ex	de,hl
E789: 21C4F1  		ld	hl,sectors	;move parameter block into our ram.
E78C: 0E0F    		ld	c,15		;it is 15 bytes long.
E78E: CD52E7  		call	de2hl
E791: 2AC9F1  		ld	hl,(dsksize)	;check disk size.
E794: 7C      		ld	a,h		;more than 256 blocks on this?
E795: 21E0F1  		ld	hl,bigdisk
E798: 36FF    		ld	(hl),0ffh	;set to samll.
E79A: B7      		or	a
E79B: CAA0E7  		jp	z,select1
E79E: 3600    		ld	(hl),0		;wrong, set to large.
E7A0: 3EFF    	select1:ld	a,0ffh		;clear the zero flag.
E7A2: B7      		or	a
E7A3: C9      		ret	
              	;
              	;   routine to home the disk track head and clear pointers.
              	;
E7A4: CDADF2  	homedrv:call	home		;home the head.
E7A7: AF      		xor	a
E7A8: 2AB8F1  		ld	hl,(scratch2)	;set our track pointer also.
E7AB: 77      		ld	(hl),a
E7AC: 23      		inc	hl
E7AD: 77      		ld	(hl),a
E7AE: 2ABAF1  		ld	hl,(scratch3)	;and our sector pointer.
E7B1: 77      		ld	(hl),a
E7B2: 23      		inc	hl
E7B3: 77      		ld	(hl),a
E7B4: C9      		ret	
              	;
              	;   do the actual disk read and check the error return status.
              	;
E7B5: CDDEF2  	doread:	call	read
E7B8: C3BEE7  		jp	ioret
              	;
              	;   do the actual disk write and handle any bios error.
              	;
E7BB: CDE2F2  	dowrite:call	write
E7BE: B7      	ioret:	or	a
E7BF: C8      		ret	z		;return unless an error occured.
E7C0: 210CE4  		ld	hl,badsctr	;bad read/write on this sector.
E7C3: C34DE7  		jp	jumphl
              	;
              	;   routine to select the track and sector that the desired
              	; block number falls in.
              	;
E7C6: 2AEDF1  	trksec:	ld	hl,(filepos)	;get position of last accessed file
E7C9: 0E02    		ld	c,2		;in directory and compute sector #.
E7CB: CDEDE8  		call	shiftr		;sector #=file-position/4.
E7CE: 22E8F1  		ld	(blknmbr),hl	;save this as the block number of interest.
E7D1: 22EFF1  		ld	(cksumtbl),hl	;what's it doing here too?
              	;
              	;   if the sector number has already been set (blknmbr), enter
              	; at this point.
              	;
E7D4: 21E8F1  	trksec1:ld	hl,blknmbr
E7D7: 4E      		ld	c,(hl)		;move sector number into (bc).
E7D8: 23      		inc	hl
E7D9: 46      		ld	b,(hl)
E7DA: 2ABAF1  		ld	hl,(scratch3)	;get current sector number and
E7DD: 5E      		ld	e,(hl)		;move this into (de).
E7DE: 23      		inc	hl
E7DF: 56      		ld	d,(hl)
E7E0: 2AB8F1  		ld	hl,(scratch2)	;get current track number.
E7E3: 7E      		ld	a,(hl)		;and this into (hl).
E7E4: 23      		inc	hl
E7E5: 66      		ld	h,(hl)
E7E6: 6F      		ld	l,a
E7E7: 79      	trksec2:ld	a,c		;is desired sector before current one?
E7E8: 93      		sub	e
E7E9: 78      		ld	a,b
E7EA: 9A      		sbc	a,d
E7EB: D2FDE7  		jp	nc,trksec3
E7EE: E5      		push	hl		;yes, decrement sectors by one track.
E7EF: 2AC4F1  		ld	hl,(sectors)	;get sectors per track.
E7F2: 7B      		ld	a,e
E7F3: 95      		sub	l
E7F4: 5F      		ld	e,a
E7F5: 7A      		ld	a,d
E7F6: 9C      		sbc	a,h
E7F7: 57      		ld	d,a		;now we have backed up one full track.
E7F8: E1      		pop	hl
E7F9: 2B      		dec	hl		;adjust track counter.
E7FA: C3E7E7  		jp	trksec2
E7FD: E5      	trksec3:push	hl		;desired sector is after current one.
E7FE: 2AC4F1  		ld	hl,(sectors)	;get sectors per track.
E801: 19      		add	hl,de		;bump sector pointer to next track.
E802: DA12E8  		jp	c,trksec4
E805: 79      		ld	a,c		;is desired sector now before current one?
E806: 95      		sub	l
E807: 78      		ld	a,b
E808: 9C      		sbc	a,h
E809: DA12E8  		jp	c,trksec4
E80C: EB      		ex	de,hl		;not yes, increment track counter
E80D: E1      		pop	hl		;and continue until it is.
E80E: 23      		inc	hl
E80F: C3FDE7  		jp	trksec3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
E812: E1      	trksec4:pop	hl		;get track number (hl).
E813: C5      		push	bc
E814: D5      		push	de
E815: E5      		push	hl
E816: EB      		ex	de,hl
E817: 2AD1F1  		ld	hl,(offset)	;adjust for first track offset.
E81A: 19      		add	hl,de
E81B: 44      		ld	b,h
E81C: 4D      		ld	c,l
E81D: CDD0F2  		call	settrk		;select this track.
E820: D1      		pop	de		;reset current track pointer.
E821: 2AB8F1  		ld	hl,(scratch2)
E824: 73      		ld	(hl),e
E825: 23      		inc	hl
E826: 72      		ld	(hl),d
E827: D1      		pop	de
E828: 2ABAF1  		ld	hl,(scratch3)	;reset the first sector on this track.
E82B: 73      		ld	(hl),e
E82C: 23      		inc	hl
E82D: 72      		ld	(hl),d
E82E: C1      		pop	bc
E82F: 79      		ld	a,c		;now subtract the desired one.
E830: 93      		sub	e		;to make it relative (1-# sectors/track).
E831: 4F      		ld	c,a
E832: 78      		ld	a,b
E833: 9A      		sbc	a,d
E834: 47      		ld	b,a
E835: 2AD3F1  		ld	hl,(xlate)	;translate this sector according to this table.
E838: EB      		ex	de,hl
E839: CDE9F2  		call	sectrn		;let the bios translate it.
E83C: 4D      		ld	c,l
E83D: 44      		ld	b,h
E83E: C3D4F2  		jp	setsec		;and select it.
              	;
              	;   compute block number from record number (savnrec) and
              	; extent number (savext).
              	;
E841: 21C6F1  	getblock: ld	hl,blkshft	;get logical to physical conversion.
E844: 4E      		ld	c,(hl)		;note that this is base 2 log of ratio.
E845: 3AE6F1  		ld	a,(savnrec)	;get record number.
E848: B7      	getblk1:or	a		;compute (a)=(a)/2^blkshft.
E849: 1F      		rra	
E84A: 0D      		dec	c
E84B: C248E8  		jp	nz,getblk1
E84E: 47      		ld	b,a		;save result in (b).
E84F: 3E08    		ld	a,8
E851: 96      		sub	(hl)
E852: 4F      		ld	c,a		;compute (c)=8-blkshft.
E853: 3AE5F1  		ld	a,(savext)
E856: 0D      	getblk2:dec	c		;compute (a)=savext*2^(8-blkshft).
E857: CA5FE8  		jp	z,getblk3
E85A: B7      		or	a
E85B: 17      		rla	
E85C: C356E8  		jp	getblk2
E85F: 80      	getblk3:add	a,b
E860: C9      		ret	
              	;
              	;   routine to extract the (bc) block byte from the fcb pointed
              	; to by (params). if this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; number is returned in (hl).
              	;
E861: 2A46E7  	extblk:	ld	hl,(params)	;get fcb address.
E864: 111000  		ld	de,16		;block numbers start 16 bytes into fcb.
E867: 19      		add	hl,de
E868: 09      		add	hl,bc
E869: 3AE0F1  		ld	a,(bigdisk)	;are we using a big-disk?
E86C: B7      		or	a
E86D: CA74E8  		jp	z,extblk1
E870: 6E      		ld	l,(hl)		;no, extract an 8 bit number from the fcb.
E871: 2600    		ld	h,0
E873: C9      		ret	
E874: 09      	extblk1:add	hl,bc		;yes, extract a 16 bit number.
E875: 5E      		ld	e,(hl)
E876: 23      		inc	hl
E877: 56      		ld	d,(hl)
E878: EB      		ex	de,hl		;return in (hl).
E879: C9      		ret	
              	;
              	;   compute block number.
              	;
E87A: CD41E8  	comblk:	call	getblock
E87D: 4F      		ld	c,a
E87E: 0600    		ld	b,0
E880: CD61E8  		call	extblk
E883: 22E8F1  		ld	(blknmbr),hl
E886: C9      		ret	
              	;
              	;   check for a zero block number (unused).
              	;
E887: 2AE8F1  	chkblk:	ld	hl,(blknmbr)
E88A: 7D      		ld	a,l		;is it zero?
E88B: B4      		or	h
E88C: C9      		ret	
              	;
              	;   adjust physical block (blknmbr) and convert to logical
              	; sector (logsect). this is the starting sector of this block.
              	; the actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (blknmbr). this
              	; will still have to be adjusted for the track number.
              	;
E88D: 3AC6F1  	logical:ld	a,(blkshft)	;get log2(physical/logical sectors).
E890: 2AE8F1  		ld	hl,(blknmbr)	;get physical sector desired.
E893: 29      	logicl1:add	hl,hl		;compute logical sector number.
E894: 3D      		dec	a		;note logical sectors are 128 bytes long.
E895: C293E8  		jp	nz,logicl1
E898: 22EAF1  		ld	(logsect),hl	;save logical sector.
E89B: 3AC7F1  		ld	a,(blkmask)	;get block mask.
E89E: 4F      		ld	c,a
E89F: 3AE6F1  		ld	a,(savnrec)	;get next sector to access.
E8A2: A1      		and	c		;extract the relative position within physical block.
E8A3: B5      		or	l		;and add it too logical sector.
E8A4: 6F      		ld	l,a
E8A5: 22E8F1  		ld	(blknmbr),hl	;and store.
E8A8: C9      		ret	
              	;
              	;   set (hl) to point to extent byte in fcb.
              	;
E8A9: 2A46E7  	setext:	ld	hl,(params)
E8AC: 110C00  		ld	de,12		;it is the twelth byte.
E8AF: 19      		add	hl,de
E8B0: C9      		ret	
              	;
              	;   set (hl) to point to record count byte in fcb and (de) to
              	; next record number byte.
              	;
E8B1: 2A46E7  	sethlde:ld	hl,(params)
E8B4: 110F00  		ld	de,15		;record count byte (#15).
E8B7: 19      		add	hl,de
E8B8: EB      		ex	de,hl
E8B9: 211100  		ld	hl,17		;next record number (#32).
E8BC: 19      		add	hl,de
E8BD: C9      		ret	
              	;
              	;   save current file data from fcb.
              	;
E8BE: CDB1E8  	strdata:call	sethlde
E8C1: 7E      		ld	a,(hl)		;get and store record count byte.
E8C2: 32E6F1  		ld	(savnrec),a
E8C5: EB      		ex	de,hl
E8C6: 7E      		ld	a,(hl)		;get and store next record number byte.
E8C7: 32E4F1  		ld	(savnxt),a
E8CA: CDA9E8  		call	setext		;point to extent byte.
E8CD: 3AC8F1  		ld	a,(extmask)	;get extent mask.
E8D0: A6      		and	(hl)
E8D1: 32E5F1  		ld	(savext),a	;and save extent here.
E8D4: C9      		ret	
              	;
              	;   set the next record to access. if (mode) is set to 2, then
              	; the last record byte (savnrec) has the correct number to access.
              	; for sequential access, (mode) will be equal to 1.
              	;
E8D5: CDB1E8  	setnrec:call	sethlde
E8D8: 3AD8F1  		ld	a,(mode)	;get sequential flag (=1).
E8DB: FE02    		cp	2		;a 2 indicates that no adder is needed.
E8DD: C2E1E8  		jp	nz,stnrec1
E8E0: AF      		xor	a		;clear adder (random access?).
E8E1: 4F      	stnrec1:ld	c,a
E8E2: 3AE6F1  		ld	a,(savnrec)	;get last record number.
E8E5: 81      		add	a,c		;increment record count.
E8E6: 77      		ld	(hl),a		;and set fcb's next record byte.
E8E7: EB      		ex	de,hl
E8E8: 3AE4F1  		ld	a,(savnxt)	;get next record byte from storage.
E8EB: 77      		ld	(hl),a		;and put this into fcb as number of records used.
E8EC: C9      		ret	
              	;
              	;   shift (hl) right (c) bits.
              	;
E8ED: 0C      	shiftr:	inc	c
E8EE: 0D      	shiftr1:dec	c
E8EF: C8      		ret	z
E8F0: 7C      		ld	a,h
E8F1: B7      		or	a
E8F2: 1F      		rra	
E8F3: 67      		ld	h,a
E8F4: 7D      		ld	a,l
E8F5: 1F      		rra	
E8F6: 6F      		ld	l,a
E8F7: C3EEE8  		jp	shiftr1
              	;
              	;   compute the check-sum for the directory buffer. return
              	; integer sum in (a).
              	;
E8FA: 0E80    	checksum: ld	c,128		;length of buffer.
E8FC: 2ABCF1  		ld	hl,(dirbuf)	;get its location.
E8FF: AF      		xor	a		;clear summation byte.
E900: 86      	chksum1:add	a,(hl)		;and compute sum ignoring carries.
E901: 23      		inc	hl
E902: 0D      		dec	c
E903: C200E9  		jp	nz,chksum1
E906: C9      		ret	
              	;
              	;   shift (hl) left (c) bits.
              	;
E907: 0C      	shiftl:	inc	c
E908: 0D      	shiftl1:dec	c
E909: C8      		ret	z
E90A: 29      		add	hl,hl		;shift left 1 bit.
E90B: C308E9  		jp	shiftl1
              	;
              	;   routine to set a bit in a 16 bit value contained in (bc).
              	; the bit set depends on the current drive selection.
              	;
E90E: C5      	setbit:	push	bc		;save 16 bit word.
E90F: 3A45E7  		ld	a,(active)	;get active drive.
E912: 4F      		ld	c,a
E913: 210100  		ld	hl,1
E916: CD07E9  		call	shiftl		;shift bit 0 into place.
E919: C1      		pop	bc		;now 'or' this with the original word.
E91A: 79      		ld	a,c
E91B: B5      		or	l
E91C: 6F      		ld	l,a		;low byte done, do high byte.
E91D: 78      		ld	a,b
E91E: B4      		or	h
E91F: 67      		ld	h,a
E920: C9      		ret	
              	;
              	;   extract the write protect status bit for the current drive.
              	; the result is returned in (a), bit 0.
              	;
E921: 2AB0F1  	getwprt:ld	hl,(wrtprt)	;get status bytes.
E924: 3A45E7  		ld	a,(active)	;which drive is current?
E927: 4F      		ld	c,a
E928: CDEDE8  		call	shiftr		;shift status such that bit 0 is the
E92B: 7D      		ld	a,l		;one of interest for this drive.
E92C: E601    		and	01h		;and isolate it.
E92E: C9      		ret	
              	;
              	;   function to write protect the current disk.
              	;
E92F: 21B0F1  	wrtprtd:ld	hl,wrtprt	;point to status word.
E932: 4E      		ld	c,(hl)		;set (bc) equal to the status.
E933: 23      		inc	hl
E934: 46      		ld	b,(hl)
E935: CD0EE9  		call	setbit		;and set this bit according to current drive.
E938: 22B0F1  		ld	(wrtprt),hl	;then save.
E93B: 2ACBF1  		ld	hl,(dirsize)	;now save directory size limit.
E93E: 23      		inc	hl		;remember the last one.
E93F: EB      		ex	de,hl
E940: 2AB6F1  		ld	hl,(scratch1)	;and store it here.
E943: 73      		ld	(hl),e		;put low byte.
E944: 23      		inc	hl
E945: 72      		ld	(hl),d		;then high byte.
E946: C9      		ret	
              	;
              	;   check for a read only file.
              	;
E947: CD61E9  	chkrofl:call	fcb2hl		;set (hl) to file entry in directory buffer.
E94A: 110900  	ckrof1:	ld	de,9		;look at bit 7 of the ninth byte.
E94D: 19      		add	hl,de
E94E: 7E      		ld	a,(hl)
E94F: 17      		rla	
E950: D0      		ret	nc		;return if ok.
E951: 2112E4  		ld	hl,rofile	;else, print error message and terminate.
E954: C34DE7  		jp	jumphl
              	;
              	;   check the write protect status of the active disk.
              	;
E957: CD21E9  	chkwprt:call	getwprt
E95A: C8      		ret	z		;return if ok.
E95B: 2110E4  		ld	hl,rodisk	;else print message and terminate.
E95E: C34DE7  		jp	jumphl
              	;
              	;   routine to set (hl) pointing to the proper entry in the
              	; directory buffer.
              	;
E961: 2ABCF1  	fcb2hl:	ld	hl,(dirbuf)	;get address of buffer.
E964: 3AECF1  		ld	a,(fcbpos)	;relative position of file.
              	;
              	;   routine to add (a) to (hl).
              	;
E967: 85      	adda2hl:add	a,l
E968: 6F      		ld	l,a
E969: D0      		ret	nc
E96A: 24      		inc	h		;take care of any carry.
E96B: C9      		ret	
              	;
              	;   routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
E96C: 2A46E7  	gets2:	ld	hl,(params)	;get address of fcb.
E96F: 110E00  		ld	de,14		;relative position of 's2'.
E972: 19      		add	hl,de
E973: 7E      		ld	a,(hl)		;extract this byte.
E974: C9      		ret	
              	;
              	;   clear the 's2' byte in the fcb.
              	;
E975: CD6CE9  	clears2:call	gets2		;this sets (hl) pointing to it.
E978: 3600    		ld	(hl),0		;now clear it.
E97A: C9      		ret	
              	;
              	;   set bit 7 in the 's2' byte of the fcb.
              	;
E97B: CD6CE9  	sets2b7:call	gets2		;get the byte.
E97E: F680    		or	80h		;and set bit 7.
E980: 77      		ld	(hl),a		;then store.
E981: C9      		ret	
              	;
              	;   compare (filepos) with (scratch1) and set flags based on
              	; the difference. this checks to see if there are more file
              	; names in the directory. we are at (filepos) and there are
              	; (scratch1) of them to check.
              	;
E982: 2AEDF1  	morefls:ld	hl,(filepos)	;we are here.
E985: EB      		ex	de,hl
E986: 2AB6F1  		ld	hl,(scratch1)	;and don't go past here.
E989: 7B      		ld	a,e		;compute difference but don't keep.
E98A: 96      		sub	(hl)
E98B: 23      		inc	hl
E98C: 7A      		ld	a,d
E98D: 9E      		sbc	a,(hl)		;set carry if no more names.
E98E: C9      		ret	
              	;
              	;   call this routine to prevent (scratch1) from being greater
              	; than (filepos).
              	;
E98F: CD82E9  	chknmbr:call	morefls		;scratch1 too big?
E992: D8      		ret	c
E993: 13      		inc	de		;yes, reset it to (filepos).
E994: 72      		ld	(hl),d
E995: 2B      		dec	hl
E996: 73      		ld	(hl),e
E997: C9      		ret	
              	;
              	;   compute (hl)=(de)-(hl)
              	;
E998: 7B      	subhl:	ld	a,e		;compute difference.
E999: 95      		sub	l
E99A: 6F      		ld	l,a		;store low byte.
E99B: 7A      		ld	a,d
E99C: 9C      		sbc	a,h
E99D: 67      		ld	h,a		;and then high byte.
E99E: C9      		ret	
              	;
              	;   set the directory checksum byte.
              	;
E99F: 0EFF    	setdir:	ld	c,0ffh
              	;
              	;   routine to set or compare the directory checksum byte. if
              	; (c)=0ffh, then this will set the checksum byte. else the byte
              	; will be checked. if the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
E9A1: 2AEFF1  	checkdir: ld	hl,(cksumtbl)
E9A4: EB      		ex	de,hl
E9A5: 2ACFF1  		ld	hl,(alloc1)
E9A8: CD98E9  		call	subhl
E9AB: D0      		ret	nc		;ok if (cksumtbl) > (alloc1), so return.
E9AC: C5      		push	bc
E9AD: CDFAE8  		call	checksum	;else compute checksum.
E9B0: 2AC0F1  		ld	hl,(chkvect)	;get address of checksum table.
E9B3: EB      		ex	de,hl
E9B4: 2AEFF1  		ld	hl,(cksumtbl)
E9B7: 19      		add	hl,de		;set (hl) to point to byte for this drive.
E9B8: C1      		pop	bc
E9B9: 0C      		inc	c		;set or check ?
E9BA: CAC7E9  		jp	z,chkdir1
E9BD: BE      		cp	(hl)		;check them.
E9BE: C8      		ret	z		;return if they are the same.
E9BF: CD82E9  		call	morefls		;not the same, do we care?
E9C2: D0      		ret	nc
E9C3: CD2FE9  		call	wrtprtd		;yes, mark this as write protected.
E9C6: C9      		ret	
E9C7: 77      	chkdir1:ld	(hl),a		;just set the byte.
E9C8: C9      		ret	
              	;
              	;   do a write to the directory of the current disk.
              	;
E9C9: CD9FE9  	dirwrite: call	setdir		;set checksum byte.
E9CC: CDE3E9  		call	dirdma		;set directory dma address.
E9CF: 0E01    		ld	c,1		;tell the bios to actually write.
E9D1: CDBBE7  		call	dowrite		;then do the write.
E9D4: C3DDE9  		jp	defdma
              	;
              	;   read from the directory.
              	;
E9D7: CDE3E9  	dirread:call	dirdma		;set the directory dma address.
E9DA: CDB5E7  		call	doread		;and read it.
              	;
              	;   routine to set the dma address to the users choice.
              	;
E9DD: 21B4F1  	defdma:	ld	hl,userdma	;reset the default dma address and return.
E9E0: C3E6E9  		jp	dirdma1
              	;
              	;   routine to set the dma address for directory work.
              	;
E9E3: 21BCF1  	dirdma:	ld	hl,dirbuf
              	;
              	;   set the dma address. on entry, (hl) points to
              	; word containing the desired dma address.
              	;
E9E6: 4E      	dirdma1:ld	c,(hl)
E9E7: 23      		inc	hl
E9E8: 46      		ld	b,(hl)		;setup (bc) and go to the bios to set it.
E9E9: C3D8F2  		jp	setdma
              	;
              	;   move the directory buffer into user's dma space.
              	;
E9EC: 2ABCF1  	movedir:ld	hl,(dirbuf)	;buffer is located here, and
E9EF: EB      		ex	de,hl
E9F0: 2AB4F1  		ld	hl,(userdma)	; put it here.
E9F3: 0E80    		ld	c,128		;this is its length.
E9F5: C352E7  		jp	de2hl		;move it now and return.
              	;
              	;   check (filepos) and set the zero flag if it equals 0ffffh.
              	;
E9F8: 21EDF1  	ckfilpos: ld	hl,filepos
E9FB: 7E      		ld	a,(hl)
E9FC: 23      		inc	hl
E9FD: BE      		cp	(hl)		;are both bytes the same?
E9FE: C0      		ret	nz
E9FF: 3C      		inc	a		;yes, but are they each 0ffh?
EA00: C9      		ret	
              	;
              	;   set location (filepos) to 0ffffh.
              	;
EA01: 21FFFF  	stfilpos: ld	hl,0ffffh
EA04: 22EDF1  		ld	(filepos),hl
EA07: C9      		ret	
              	;
              	;   move on to the next file position within the current
              	; directory buffer. if no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. enter with (c)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
EA08: 2ACBF1  	nxentry:ld	hl,(dirsize)	;get directory entry size limit.
EA0B: EB      		ex	de,hl
EA0C: 2AEDF1  		ld	hl,(filepos)	;get current count.
EA0F: 23      		inc	hl		;go on to the next one.
EA10: 22EDF1  		ld	(filepos),hl
EA13: CD98E9  		call	subhl		;(hl)=(dirsize)-(filepos)
EA16: D21CEA  		jp	nc,nxent1	;is there more room left?
EA19: C301EA  		jp	stfilpos	;no. set this flag and return.
EA1C: 3AEDF1  	nxent1:	ld	a,(filepos)	;get file position within directory.
EA1F: E603    		and	03h		;only look within this sector (only 4 entries fit).
EA21: 0605    		ld	b,5		;convert to relative position (32 bytes each).
EA23: 87      	nxent2:	add	a,a		;note that this is not efficient code.
EA24: 05      		dec	b		;5 'add a's would be better.
EA25: C223EA  		jp	nz,nxent2
EA28: 32ECF1  		ld	(fcbpos),a	;save it as position of fcb.
EA2B: B7      		or	a
EA2C: C0      		ret	nz		;return if we are within buffer.
EA2D: C5      		push	bc
EA2E: CDC6E7  		call	trksec		;we need the next directory sector.
EA31: CDD7E9  		call	dirread
EA34: C1      		pop	bc
EA35: C3A1E9  		jp	checkdir
              	;
              	;   routine to to get a bit from the disk space allocation
              	; map. it is returned in (a), bit position 0. on entry to here,
              	; set (bc) to the block number on the disk to check.
              	; on return, (d) will contain the original bit position for
              	; this block number and (hl) will point to the address for it.
              	;
EA38: 79      	ckbitmap: ld	a,c		;determine bit number of interest.
EA39: E607    		and	07h		;compute (d)=(e)=(c and 7)+1.
EA3B: 3C      		inc	a
EA3C: 5F      		ld	e,a		;save particular bit number.
EA3D: 57      		ld	d,a
              	;
              	;   compute (bc)=(bc)/8.
              	;
EA3E: 79      		ld	a,c
EA3F: 0F      		rrca			;now shift right 3 bits.
EA40: 0F      		rrca	
EA41: 0F      		rrca	
EA42: E61F    		and	1fh		;and clear bits 7,6,5.
EA44: 4F      		ld	c,a
EA45: 78      		ld	a,b
EA46: 87      		add	a,a		;now shift (b) into bits 7,6,5.
EA47: 87      		add	a,a
EA48: 87      		add	a,a
EA49: 87      		add	a,a
EA4A: 87      		add	a,a
EA4B: B1      		or	c		;and add in (c).
EA4C: 4F      		ld	c,a		;ok, (c) ha been completed.
EA4D: 78      		ld	a,b		;is there a better way of doing this?
EA4E: 0F      		rrca	
EA4F: 0F      		rrca	
EA50: 0F      		rrca	
EA51: E61F    		and	1fh
EA53: 47      		ld	b,a		;and now (b) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
EA54: 2AC2F1  		ld	hl,(alocvect)
EA57: 09      		add	hl,bc
EA58: 7E      		ld	a,(hl)		;now get correct byte.
EA59: 07      	ckbmap1:rlca			;get correct bit into position 0.
EA5A: 1D      		dec	e
EA5B: C259EA  		jp	nz,ckbmap1
EA5E: C9      		ret	
              	;
              	;   set or clear the bit map such that block number (bc) will be marked
              	; as used. on entry, if (e)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
EA5F: D5      	stbitmap: push	de
EA60: CD38EA  		call	ckbitmap	;get the byte of interest.
EA63: E6FE    		and	0feh		;clear the affected bit.
EA65: C1      		pop	bc
EA66: B1      		or	c		;and now set it acording to (c).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (a) contains the value, (d) contains the bit
              	; position (1-8), and (hl) points to the address within the
              	; space allocation table for this byte.
              	;
EA67: 0F      	stbmap1:rrca			;restore original bit position.
EA68: 15      		dec	d
EA69: C267EA  		jp	nz,stbmap1
EA6C: 77      		ld	(hl),a		;and stor byte in table.
EA6D: C9      		ret	
              	;
              	;   set/clear space used bits in allocation map for this file.
              	; on entry, (c)=1 to set the map and (c)=0 to clear it.
              	;
EA6E: CD61E9  	setfile:call	fcb2hl		;get address of fcb
EA71: 111000  		ld	de,16
EA74: 19      		add	hl,de		;get to block number bytes.
EA75: C5      		push	bc
EA76: 0E11    		ld	c,17		;check all 17 bytes (max) of table.
EA78: D1      	setfl1:	pop	de
EA79: 0D      		dec	c		;done all bytes yet?
EA7A: C8      		ret	z
EA7B: D5      		push	de
EA7C: 3AE0F1  		ld	a,(bigdisk)	;check disk size for 16 bit block numbers.
EA7F: B7      		or	a
EA80: CA8BEA  		jp	z,setfl2
EA83: C5      		push	bc		;only 8 bit numbers. set (bc) to this one.
EA84: E5      		push	hl
EA85: 4E      		ld	c,(hl)		;get low byte from table, always
EA86: 0600    		ld	b,0		;set high byte to zero.
EA88: C391EA  		jp	setfl3
EA8B: 0D      	setfl2:	dec	c		;for 16 bit block numbers, adjust counter.
EA8C: C5      		push	bc
EA8D: 4E      		ld	c,(hl)		;now get both the low and high bytes.
EA8E: 23      		inc	hl
EA8F: 46      		ld	b,(hl)
EA90: E5      		push	hl
EA91: 79      	setfl3:	ld	a,c		;block used?
EA92: B0      		or	b
EA93: CAA0EA  		jp	z,setfl4
EA96: 2AC9F1  		ld	hl,(dsksize)	;is this block number within the
EA99: 7D      		ld	a,l		;space on the disk?
EA9A: 91      		sub	c
EA9B: 7C      		ld	a,h
EA9C: 98      		sbc	a,b
EA9D: D45FEA  		call	nc,stbitmap	;yes, set the proper bit.
EAA0: E1      	setfl4:	pop	hl		;point to next block number in fcb.
EAA1: 23      		inc	hl
EAA2: C1      		pop	bc
EAA3: C378EA  		jp	setfl1
              	;
              	;   construct the space used allocation bit map for the active
              	; drive. if a file name starts with '$' and it is under the
              	; current user number, then (status) is set to minus 1. otherwise
              	; it is not set at all.
              	;
EAA6: 2AC9F1  	bitmap:	ld	hl,(dsksize)	;compute size of allocation table.
EAA9: 0E03    		ld	c,3
EAAB: CDEDE8  		call	shiftr		;(hl)=(hl)/8.
EAAE: 23      		inc	hl		;at lease 1 byte.
EAAF: 44      		ld	b,h
EAB0: 4D      		ld	c,l		;set (bc) to the allocation table length.
              	;
              	;   initialize the bitmap for this drive. right now, the first
              	; two bytes are specified by the disk parameter block. however
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. for example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
EAB1: 2AC2F1  		ld	hl,(alocvect)	;now zero out the table now.
EAB4: 3600    	bitmap1:ld	(hl),0
EAB6: 23      		inc	hl
EAB7: 0B      		dec	bc
EAB8: 78      		ld	a,b
EAB9: B1      		or	c
EABA: C2B4EA  		jp	nz,bitmap1
EABD: 2ACDF1  		ld	hl,(alloc0)	;get initial space used by directory.
EAC0: EB      		ex	de,hl
EAC1: 2AC2F1  		ld	hl,(alocvect)	;and put this into map.
EAC4: 73      		ld	(hl),e
EAC5: 23      		inc	hl
EAC6: 72      		ld	(hl),d
              	;
              	;   end of initialization portion.
              	;
EAC7: CDA4E7  		call	homedrv		;now home the drive.
EACA: 2AB6F1  		ld	hl,(scratch1)
EACD: 3603    		ld	(hl),3		;force next directory request to read
EACF: 23      		inc	hl		;in a sector.
EAD0: 3600    		ld	(hl),0
EAD2: CD01EA  		call	stfilpos	;clear initial file position also.
EAD5: 0EFF    	bitmap2:ld	c,0ffh		;read next file name in directory
EAD7: CD08EA  		call	nxentry		;and set checksum byte.
EADA: CDF8E9  		call	ckfilpos	;is there another file?
EADD: C8      		ret	z
EADE: CD61E9  		call	fcb2hl		;yes, get its address.
EAE1: 3EE5    		ld	a,0e5h
EAE3: BE      		cp	(hl)		;empty file entry?
EAE4: CAD5EA  		jp	z,bitmap2
EAE7: 3A44E7  		ld	a,(userno)	;no, correct user number?
EAEA: BE      		cp	(hl)
EAEB: C2F9EA  		jp	nz,bitmap3
EAEE: 23      		inc	hl
EAEF: 7E      		ld	a,(hl)		;yes, does name start with a '$'?
EAF0: D624    		sub	'$'
EAF2: C2F9EA  		jp	nz,bitmap3
EAF5: 3D      		dec	a		;yes, set atatus to minus one.
EAF6: 3248E7  		ld	(status),a
EAF9: 0E01    	bitmap3:ld	c,1		;now set this file's space as used in bit map.
EAFB: CD6EEA  		call	setfile
EAFE: CD8FE9  		call	chknmbr		;keep (scratch1) in bounds.
EB01: C3D5EA  		jp	bitmap2
              	;
              	;   set the status (status) and return.
              	;
EB04: 3AD7F1  	ststatus: ld	a,(fndstat)
EB07: C304E7  		jp	setstat
              	;
              	;   check extents in (a) and (c). set the zero flag if they
              	; are the same. the number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (extmask+1).
              	; no registers are modified.
              	;
EB0A: C5      	samext:	push	bc
EB0B: F5      		push	af
EB0C: 3AC8F1  		ld	a,(extmask)	;get extent mask and use it to
EB0F: 2F      		cpl			;to compare both extent numbers.
EB10: 47      		ld	b,a		;save resulting mask here.
EB11: 79      		ld	a,c		;mask first extent and save in (c).
EB12: A0      		and	b
EB13: 4F      		ld	c,a
EB14: F1      		pop	af		;now mask second extent and compare
EB15: A0      		and	b		;with the first one.
EB16: 91      		sub	c
EB17: E61F    		and	1fh		;(* only check buts 0-4 *)
EB19: C1      		pop	bc		;the zero flag is set if they are the same.
EB1A: C9      		ret			;restore (bc) and return.
              	;
              	;   search for the first occurence of a file name. on entry,
              	; register (c) should contain the number of bytes of the fcb
              	; that must match.
              	;
EB1B: 3EFF    	findfst:ld	a,0ffh
EB1D: 32D7F1  		ld	(fndstat),a
EB20: 21DBF1  		ld	hl,counter	;save character count.
EB23: 71      		ld	(hl),c
EB24: 2A46E7  		ld	hl,(params)	;get filename to match.
EB27: 22DCF1  		ld	(savefcb),hl	;and save.
EB2A: CD01EA  		call	stfilpos	;clear initial file position (set to 0ffffh).
EB2D: CDA4E7  		call	homedrv		;home the drive.
              	;
              	;   entry to locate the next occurence of a filename within the
              	; directory. the disk is not expected to have been changed. if
              	; it was, then it will be write protected.
              	;
EB30: 0E00    	findnxt:ld	c,0		;write protect the disk if changed.
EB32: CD08EA  		call	nxentry		;get next filename entry in directory.
EB35: CDF8E9  		call	ckfilpos	;is file position = 0ffffh?
EB38: CA97EB  		jp	z,fndnxt6	;yes, exit now then.
EB3B: 2ADCF1  		ld	hl,(savefcb)	;set (de) pointing to filename to match.
EB3E: EB      		ex	de,hl
EB3F: 1A      		ld	a,(de)
EB40: FEE5    		cp	0e5h		;empty directory entry?
EB42: CA4DEB  		jp	z,fndnxt1	;(* are we trying to reserect erased entries? *)
EB45: D5      		push	de
EB46: CD82E9  		call	morefls		;more files in directory?
EB49: D1      		pop	de
EB4A: D297EB  		jp	nc,fndnxt6	;no more. exit now.
EB4D: CD61E9  	fndnxt1:call	fcb2hl		;get address of this fcb in directory.
EB50: 3ADBF1  		ld	a,(counter)	;get number of bytes (characters) to check.
EB53: 4F      		ld	c,a
EB54: 0600    		ld	b,0		;initialize byte position counter.
EB56: 79      	fndnxt2:ld	a,c		;are we done with the compare?
EB57: B7      		or	a
EB58: CA86EB  		jp	z,fndnxt5
EB5B: 1A      		ld	a,(de)		;no, check next byte.
EB5C: FE3F    		cp	'?'		;don't care about this character?
EB5E: CA7FEB  		jp	z,fndnxt4
EB61: 78      		ld	a,b		;get bytes position in fcb.
EB62: FE0D    		cp	13		;don't care about the thirteenth byte either.
EB64: CA7FEB  		jp	z,fndnxt4
EB67: FE0C    		cp	12		;extent byte?
EB69: 1A      		ld	a,(de)
EB6A: CA76EB  		jp	z,fndnxt3
EB6D: 96      		sub	(hl)		;otherwise compare characters.
EB6E: E67F    		and	7fh
EB70: C230EB  		jp	nz,findnxt	;not the same, check next entry.
EB73: C37FEB  		jp	fndnxt4		;so far so good, keep checking.
EB76: C5      	fndnxt3:push	bc		;check the extent byte here.
EB77: 4E      		ld	c,(hl)
EB78: CD0AEB  		call	samext
EB7B: C1      		pop	bc
EB7C: C230EB  		jp	nz,findnxt	;not the same, look some more.
              	;
              	;   so far the names compare. bump pointers to the next byte
              	; and continue until all (c) characters have been checked.
              	;
EB7F: 13      	fndnxt4:inc	de		;bump pointers.
EB80: 23      		inc	hl
EB81: 04      		inc	b
EB82: 0D      		dec	c		;adjust character counter.
EB83: C356EB  		jp	fndnxt2
EB86: 3AEDF1  	fndnxt5:ld	a,(filepos)	;return the position of this entry.
EB89: E603    		and	03h
EB8B: 3248E7  		ld	(status),a
EB8E: 21D7F1  		ld	hl,fndstat
EB91: 7E      		ld	a,(hl)
EB92: 17      		rla	
EB93: D0      		ret	nc
EB94: AF      		xor	a
EB95: 77      		ld	(hl),a
EB96: C9      		ret	
              	;
              	;   filename was not found. set appropriate status.
              	;
EB97: CD01EA  	fndnxt6:call	stfilpos	;set (filepos) to 0ffffh.
EB9A: 3EFF    		ld	a,0ffh		;say not located.
EB9C: C304E7  		jp	setstat
              	;
              	;   erase files from the directory. only the first byte of the
              	; fcb will be affected. it is set to (e5).
              	;
EB9F: CD57E9  	erafile:call	chkwprt		;is disk write protected?
EBA2: 0E0C    		ld	c,12		;only compare file names.
EBA4: CD1BEB  		call	findfst		;get first file name.
EBA7: CDF8E9  	erafil1:call	ckfilpos	;any found?
EBAA: C8      		ret	z		;nope, we must be done.
EBAB: CD47E9  		call	chkrofl		;is file read only?
EBAE: CD61E9  		call	fcb2hl		;nope, get address of fcb and
EBB1: 36E5    		ld	(hl),0e5h	;set first byte to 'empty'.
EBB3: 0E00    		ld	c,0		;clear the space from the bit map.
EBB5: CD6EEA  		call	setfile
EBB8: CDC9E9  		call	dirwrite	;now write the directory sector back out.
EBBB: CD30EB  		call	findnxt		;find the next file name.
EBBE: C3A7EB  		jp	erafil1		;and repeat process.
              	;
              	;   look through the space allocation map (bit map) for the
              	; next available block. start searching at block number (bc-1).
              	; the search procedure is to look for an empty block that is
              	; before the starting block. if not empty, look at a later
              	; block number. in this way, we return the closest empty block
              	; on either side of the 'target' block number. this will speed
              	; access on random devices. for serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   on return, (de)= block number that is empty and (hl) =0
              	; if no empry block was found.
              	;
EBC1: 50      	fndspace: ld	d,b		;set (de) as the block that is checked.
EBC2: 59      		ld	e,c
              	;
              	;   look before target block. registers (bc) are used as the lower
              	; pointer and (de) as the upper pointer.
              	;
EBC3: 79      	fndspa1:ld	a,c		;is block 0 specified?
EBC4: B0      		or	b
EBC5: CAD4EB  		jp	z,fndspa2
EBC8: 0B      		dec	bc		;nope, check previous block.
EBC9: D5      		push	de
EBCA: C5      		push	bc
EBCB: CD38EA  		call	ckbitmap
EBCE: 1F      		rra			;is this block empty?
EBCF: D2EFEB  		jp	nc,fndspa3	;yes. use this.
              	;
              	;   note that the above logic gets the first block that it finds
              	; that is empty. thus a file could be written 'backward' making
              	; it very slow to access. this could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; this should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
EBD2: C1      		pop	bc		;nope, check some more.
EBD3: D1      		pop	de
              	;
              	;   now look after target block.
              	;
EBD4: 2AC9F1  	fndspa2:ld	hl,(dsksize)	;is block (de) within disk limits?
EBD7: 7B      		ld	a,e
EBD8: 95      		sub	l
EBD9: 7A      		ld	a,d
EBDA: 9C      		sbc	a,h
EBDB: D2F7EB  		jp	nc,fndspa4
EBDE: 13      		inc	de		;yes, move on to next one.
EBDF: C5      		push	bc
EBE0: D5      		push	de
EBE1: 42      		ld	b,d
EBE2: 4B      		ld	c,e
EBE3: CD38EA  		call	ckbitmap	;check it.
EBE6: 1F      		rra			;empty?
EBE7: D2EFEB  		jp	nc,fndspa3
EBEA: D1      		pop	de		;nope, continue searching.
EBEB: C1      		pop	bc
EBEC: C3C3EB  		jp	fndspa1
              	;
              	;   empty block found. set it as used and return with (hl)
              	; pointing to it (true?).
              	;
EBEF: 17      	fndspa3:rla			;reset byte.
EBF0: 3C      		inc	a		;and set bit 0.
EBF1: CD67EA  		call	stbmap1		;update bit map.
EBF4: E1      		pop	hl		;set return registers.
EBF5: D1      		pop	de
EBF6: C9      		ret	
              	;
              	;   free block was not found. if (bc) is not zero, then we have
              	; not checked all of the disk space.
              	;
EBF7: 79      	fndspa4:ld	a,c
EBF8: B0      		or	b
EBF9: C2C3EB  		jp	nz,fndspa1
EBFC: 210000  		ld	hl,0		;set 'not found' status.
EBFF: C9      		ret	
              	;
              	;   move a complete fcb entry into the directory and write it.
              	;
EC00: 0E00    	fcbset:	ld	c,0
EC02: 1E20    		ld	e,32		;length of each entry.
              	;
              	;   move (e) bytes from the fcb pointed to by (params) into
              	; fcb in directory starting at relative byte (c). this updated
              	; directory buffer is then written to the disk.
              	;
EC04: D5      	update:	push	de
EC05: 0600    		ld	b,0		;set (bc) to relative byte position.
EC07: 2A46E7  		ld	hl,(params)	;get address of fcb.
EC0A: 09      		add	hl,bc		;compute starting byte.
EC0B: EB      		ex	de,hl
EC0C: CD61E9  		call	fcb2hl		;get address of fcb to update in directory.
EC0F: C1      		pop	bc		;set (c) to number of bytes to change.
EC10: CD52E7  		call	de2hl
EC13: CDC6E7  	update1:call	trksec		;determine the track and sector affected.
EC16: C3C9E9  		jp	dirwrite	;then write this sector out.
              	;
              	;   routine to change the name of all files on the disk with a
              	; specified name. the fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
EC19: CD57E9  	chgnames: call	chkwprt		;check for a write protected disk.
EC1C: 0E0C    		ld	c,12		;match first 12 bytes of fcb only.
EC1E: CD1BEB  		call	findfst		;get first name.
EC21: 2A46E7  		ld	hl,(params)	;get address of fcb.
EC24: 7E      		ld	a,(hl)		;get user number.
EC25: 111000  		ld	de,16		;move over to desired name.
EC28: 19      		add	hl,de
EC29: 77      		ld	(hl),a		;keep same user number.
EC2A: CDF8E9  	chgnam1:call	ckfilpos	;any matching file found?
EC2D: C8      		ret	z		;no, we must be done.
EC2E: CD47E9  		call	chkrofl		;check for read only file.
EC31: 0E10    		ld	c,16		;start 16 bytes into fcb.
EC33: 1E0C    		ld	e,12		;and update the first 12 bytes of directory.
EC35: CD04EC  		call	update
EC38: CD30EB  		call	findnxt		;get te next file name.
EC3B: C32AEC  		jp	chgnam1		;and continue.
              	;
              	;   update a files attributes. the procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). no other changes
              	; are made.
              	;
EC3E: 0E0C    	saveattr: ld	c,12		;match first 12 bytes.
EC40: CD1BEB  		call	findfst		;look for first filename.
EC43: CDF8E9  	savatr1:call	ckfilpos	;was one found?
EC46: C8      		ret	z		;nope, we must be done.
EC47: 0E00    		ld	c,0		;yes, update the first 12 bytes now.
EC49: 1E0C    		ld	e,12
EC4B: CD04EC  		call	update		;update filename and write directory.
EC4E: CD30EB  		call	findnxt		;and get the next file.
EC51: C343EC  		jp	savatr1		;then continue until done.
              	;
              	;  open a file (name specified in fcb).
              	;
EC54: 0E0F    	openit:	ld	c,15		;compare the first 15 bytes.
EC56: CD1BEB  		call	findfst		;get the first one in directory.
EC59: CDF8E9  		call	ckfilpos	;any at all?
EC5C: C8      		ret	z
EC5D: CDA9E8  	openit1:call	setext		;point to extent byte within users fcb.
EC60: 7E      		ld	a,(hl)		;and get it.
EC61: F5      		push	af		;save it and address.
EC62: E5      		push	hl
EC63: CD61E9  		call	fcb2hl		;point to fcb in directory.
EC66: EB      		ex	de,hl
EC67: 2A46E7  		ld	hl,(params)	;this is the users copy.
EC6A: 0E20    		ld	c,32		;move it into users space.
EC6C: D5      		push	de
EC6D: CD52E7  		call	de2hl
EC70: CD7BE9  		call	sets2b7		;set bit 7 in 's2' byte (unmodified).
EC73: D1      		pop	de		;now get the extent byte from this fcb.
EC74: 210C00  		ld	hl,12
EC77: 19      		add	hl,de
EC78: 4E      		ld	c,(hl)		;into (c).
EC79: 210F00  		ld	hl,15		;now get the record count byte into (b).
EC7C: 19      		add	hl,de
EC7D: 46      		ld	b,(hl)
EC7E: E1      		pop	hl		;keep the same extent as the user had originally.
EC7F: F1      		pop	af
EC80: 77      		ld	(hl),a
EC81: 79      		ld	a,c		;is it the same as in the directory fcb?
EC82: BE      		cp	(hl)
EC83: 78      		ld	a,b		;if yes, then use the same record count.
EC84: CA8EEC  		jp	z,openit2
EC87: 3E00    		ld	a,0		;if the user specified an extent greater than
EC89: DA8EEC  		jp	c,openit2	;the one in the directory, then set record count to 0.
EC8C: 3E80    		ld	a,128		;otherwise set to maximum.
EC8E: 2A46E7  	openit2:ld	hl,(params)	;set record count in users fcb to (a).
EC91: 110F00  		ld	de,15
EC94: 19      		add	hl,de		;compute relative position.
EC95: 77      		ld	(hl),a		;and set the record count.
EC96: C9      		ret	
              	;
              	;   move two bytes from (de) to (hl) if (and only if) (hl)
              	; point to a zero value (16 bit).
              	;   return with zero flag set it (de) was moved. registers (de)
              	; and (hl) are not changed. however (a) is.
              	;
EC97: 7E      	moveword: ld	a,(hl)		;check for a zero word.
EC98: 23      		inc	hl
EC99: B6      		or	(hl)		;both bytes zero?
EC9A: 2B      		dec	hl
EC9B: C0      		ret	nz		;nope, just return.
EC9C: 1A      		ld	a,(de)		;yes, move two bytes from (de) into
EC9D: 77      		ld	(hl),a		;this zero space.
EC9E: 13      		inc	de
EC9F: 23      		inc	hl
ECA0: 1A      		ld	a,(de)
ECA1: 77      		ld	(hl),a
ECA2: 1B      		dec	de		;don't disturb these registers.
ECA3: 2B      		dec	hl
ECA4: C9      		ret	
              	;
              	;   get here to close a file specified by (fcb).
              	;
ECA5: AF      	closeit:xor	a		;clear status and file position bytes.
ECA6: 3248E7  		ld	(status),a
ECA9: 32EDF1  		ld	(filepos),a
ECAC: 32EEF1  		ld	(filepos+1),a
ECAF: CD21E9  		call	getwprt		;get write protect bit for this drive.
ECB2: C0      		ret	nz		;just return if it is set.
ECB3: CD6CE9  		call	gets2		;else get the 's2' byte.
ECB6: E680    		and	80h		;and look at bit 7 (file unmodified?).
ECB8: C0      		ret	nz		;just return if set.
ECB9: 0E0F    		ld	c,15		;else look up this file in directory.
ECBB: CD1BEB  		call	findfst
ECBE: CDF8E9  		call	ckfilpos	;was it found?
ECC1: C8      		ret	z		;just return if not.
ECC2: 011000  		ld	bc,16		;set (hl) pointing to records used section.
ECC5: CD61E9  		call	fcb2hl
ECC8: 09      		add	hl,bc
ECC9: EB      		ex	de,hl
ECCA: 2A46E7  		ld	hl,(params)	;do the same for users specified fcb.
ECCD: 09      		add	hl,bc
ECCE: 0E10    		ld	c,16		;this many bytes are present in this extent.
ECD0: 3AE0F1  	closeit1: ld	a,(bigdisk)	;8 or 16 bit record numbers?
ECD3: B7      		or	a
ECD4: CAEBEC  		jp	z,closeit4
ECD7: 7E      		ld	a,(hl)		;just 8 bit. get one from users fcb.
ECD8: B7      		or	a
ECD9: 1A      		ld	a,(de)		;now get one from directory fcb.
ECDA: C2DEEC  		jp	nz,closeit2
ECDD: 77      		ld	(hl),a		;users byte was zero. update from directory.
ECDE: B7      	closeit2: or	a
ECDF: C2E4EC  		jp	nz,closeit3
ECE2: 7E      		ld	a,(hl)		;directories byte was zero, update from users fcb.
ECE3: 12      		ld	(de),a
ECE4: BE      	closeit3: cp	(hl)		;if neither one of these bytes were zero,
ECE5: C222ED  		jp	nz,closeit7	;then close error if they are not the same.
ECE8: C300ED  		jp	closeit5	;ok so far, get to next byte in fcbs.
ECEB: CD97EC  	closeit4: call	moveword	;update users fcb if it is zero.
ECEE: EB      		ex	de,hl
ECEF: CD97EC  		call	moveword	;update directories fcb if it is zero.
ECF2: EB      		ex	de,hl
ECF3: 1A      		ld	a,(de)		;if these two values are no different,
ECF4: BE      		cp	(hl)		;then a close error occured.
ECF5: C222ED  		jp	nz,closeit7
ECF8: 13      		inc	de		;check second byte.
ECF9: 23      		inc	hl
ECFA: 1A      		ld	a,(de)
ECFB: BE      		cp	(hl)
ECFC: C222ED  		jp	nz,closeit7
ECFF: 0D      		dec	c		;remember 16 bit values.
ED00: 13      	closeit5: inc	de		;bump to next item in table.
ED01: 23      		inc	hl
ED02: 0D      		dec	c		;there are 16 entries only.
ED03: C2D0EC  		jp	nz,closeit1	;continue if more to do.
ED06: 01ECFF  		ld	bc,0ffech	;backup 20 places (extent byte).
ED09: 09      		add	hl,bc
ED0A: EB      		ex	de,hl
ED0B: 09      		add	hl,bc
ED0C: 1A      		ld	a,(de)
ED0D: BE      		cp	(hl)		;directory's extent already greater than the
ED0E: DA1AED  		jp	c,closeit6	;users extent?
ED11: 77      		ld	(hl),a		;no, update directory extent.
ED12: 010300  		ld	bc,3		;and update the record count byte in
ED15: 09      		add	hl,bc		;directories fcb.
ED16: EB      		ex	de,hl
ED17: 09      		add	hl,bc
ED18: 7E      		ld	a,(hl)		;get from user.
ED19: 12      		ld	(de),a		;and put in directory.
ED1A: 3EFF    	closeit6: ld	a,0ffh		;set 'was open and is now closed' byte.
ED1C: 32D5F1  		ld	(closeflg),a
ED1F: C313EC  		jp	update1		;update the directory now.
ED22: 2148E7  	closeit7: ld	hl,status	;set return status and then return.
ED25: 35      		dec	(hl)
ED26: C9      		ret	
              	;
              	;   routine to get the next empty space in the directory. it
              	; will then be cleared for use.
              	;
ED27: CD57E9  	getempty: call	chkwprt		;make sure disk is not write protected.
ED2A: 2A46E7  		ld	hl,(params)	;save current parameters (fcb).
ED2D: E5      		push	hl
ED2E: 21AFF1  		ld	hl,emptyfcb	;use special one for empty space.
ED31: 2246E7  		ld	(params),hl
ED34: 0E01    		ld	c,1		;search for first empty spot in directory.
ED36: CD1BEB  		call	findfst		;(* only check first byte *)
ED39: CDF8E9  		call	ckfilpos	;none?
ED3C: E1      		pop	hl
ED3D: 2246E7  		ld	(params),hl	;restore original fcb address.
ED40: C8      		ret	z		;return if no more space.
ED41: EB      		ex	de,hl
ED42: 210F00  		ld	hl,15		;point to number of records for this file.
ED45: 19      		add	hl,de
ED46: 0E11    		ld	c,17		;and clear all of this space.
ED48: AF      		xor	a
ED49: 77      	getmt1:	ld	(hl),a
ED4A: 23      		inc	hl
ED4B: 0D      		dec	c
ED4C: C249ED  		jp	nz,getmt1
ED4F: 210D00  		ld	hl,13		;clear the 's1' byte also.
ED52: 19      		add	hl,de
ED53: 77      		ld	(hl),a
ED54: CD8FE9  		call	chknmbr		;keep (scratch1) within bounds.
ED57: CD00EC  		call	fcbset		;write out this fcb entry to directory.
ED5A: C37BE9  		jp	sets2b7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   routine to close the current extent and open the next one
              	; for reading.
              	;
ED5D: AF      	getnext:xor	a
ED5E: 32D5F1  		ld	(closeflg),a	;clear close flag.
ED61: CDA5EC  		call	closeit		;close this extent.
ED64: CDF8E9  		call	ckfilpos
ED67: C8      		ret	z		;not there???
ED68: 2A46E7  		ld	hl,(params)	;get extent byte.
ED6B: 010C00  		ld	bc,12
ED6E: 09      		add	hl,bc
ED6F: 7E      		ld	a,(hl)		;and increment it.
ED70: 3C      		inc	a
ED71: E61F    		and	1fh		;keep within range 0-31.
ED73: 77      		ld	(hl),a
ED74: CA86ED  		jp	z,gtnext1	;overflow?
ED77: 47      		ld	b,a		;mask extent byte.
ED78: 3AC8F1  		ld	a,(extmask)
ED7B: A0      		and	b
ED7C: 21D5F1  		ld	hl,closeflg	;check close flag (0ffh is ok).
ED7F: A6      		and	(hl)
ED80: CA91ED  		jp	z,gtnext2	;if zero, we must read in next extent.
ED83: C3AFED  		jp	gtnext3		;else, it is already in memory.
ED86: 010200  	gtnext1:ld	bc,2		;point to the 's2' byte.
ED89: 09      		add	hl,bc
ED8A: 34      		inc	(hl)		;and bump it.
ED8B: 7E      		ld	a,(hl)		;too many extents?
ED8C: E60F    		and	0fh
ED8E: CAB9ED  		jp	z,gtnext5	;yes, set error code.
              	;
              	;   get here to open the next extent.
              	;
ED91: 0E0F    	gtnext2:ld	c,15		;set to check first 15 bytes of fcb.
ED93: CD1BEB  		call	findfst		;find the first one.
ED96: CDF8E9  		call	ckfilpos	;none available?
ED99: C2AFED  		jp	nz,gtnext3
ED9C: 3AD6F1  		ld	a,(rdwrtflg)	;no extent present. can we open an empty one?
ED9F: 3C      		inc	a		;0ffh means reading (so not possible).
EDA0: CAB9ED  		jp	z,gtnext5	;or an error.
EDA3: CD27ED  		call	getempty	;we are writing, get an empty entry.
EDA6: CDF8E9  		call	ckfilpos	;none?
EDA9: CAB9ED  		jp	z,gtnext5	;error if true.
EDAC: C3B2ED  		jp	gtnext4		;else we are almost done.
EDAF: CD5DEC  	gtnext3:call	openit1		;open this extent.
EDB2: CDBEE8  	gtnext4:call	strdata		;move in updated data (rec #, extent #, etc.)
EDB5: AF      		xor	a		;clear status and return.
EDB6: C304E7  		jp	setstat
              	;
              	;   error in extending the file. too many extents were needed
              	; or not enough space on the disk.
              	;
EDB9: CD08E7  	gtnext5:call	ioerr1		;set error code, clear bit 7 of 's2'
EDBC: C37BE9  		jp	sets2b7		;so this is not written on a close.
              	;
              	;   read a sequential file.
              	;
EDBF: 3E01    	rdseq:	ld	a,1		;set sequential access mode.
EDC1: 32D8F1  		ld	(mode),a
EDC4: 3EFF    	rdseq1:	ld	a,0ffh		;don't allow reading unwritten space.
EDC6: 32D6F1  		ld	(rdwrtflg),a
EDC9: CDBEE8  		call	strdata		;put rec# and ext# into fcb.
EDCC: 3AE6F1  		ld	a,(savnrec)	;get next record to read.
EDCF: 21E4F1  		ld	hl,savnxt	;get number of records in extent.
EDD2: BE      		cp	(hl)		;within this extent?
EDD3: DAE9ED  		jp	c,rdseq2
EDD6: FE80    		cp	128		;no. is this extent fully used?
EDD8: C2FEED  		jp	nz,rdseq3	;no. end-of-file.
EDDB: CD5DED  		call	getnext		;yes, open the next one.
EDDE: AF      		xor	a		;reset next record to read.
EDDF: 32E6F1  		ld	(savnrec),a
EDE2: 3A48E7  		ld	a,(status)	;check on open, successful?
EDE5: B7      		or	a
EDE6: C2FEED  		jp	nz,rdseq3	;no, error.
EDE9: CD7AE8  	rdseq2:	call	comblk		;ok. compute block number to read.
EDEC: CD87E8  		call	chkblk		;check it. within bounds?
EDEF: CAFEED  		jp	z,rdseq3	;no, error.
EDF2: CD8DE8  		call	logical		;convert (blknmbr) to logical sector (128 byte).
EDF5: CDD4E7  		call	trksec1		;set the track and sector for this block #.
EDF8: CDB5E7  		call	doread		;and read it.
EDFB: C3D5E8  		jp	setnrec		;and set the next record to be accessed.
              	;
              	;   read error occured. set status and return.
              	;
EDFE: C308E7  	rdseq3:	jp	ioerr1
              	;
              	;   write the next sequential record.
              	;
EE01: 3E01    	wtseq:	ld	a,1		;set sequential access mode.
EE03: 32D8F1  		ld	(mode),a
EE06: 3E00    	wtseq1:	ld	a,0		;allow an addition empty extent to be opened.
EE08: 32D6F1  		ld	(rdwrtflg),a
EE0B: CD57E9  		call	chkwprt		;check write protect status.
EE0E: 2A46E7  		ld	hl,(params)
EE11: CD4AE9  		call	ckrof1		;check for read only file, (hl) already set to fcb.
EE14: CDBEE8  		call	strdata		;put updated data into fcb.
EE17: 3AE6F1  		ld	a,(savnrec)	;get record number to write.
EE1A: FE80    		cp	128		;within range?
EE1C: D208E7  		jp	nc,ioerr1	;no, error(?).
EE1F: CD7AE8  		call	comblk		;compute block number.
EE22: CD87E8  		call	chkblk		;check number.
EE25: 0E00    		ld	c,0		;is there one to write to?
EE27: C271EE  		jp	nz,wtseq6	;yes, go do it.
EE2A: CD41E8  		call	getblock	;get next block number within fcb to use.
EE2D: 32DAF1  		ld	(relblock),a	;and save.
EE30: 010000  		ld	bc,0		;start looking for space from the start
EE33: B7      		or	a		;if none allocated as yet.
EE34: CA3EEE  		jp	z,wtseq2
EE37: 4F      		ld	c,a		;extract previous block number from fcb
EE38: 0B      		dec	bc		;so we can be closest to it.
EE39: CD61E8  		call	extblk
EE3C: 44      		ld	b,h
EE3D: 4D      		ld	c,l
EE3E: CDC1EB  	wtseq2:	call	fndspace	;find the next empty block nearest number (bc).
EE41: 7D      		ld	a,l		;check for a zero number.
EE42: B4      		or	h
EE43: C24BEE  		jp	nz,wtseq3
EE46: 3E02    		ld	a,2		;no more space?
EE48: C304E7  		jp	setstat
EE4B: 22E8F1  	wtseq3:	ld	(blknmbr),hl	;save block number to access.
EE4E: EB      		ex	de,hl		;put block number into (de).
EE4F: 2A46E7  		ld	hl,(params)	;now we must update the fcb for this
EE52: 011000  		ld	bc,16		;newly allocated block.
EE55: 09      		add	hl,bc
EE56: 3AE0F1  		ld	a,(bigdisk)	;8 or 16 bit block numbers?
EE59: B7      		or	a
EE5A: 3ADAF1  		ld	a,(relblock)	;(* update this entry *)
EE5D: CA67EE  		jp	z,wtseq4	;zero means 16 bit ones.
EE60: CD67E9  		call	adda2hl		;(hl)=(hl)+(a)
EE63: 73      		ld	(hl),e		;store new block number.
EE64: C36FEE  		jp	wtseq5
EE67: 4F      	wtseq4:	ld	c,a		;compute spot in this 16 bit table.
EE68: 0600    		ld	b,0
EE6A: 09      		add	hl,bc
EE6B: 09      		add	hl,bc
EE6C: 73      		ld	(hl),e		;stuff block number (de) there.
EE6D: 23      		inc	hl
EE6E: 72      		ld	(hl),d
EE6F: 0E02    	wtseq5:	ld	c,2		;set (c) to indicate writing to un-used disk space.
EE71: 3A48E7  	wtseq6:	ld	a,(status)	;are we ok so far?
EE74: B7      		or	a
EE75: C0      		ret	nz
EE76: C5      		push	bc		;yes, save write flag for bios (register c).
EE77: CD8DE8  		call	logical		;convert (blknmbr) over to loical sectors.
EE7A: 3AD8F1  		ld	a,(mode)	;get access mode flag (1=sequential,
EE7D: 3D      		dec	a		;0=random, 2=special?).
EE7E: 3D      		dec	a
EE7F: C2BEEE  		jp	nz,wtseq9
              	;
              	;   special random i/o from function #40. maybe for m/pm, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
EE82: C1      		pop	bc
EE83: C5      		push	bc
EE84: 79      		ld	a,c		;get write status flag (2=writing unused space).
EE85: 3D      		dec	a
EE86: 3D      		dec	a
EE87: C2BEEE  		jp	nz,wtseq9
EE8A: E5      		push	hl
EE8B: 2ABCF1  		ld	hl,(dirbuf)	;zero out the directory buffer.
EE8E: 57      		ld	d,a		;note that (a) is zero here.
EE8F: 77      	wtseq7:	ld	(hl),a
EE90: 23      		inc	hl
EE91: 14      		inc	d		;do 128 bytes.
EE92: F28FEE  		jp	p,wtseq7
EE95: CDE3E9  		call	dirdma		;tell the bios the dma address for directory access.
EE98: 2AEAF1  		ld	hl,(logsect)	;get sector that starts current block.
EE9B: 0E02    		ld	c,2		;set 'writing to unused space' flag.
EE9D: 22E8F1  	wtseq8:	ld	(blknmbr),hl	;save sector to write.
EEA0: C5      		push	bc
EEA1: CDD4E7  		call	trksec1		;determine its track and sector numbers.
EEA4: C1      		pop	bc
EEA5: CDBBE7  		call	dowrite		;now write out 128 bytes of zeros.
EEA8: 2AE8F1  		ld	hl,(blknmbr)	;get sector number.
EEAB: 0E00    		ld	c,0		;set normal write flag.
EEAD: 3AC7F1  		ld	a,(blkmask)	;determine if we have written the entire
EEB0: 47      		ld	b,a		;physical block.
EEB1: A5      		and	l
EEB2: B8      		cp	b
EEB3: 23      		inc	hl		;prepare for the next one.
EEB4: C29DEE  		jp	nz,wtseq8	;continue until (blkmask+1) sectors written.
EEB7: E1      		pop	hl		;reset next sector number.
EEB8: 22E8F1  		ld	(blknmbr),hl
EEBB: CDDDE9  		call	defdma		;and reset dma address.
              	;
              	;   normal disk write. set the desired track and sector then
              	; do the actual write.
              	;
EEBE: CDD4E7  	wtseq9:	call	trksec1		;determine track and sector for this write.
EEC1: C1      		pop	bc		;get write status flag.
EEC2: C5      		push	bc
EEC3: CDBBE7  		call	dowrite		;and write this out.
EEC6: C1      		pop	bc
EEC7: 3AE6F1  		ld	a,(savnrec)	;get number of records in file.
EECA: 21E4F1  		ld	hl,savnxt	;get last record written.
EECD: BE      		cp	(hl)
EECE: DAD5EE  		jp	c,wtseq10
EED1: 77      		ld	(hl),a		;we have to update record count.
EED2: 34      		inc	(hl)
EED3: 0E02    		ld	c,2
              	;
              	;*   this area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the bios.
              	;
EED5: 00      	wtseq10:nop			;was 'dcr c'
EED6: 00      		nop			;was 'dcr c'
EED7: 210000  		ld	hl,0		;was 'jnz wtseq99'
              	;
              	; *   end of patch.
              	;
EEDA: F5      		push	af
EEDB: CD6CE9  		call	gets2		;set 'extent written to' flag.
EEDE: E67F    		and	7fh		;(* clear bit 7 *)
EEE0: 77      		ld	(hl),a
EEE1: F1      		pop	af		;get record count for this extent.
EEE2: FE7F    	wtseq99:cp	127		;is it full?
EEE4: C203EF  		jp	nz,wtseq12
EEE7: 3AD8F1  		ld	a,(mode)	;yes, are we in sequential mode?
EEEA: FE01    		cp	1
EEEC: C203EF  		jp	nz,wtseq12
EEEF: CDD5E8  		call	setnrec		;yes, set next record number.
EEF2: CD5DED  		call	getnext		;and get next empty space in directory.
EEF5: 2148E7  		ld	hl,status	;ok?
EEF8: 7E      		ld	a,(hl)
EEF9: B7      		or	a
EEFA: C201EF  		jp	nz,wtseq11
EEFD: 3D      		dec	a		;yes, set record count to -1.
EEFE: 32E6F1  		ld	(savnrec),a
EF01: 3600    	wtseq11:ld	(hl),0		;clear status.
EF03: C3D5E8  	wtseq12:jp	setnrec		;set next record to access.
              	;
              	;   for random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. these bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   on entry, register (c) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. otherwise,
              	; another extent will be opened (for writing) if required.
              	;
EF06: AF      	position: xor	a		;set random i/o flag.
EF07: 32D8F1  		ld	(mode),a
              	;
              	;   special entry (function #40). m/pm ?
              	;
EF0A: C5      	positn1:push	bc		;save read/write flag.
EF0B: 2A46E7  		ld	hl,(params)	;get address of fcb.
EF0E: EB      		ex	de,hl
EF0F: 212100  		ld	hl,33		;now get byte 'r0'.
EF12: 19      		add	hl,de
EF13: 7E      		ld	a,(hl)
EF14: E67F    		and	7fh		;keep bits 0-6 for the record number to access.
EF16: F5      		push	af
EF17: 7E      		ld	a,(hl)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
EF18: 17      		rla	
EF19: 23      		inc	hl
EF1A: 7E      		ld	a,(hl)
EF1B: 17      		rla	
EF1C: E61F    		and	1fh		;and save this in bits 0-4 of (c).
EF1E: 4F      		ld	c,a		;this is the extent byte.
EF1F: 7E      		ld	a,(hl)		;now get the extra extent byte.
EF20: 1F      		rra	
EF21: 1F      		rra	
EF22: 1F      		rra	
EF23: 1F      		rra	
EF24: E60F    		and	0fh
EF26: 47      		ld	b,a		;and save it in (b).
EF27: F1      		pop	af		;get record number back to (a).
EF28: 23      		inc	hl		;check overflow byte 'r2'.
EF29: 6E      		ld	l,(hl)
EF2A: 2C      		inc	l
EF2B: 2D      		dec	l
EF2C: 2E06    		ld	l,6		;prepare for error.
EF2E: C28EEF  		jp	nz,positn5	;out of disk space error.
EF31: 212000  		ld	hl,32		;store record number into fcb.
EF34: 19      		add	hl,de
EF35: 77      		ld	(hl),a
EF36: 210C00  		ld	hl,12		;and now check the extent byte.
EF39: 19      		add	hl,de
EF3A: 79      		ld	a,c
EF3B: 96      		sub	(hl)		;same extent as before?
EF3C: C24AEF  		jp	nz,positn2
EF3F: 210E00  		ld	hl,14		;yes, check extra extent byte 's2' also.
EF42: 19      		add	hl,de
EF43: 78      		ld	a,b
EF44: 96      		sub	(hl)
EF45: E67F    		and	7fh
EF47: CA82EF  		jp	z,positn3	;same, we are almost done then.
              	;
              	;  get here when another extent is required.
              	;
EF4A: C5      	positn2:push	bc
EF4B: D5      		push	de
EF4C: CDA5EC  		call	closeit		;close current extent.
EF4F: D1      		pop	de
EF50: C1      		pop	bc
EF51: 2E03    		ld	l,3		;prepare for error.
EF53: 3A48E7  		ld	a,(status)
EF56: 3C      		inc	a
EF57: CA87EF  		jp	z,positn4	;close error.
EF5A: 210C00  		ld	hl,12		;put desired extent into fcb now.
EF5D: 19      		add	hl,de
EF5E: 71      		ld	(hl),c
EF5F: 210E00  		ld	hl,14		;and store extra extent byte 's2'.
EF62: 19      		add	hl,de
EF63: 70      		ld	(hl),b
EF64: CD54EC  		call	openit		;try and get this extent.
EF67: 3A48E7  		ld	a,(status)	;was it there?
EF6A: 3C      		inc	a
EF6B: C282EF  		jp	nz,positn3
EF6E: C1      		pop	bc		;no. can we create a new one (writing?).
EF6F: C5      		push	bc
EF70: 2E04    		ld	l,4		;prepare for error.
EF72: 0C      		inc	c
EF73: CA87EF  		jp	z,positn4	;nope, reading unwritten space error.
EF76: CD27ED  		call	getempty	;yes we can, try to find space.
EF79: 2E05    		ld	l,5		;prepare for error.
EF7B: 3A48E7  		ld	a,(status)
EF7E: 3C      		inc	a
EF7F: CA87EF  		jp	z,positn4	;out of space?
              	;
              	;   normal return location. clear error code and return.
              	;
EF82: C1      	positn3:pop	bc		;restore stack.
EF83: AF      		xor	a		;and clear error code byte.
EF84: C304E7  		jp	setstat
              	;
              	;   error. set the 's2' byte to indicate this (why?).
              	;
EF87: E5      	positn4:push	hl
EF88: CD6CE9  		call	gets2
EF8B: 36C0    		ld	(hl),0c0h
EF8D: E1      		pop	hl
              	;
              	;   return with error code (presently in l).
              	;
EF8E: C1      	positn5:pop	bc
EF8F: 7D      		ld	a,l		;get error code.
EF90: 3248E7  		ld	(status),a
EF93: C37BE9  		jp	sets2b7
              	;
              	;   read a random record.
              	;
EF96: 0EFF    	readran:ld	c,0ffh		;set 'read' status.
EF98: CD06EF  		call	position	;position the file to proper record.
EF9B: CCC4ED  		call	z,rdseq1	;and read it as usual (if no errors).
EF9E: C9      		ret	
              	;
              	;   write to a random record.
              	;
EF9F: 0E00    	writeran: ld	c,0		;set 'writing' flag.
EFA1: CD06EF  		call	position	;position the file to proper record.
EFA4: CC06EE  		call	z,wtseq1	;and write as usual (if no errors).
EFA7: C9      		ret	
              	;
              	;   compute the random record number. enter with (hl) pointing
              	; to a fcb an (de) contains a relative location of a record
              	; number. on exit, (c) contains the 'r0' byte, (b) the 'r1'
              	; byte, and (a) the 'r2' byte.
              	;
              	;   on return, the zero flag is set if the record is within
              	; bounds. otherwise, an overflow occured.
              	;
EFA8: EB      	comprand: ex	de,hl		;save fcb pointer in (de).
EFA9: 19      		add	hl,de		;compute relative position of record #.
EFAA: 4E      		ld	c,(hl)		;get record number into (bc).
EFAB: 0600    		ld	b,0
EFAD: 210C00  		ld	hl,12		;now get extent.
EFB0: 19      		add	hl,de
EFB1: 7E      		ld	a,(hl)		;compute (bc)=(record #)+(extent)*128.
EFB2: 0F      		rrca			;move lower bit into bit 7.
EFB3: E680    		and	80h		;and ignore all other bits.
EFB5: 81      		add	a,c		;add to our record number.
EFB6: 4F      		ld	c,a
EFB7: 3E00    		ld	a,0		;take care of any carry.
EFB9: 88      		adc	a,b
EFBA: 47      		ld	b,a
EFBB: 7E      		ld	a,(hl)		;now get the upper bits of extent into
EFBC: 0F      		rrca			;bit positions 0-3.
EFBD: E60F    		and	0fh		;and ignore all others.
EFBF: 80      		add	a,b		;add this in to 'r1' byte.
EFC0: 47      		ld	b,a
EFC1: 210E00  		ld	hl,14		;get the 's2' byte (extra extent).
EFC4: 19      		add	hl,de
EFC5: 7E      		ld	a,(hl)
EFC6: 87      		add	a,a		;and shift it left 4 bits (bits 4-7).
EFC7: 87      		add	a,a
EFC8: 87      		add	a,a
EFC9: 87      		add	a,a
EFCA: F5      		push	af		;save carry flag (bit 0 of flag byte).
EFCB: 80      		add	a,b		;now add extra extent into 'r1'.
EFCC: 47      		ld	b,a
EFCD: F5      		push	af		;and save carry (overflow byte 'r2').
EFCE: E1      		pop	hl		;bit 0 of (l) is the overflow indicator.
EFCF: 7D      		ld	a,l
EFD0: E1      		pop	hl		;and same for first carry flag.
EFD1: B5      		or	l		;either one of these set?
EFD2: E601    		and	01h		;only check the carry flags.
EFD4: C9      		ret	
              	;
              	;   routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; this reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. this is used to compute the space used
              	; by a random file.
              	;
EFD5: 0E0C    	ransize:ld	c,12		;look thru directory for first entry with
EFD7: CD1BEB  		call	findfst		;this name.
EFDA: 2A46E7  		ld	hl,(params)	;zero out the 'r0, r1, r2' bytes.
EFDD: 112100  		ld	de,33
EFE0: 19      		add	hl,de
EFE1: E5      		push	hl
EFE2: 72      		ld	(hl),d		;note that (d)=0.
EFE3: 23      		inc	hl
EFE4: 72      		ld	(hl),d
EFE5: 23      		inc	hl
EFE6: 72      		ld	(hl),d
EFE7: CDF8E9  	ransiz1:call	ckfilpos	;is there an extent to process?
EFEA: CA0FF0  		jp	z,ransiz3	;no, we are done.
EFED: CD61E9  		call	fcb2hl		;set (hl) pointing to proper fcb in dir.
EFF0: 110F00  		ld	de,15		;point to last record in extent.
EFF3: CDA8EF  		call	comprand	;and compute random parameters.
EFF6: E1      		pop	hl
EFF7: E5      		push	hl		;now check these values against those
EFF8: 5F      		ld	e,a		;already in fcb.
EFF9: 79      		ld	a,c		;the carry flag will be set if those
EFFA: 96      		sub	(hl)		;in the fcb represent a larger size than
EFFB: 23      		inc	hl		;this extent does.
EFFC: 78      		ld	a,b
EFFD: 9E      		sbc	a,(hl)
EFFE: 23      		inc	hl
EFFF: 7B      		ld	a,e
F000: 9E      		sbc	a,(hl)
F001: DA09F0  		jp	c,ransiz2
F004: 73      		ld	(hl),e		;we found a larger (in size) extent.
F005: 2B      		dec	hl		;stuff these values into fcb.
F006: 70      		ld	(hl),b
F007: 2B      		dec	hl
F008: 71      		ld	(hl),c
F009: CD30EB  	ransiz2:call	findnxt		;now get the next extent.
F00C: C3E7EF  		jp	ransiz1		;continue til all done.
F00F: E1      	ransiz3:pop	hl		;we are done, restore the stack and
F010: C9      		ret			;return.
              	;
              	;   function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
F011: 2A46E7  	setran:	ld	hl,(params)	;point to fcb.
F014: 112000  		ld	de,32		;and to last used record.
F017: CDA8EF  		call	comprand	;compute random position.
F01A: 212100  		ld	hl,33		;now stuff these values into fcb.
F01D: 19      		add	hl,de
F01E: 71      		ld	(hl),c		;move 'r0'.
F01F: 23      		inc	hl
F020: 70      		ld	(hl),b		;and 'r1'.
F021: 23      		inc	hl
F022: 77      		ld	(hl),a		;and lastly 'r2'.
F023: C9      		ret	
              	;
              	;   this routine select the drive specified in (active) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
F024: 2AB2F1  	logindrv: ld	hl,(login)	;get the login vector.
F027: 3A45E7  		ld	a,(active)	;get the default drive.
F02A: 4F      		ld	c,a
F02B: CDEDE8  		call	shiftr		;position active bit for this drive
F02E: E5      		push	hl		;into bit 0.
F02F: EB      		ex	de,hl
F030: CD5CE7  		call	select		;select this drive.
F033: E1      		pop	hl
F034: CC4AE7  		call	z,slcterr	;valid drive?
F037: 7D      		ld	a,l		;is this a newly activated drive?
F038: 1F      		rra	
F039: D8      		ret	c
F03A: 2AB2F1  		ld	hl,(login)	;yes, update the login vector.
F03D: 4D      		ld	c,l
F03E: 44      		ld	b,h
F03F: CD0EE9  		call	setbit
F042: 22B2F1  		ld	(login),hl	;and save.
F045: C3A6EA  		jp	bitmap		;now update the bitmap.
              	;
              	;   function to set the active disk number.
              	;
F048: 3AD9F1  	setdsk:	ld	a,(eparam)	;get parameter passed and see if this
F04B: 2145E7  		ld	hl,active	;represents a change in drives.
F04E: BE      		cp	(hl)
F04F: C8      		ret	z
F050: 77      		ld	(hl),a		;yes it does, log it in.
F051: C324F0  		jp	logindrv
              	;
              	;   this is the 'auto disk select' routine. the firsst byte
              	; of the fcb is examined for a drive specification. if non
              	; zero then the drive will be selected and loged in.
              	;
F054: 3EFF    	autosel:ld	a,0ffh		;say 'auto-select activated'.
F056: 32E1F1  		ld	(auto),a
F059: 2A46E7  		ld	hl,(params)	;get drive specified.
F05C: 7E      		ld	a,(hl)
F05D: E61F    		and	1fh		;look at lower 5 bits.
F05F: 3D      		dec	a		;adjust for (1=a, 2=b) etc.
F060: 32D9F1  		ld	(eparam),a	;and save for the select routine.
F063: FE1E    		cp	1eh		;check for 'no change' condition.
F065: D278F0  		jp	nc,autosl1	;yes, don't change.
F068: 3A45E7  		ld	a,(active)	;we must change, save currently active
F06B: 32E2F1  		ld	(olddrv),a	;drive.
F06E: 7E      		ld	a,(hl)		;and save first byte of fcb also.
F06F: 32E3F1  		ld	(autoflag),a	;this must be non-zero.
F072: E6E0    		and	0e0h		;whats this for (bits 6,7 are used for
F074: 77      		ld	(hl),a		;something)?
F075: CD48F0  		call	setdsk		;select and log in this drive.
F078: 3A44E7  	autosl1:ld	a,(userno)	;move user number into fcb.
F07B: 2A46E7  		ld	hl,(params)	;(* upper half of first byte *)
F07E: B6      		or	(hl)
F07F: 77      		ld	(hl),a
F080: C9      		ret			;and return (all done).
              	;
              	;   function to return the current cp/m version number.
              	;
F081: 3E22    	getver:	ld	a,022h		;version 2.2
F083: C304E7  		jp	setstat
              	;
              	;   function to reset the disk system.
              	;
F086: 210000  	rstdsk:	ld	hl,0		;clear write protect status and log
F089: 22B0F1  		ld	(wrtprt),hl	;in vector.
F08C: 22B2F1  		ld	(login),hl
F08F: AF      		xor	a		;select drive 'a'.
F090: 3245E7  		ld	(active),a
F093: 218000  		ld	hl,tbuff	;setup default dma address.
F096: 22B4F1  		ld	(userdma),hl
F099: CDDDE9  		call	defdma
F09C: C324F0  		jp	logindrv	;now log in drive 'a'.
              	;
              	;   function to open a specified file.
              	;
F09F: CD75E9  	openfil:call	clears2		;clear 's2' byte.
F0A2: CD54F0  		call	autosel		;select proper disk.
F0A5: C354EC  		jp	openit		;and open the file.
              	;
              	;   function to close a specified file.
              	;
F0A8: CD54F0  	closefil: call	autosel		;select proper disk.
F0AB: C3A5EC  		jp	closeit		;and close the file.
              	;
              	;   function to return the first occurence of a specified file
              	; name. if the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
F0AE: 0E00    	getfst:	ld	c,0		;prepare for special search.
F0B0: EB      		ex	de,hl
F0B1: 7E      		ld	a,(hl)		;is first byte a '?'?
F0B2: FE3F    		cp	'?'
F0B4: CAC5F0  		jp	z,getfst1	;yes, just get very first entry (zero length match).
F0B7: CDA9E8  		call	setext		;get the extension byte from fcb.
F0BA: 7E      		ld	a,(hl)		;is it '?'? if yes, then we want
F0BB: FE3F    		cp	'?'		;an entry with a specific 's2' byte.
F0BD: C475E9  		call	nz,clears2	;otherwise, look for a zero 's2' byte.
F0C0: CD54F0  		call	autosel		;select proper drive.
F0C3: 0E0F    		ld	c,15		;compare bytes 0-14 in fcb (12&13 excluded).
F0C5: CD1BEB  	getfst1:call	findfst		;find an entry and then move it into
F0C8: C3ECE9  		jp	movedir		;the users dma space.
              	;
              	;   function to return the next occurence of a file name.
              	;
F0CB: 2ADCF1  	getnxt:	ld	hl,(savefcb)	;restore pointers. note that no
F0CE: 2246E7  		ld	(params),hl	;other dbos calls are allowed.
F0D1: CD54F0  		call	autosel		;no error will be returned, but the
F0D4: CD30EB  		call	findnxt		;results will be wrong.
F0D7: C3ECE9  		jp	movedir
              	;
              	;   function to delete a file by name.
              	;
F0DA: CD54F0  	delfile:call	autosel		;select proper drive.
F0DD: CD9FEB  		call	erafile		;erase the file.
F0E0: C304EB  		jp	ststatus	;set status and return.
              	;
              	;   function to execute a sequential read of the specified
              	; record number.
              	;
F0E3: CD54F0  	readseq:call	autosel		;select proper drive then read.
F0E6: C3BFED  		jp	rdseq
              	;
              	;   function to write the net sequential record.
              	;
F0E9: CD54F0  	wrtseq:	call	autosel		;select proper drive then write.
F0EC: C301EE  		jp	wtseq
              	;
              	;   create a file function.
              	;
F0EF: CD75E9  	fcreate:call	clears2		;clear the 's2' byte on all creates.
F0F2: CD54F0  		call	autosel		;select proper drive and get the next
F0F5: C327ED  		jp	getempty	;empty directory space.
              	;
              	;   function to rename a file.
              	;
F0F8: CD54F0  	renfile:call	autosel		;select proper drive and then switch
F0FB: CD19EC  		call	chgnames	;file names.
F0FE: C304EB  		jp	ststatus
              	;
              	;   function to return the login vector.
              	;
F101: 2AB2F1  	getlog:	ld	hl,(login)
F104: C32CF1  		jp	getprm1
              	;
              	;   function to return the current disk assignment.
              	;
F107: 3A45E7  	getcrnt:ld	a,(active)
F10A: C304E7  		jp	setstat
              	;
              	;   function to set the dma address.
              	;
F10D: EB      	putdma:	ex	de,hl
F10E: 22B4F1  		ld	(userdma),hl	;save in our space and then get to
F111: C3DDE9  		jp	defdma		;the bios with this also.
              	;
              	;   function to return the allocation vector.
              	;
F114: 2AC2F1  	getaloc:ld	hl,(alocvect)
F117: C32CF1  		jp	getprm1
              	;
              	;   function to return the read-only status vector.
              	;
F11A: 2AB0F1  	getrov:	ld	hl,(wrtprt)
F11D: C32CF1  		jp	getprm1
              	;
              	;   function to set the file attributes (read-only, system).
              	;
F120: CD54F0  	setattr:call	autosel		;select proper drive then save attributes.
F123: CD3EEC  		call	saveattr
F126: C304EB  		jp	ststatus
              	;
              	;   function to return the address of the disk parameter block
              	; for the current drive.
              	;
F129: 2ABEF1  	getparm:ld	hl,(diskpb)
F12C: 2248E7  	getprm1:ld	(status),hl
F12F: C9      		ret	
              	;
              	;   function to get or set the user number. if (e) was (ff)
              	; then this is a request to return the current user number.
              	; else set the user number from (e).
              	;
F130: 3AD9F1  	getuser:ld	a,(eparam)	;get parameter.
F133: FEFF    		cp	0ffh		;get user number?
F135: C23EF1  		jp	nz,setuser
F138: 3A44E7  		ld	a,(userno)	;yes, just do it.
F13B: C304E7  		jp	setstat
F13E: E61F    	setuser:and	1fh		;no, we should set it instead. keep low
F140: 3244E7  		ld	(userno),a	;bits (0-4) only.
F143: C9      		ret	
              	;
              	;   function to read a random record from a file.
              	;
F144: CD54F0  	rdrandom: call	autosel		;select proper drive and read.
F147: C396EF  		jp	readran
              	;
              	;   function to compute the file size for random files.
              	;
F14A: CD54F0  	wtrandom: call	autosel		;select proper drive and write.
F14D: C39FEF  		jp	writeran
              	;
              	;   function to compute the size of a random file.
              	;
F150: CD54F0  	filesize: call	autosel		;select proper drive and check file length
F153: C3D5EF  		jp	ransize
              	;
              	;   function #37. this allows a program to log off any drives.
              	; on entry, set (de) to contain a word with bits set for those
              	; drives that are to be logged off. the log-in vector and the
              	; write protect vector will be updated. this must be a m/pm
              	; special function.
              	;
F156: 2A46E7  	logoff:	ld	hl,(params)	;get drives to log off.
F159: 7D      		ld	a,l		;for each bit that is set, we want
F15A: 2F      		cpl			;to clear that bit in (login)
F15B: 5F      		ld	e,a		;and (wrtprt).
F15C: 7C      		ld	a,h
F15D: 2F      		cpl	
F15E: 2AB2F1  		ld	hl,(login)	;reset the login vector.
F161: A4      		and	h
F162: 57      		ld	d,a
F163: 7D      		ld	a,l
F164: A3      		and	e
F165: 5F      		ld	e,a
F166: 2AB0F1  		ld	hl,(wrtprt)
F169: EB      		ex	de,hl
F16A: 22B2F1  		ld	(login),hl	;and save.
F16D: 7D      		ld	a,l		;now do the write protect vector.
F16E: A3      		and	e
F16F: 6F      		ld	l,a
F170: 7C      		ld	a,h
F171: A2      		and	d
F172: 67      		ld	h,a
F173: 22B0F1  		ld	(wrtprt),hl	;and save. all done.
F176: C9      		ret	
              	;
              	;   get here to return to the user.
              	;
F177: 3AE1F1  	goback:	ld	a,(auto)	;was auto select activated?
F17A: B7      		or	a
F17B: CA94F1  		jp	z,goback1
F17E: 2A46E7  		ld	hl,(params)	;yes, but was a change made?
F181: 3600    		ld	(hl),0		;(* reset first byte of fcb *)
F183: 3AE3F1  		ld	a,(autoflag)
F186: B7      		or	a
F187: CA94F1  		jp	z,goback1
F18A: 77      		ld	(hl),a		;yes, reset first byte properly.
F18B: 3AE2F1  		ld	a,(olddrv)	;and get the old drive and select it.
F18E: 32D9F1  		ld	(eparam),a
F191: CD48F0  		call	setdsk
F194: 2A12E7  	goback1:ld	hl,(usrstack)	;reset the users stack pointer.
F197: F9      		ld	sp,hl
F198: 2A48E7  		ld	hl,(status)	;get return status.
F19B: 7D      		ld	a,l		;force version 1.4 compatability.
F19C: 44      		ld	b,h
F19D: C9      		ret			;and go back to user.
              	;
              	;   function #40. this is a special entry to do random i/o.
              	; for the case where we are writing to unused disk space, this
              	; space will be zeroed out first. this must be a m/pm special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
F19E: CD54F0  	wtspecl:call	autosel		;select proper drive.
F1A1: 3E02    		ld	a,2		;use special write mode.
F1A3: 32D8F1  		ld	(mode),a
F1A6: 0E00    		ld	c,0		;set write indicator.
F1A8: CD0AEF  		call	positn1		;position the file.
F1AB: CC06EE  		call	z,wtseq1	;and write (if no errors).
F1AE: C9      		ret	
              	;
              	;**************************************************************
              	;*
              	;*     bdos data storage pool.
              	;*
              	;**************************************************************
              	;
F1AF: E5      	emptyfcb: defb	0e5h		;empty directory segment indicator.
F1B0: 0000    	wrtprt:	defw	0		;write protect status for all 16 drives.
F1B2: 0000    	login:	defw	0		;drive active word (1 bit per drive).
F1B4: 8000    	userdma:defw	080h		;user's dma address (defaults to 80h).
              	;
              	;   scratch areas from parameter block.
              	;
F1B6: 0000    	scratch1: defw	0		;relative position within dir segment for file (0-3).
F1B8: 0000    	scratch2: defw	0		;last selected track number.
F1BA: 0000    	scratch3: defw	0		;last selected sector number.
              	;
              	;   disk storage areas from parameter block.
              	;
F1BC: 0000    	dirbuf:	defw	0		;address of directory buffer to use.
F1BE: 0000    	diskpb:	defw	0		;contains address of disk parameter block.
F1C0: 0000    	chkvect:defw	0		;address of check vector.
F1C2: 0000    	alocvect: defw	0		;address of allocation vector (bit map).
              	;
              	;   parameter block returned from the bios.
              	;
F1C4: 0000    	sectors:defw	0		;sectors per track from bios.
F1C6: 00      	blkshft:defb	0		;block shift.
F1C7: 00      	blkmask:defb	0		;block mask.
F1C8: 00      	extmask:defb	0		;extent mask.
F1C9: 0000    	dsksize:defw	0		;disk size from bios (number of blocks-1).
F1CB: 0000    	dirsize:defw	0		;directory size.
F1CD: 0000    	alloc0:	defw	0		;storage for first bytes of bit map (dir space used).
F1CF: 0000    	alloc1:	defw	0
F1D1: 0000    	offset:	defw	0		;first usable track number.
F1D3: 0000    	xlate:	defw	0		;sector translation table address.
              	;
              	;
F1D5: 00      	closeflg: defb	0		;close flag (=0ffh is extent written ok).
F1D6: 00      	rdwrtflg: defb	0		;read/write flag (0ffh=read, 0=write).
F1D7: 00      	fndstat:defb	0		;filename found status (0=found first entry).
F1D8: 00      	mode:	defb	0		;i/o mode select (0=random, 1=sequential, 2=special random).
F1D9: 00      	eparam:	defb	0		;storage for register (e) on entry to bdos.
F1DA: 00      	relblock: defb	0		;relative position within fcb of block number written.
F1DB: 00      	counter:defb	0		;byte counter for directory name searches.
F1DC: 00000000	savefcb:defw	0,0		;save space for address of fcb (for directory searches).
F1E0: 00      	bigdisk:defb	0		;if =0 then disk is > 256 blocks long.
F1E1: 00      	auto:	defb	0		;if non-zero, then auto select activated.
F1E2: 00      	olddrv:	defb	0		;on auto select, storage for previous drive.
F1E3: 00      	autoflag: defb	0		;if non-zero, then auto select changed drives.
F1E4: 00      	savnxt:	defb	0		;storage for next record number to access.
F1E5: 00      	savext:	defb	0		;storage for extent number of file.
F1E6: 0000    	savnrec:defw	0		;storage for number of records in file.
F1E8: 0000    	blknmbr:defw	0		;block number (physical sector) used within a file or logical sect
F1EA: 0000    	logsect:defw	0		;starting logical (128 byte) sector of block (physical sector).
F1EC: 00      	fcbpos:	defb	0		;relative position within buffer for fcb of file of interest.
F1ED: 0000    	filepos:defw	0		;files position within directory (0 to max entries -1).
              	;
              	;   disk directory buffer checksum bytes. one for each of the
              	; 16 possible drives.
              	;
F1EF: 00000000	cksumtbl: defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F1F3: 00...   	
              	;
              	;   extra space ?
              	;
F1FF: 00      		defb	0
              		
              	#include "bios.asm"
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   B O O T   R O U T I N E S
              	;*
              	;**************************************************************
              	;
              	
              	;
              	;**************************************************************
              	;*
              	;*          B I O S   J U M P   T A B L E
              	;*
              	;*    This isn't actually used by the BDOS, but
              	;*    some applications (*cough* MBASIC) use it
              	;*    to directly address BIOS calls to get around
              	;*    the BDOS. 
              	;*
              	;**************************************************************
              	;
F200: C333F2  		jp	boot
F203: C341F2  	wbootin:jp	wboot	; Indirection to wboot, used by MBASIC
F206: C388F2  		jp	const
F209: C392F2  		jp	conin
F20C: C39DF2  		jp	conout
F20F: C3A8F2  		jp	list
F212: C3A9F2  		jp	punch
F215: C3AAF2  		jp	reader
F218: C3ADF2  		jp	home
F21B: C3B2F2  		jp	seldsk
F21E: C3D0F2  		jp	settrk
F221: C3D4F2  		jp	setsec
F224: C3D8F2  		jp	setdma
F227: C3DEF2  		jp	read
F22A: C3E2F2  		jp	write
F22D: C3E6F2  		jp	prstat
F230: C3E9F2  		jp	sectrn
              	
              	; Cold boot entry
              	; Not much special happens here, so it jumps directly to wboot
F233: 3100DC  	boot:	ld	sp,cbase
F236: CD4AF2  		call	wbootr
F239: 3E04    		ld	a,4
F23B: 3207DC  		ld	(inbulen),a
F23E: C300DC  		jp	cbase
              	
              	; 
F241: 3100DC  	wboot:	ld	sp,cbase
F244: CD4AF2  		call	wbootr
F247: C300DC  		jp	cbase
              	
              	; Warm boot routine
              	; Sends init signal to device bus, loads CCP, and inits CP/M
              	; Does not actually jump to CP/M just yet
F24A: F3      	wbootr:	di
              		
              		; Zero out BSS
F24B: AF      		xor	a
F24C: 2138F8  		ld	hl,imgtop
F24F: 77      		ld	(hl),a
F250: 1139F8  		ld	de,imgtop+1
F253: 01C707  		ld	bc,0xFFFF-imgtop
F256: EDB0    		ldir
              	
              		; Send init signals to all devices
F258: 0600    		ld	b,0
F25A: C5      	wboot0:	push	bc
F25B: 2131F3  		ld	hl,bdevsw
F25E: 78      		ld	a,b
F25F: CDEFF2  		call	swindir
F262: AF      		xor	a
F263: 14      		inc	d
F264: CC0CF3  		call	z,callmj
F267: C1      		pop	bc
F268: 04      		inc	b
F269: 3E14    		ld	a,20
F26B: B8      		cp	b
F26C: 20EC    		jr	nz,wboot0
              	
              		; Call config init
F26E: CD11F3  		call	cfinit
              	
              		; Load the CCP
F271: CD2BF3  		call	resccp
              		
              		; Set up lower memory
F274: 2180F2  		ld	hl,cpmlow
F277: 110000  		ld	de,0
F27A: 010800  		ld	bc,8
F27D: EDB0    		ldir
              		
              		; Return
F27F: C9      		ret
              	
              	
              	; This is not a true function, but a block of code to be copied
              	; to CP/M lower memory
F280: C303F2  	cpmlow:	jp	wbootin	; call jump table version instead
F283: 00      		nop
F284: 00      		nop
F285: C302E4  		jp	fbase-4
              	
              	
              	; Console status
              	;
              	; Returns a=0xFF if there is a character
              	; uses: all
              	; Defaults to device 0 right now
F288: AF      	const:	xor	a
F289: CDECF2  		call	cdindir
F28C: 14      		inc	d
F28D: C0      		ret	nz
F28E: 3C      		inc	a
F28F: C30CF3  		jp	callmj
              		
              	; Console read
              	;
              	; Returns character in a
              	; uses: all
              	; Defaults to device 0 right now
F292: AF      	conin:	xor	a
F293: CDECF2  		call	cdindir
F296: 14      		inc	d
F297: C0      		ret	nz
F298: 3E02    		ld	a,2
F29A: C30CF3  		jp	callmj
              		
              	; Console write
              	; c = Character to print
              	;
              	; uses: all
              	; Defaults to device 0 right now
F29D: AF      	conout:	xor	a
F29E: CDECF2  		call	cdindir
F2A1: 14      		inc	d
F2A2: C0      		ret	nz
F2A3: 3E03    		ld	a,3
F2A5: C30CF3  		jp	callmj
              		
              	; TODO: Implement
F2A8: C9      	list:	ret
              	
              	; TODO: Implement
F2A9: C9      	punch:	ret
              	
              	; TODO: Implement
F2AA: 3E1A    	reader:	ld	a,0x1A
F2AC: C9      		ret
              		
              	; Move the current drive to track 0
              	;
              	; uses: all
F2AD: 3E01    	home:	ld	a,1
F2AF: C3CAF2  		jp	callbd
              		
              	; Selects a block device
              	; c = Device to select
              	; e = Disk logging status
              	;
              	; return hl=0 if device not valid
              	; uses: all
F2B2: 79      	seldsk:	ld	a,c
F2B3: 4B      		ld	c,e
F2B4: 2131F3  		ld	hl,bdevsw
F2B7: CDEFF2  		call	swindir
F2BA: 22CBF2  		ld	(callbd+1),hl
F2BD: 210000  		ld	hl,0
F2C0: 14      		inc	d
F2C1: C0      		ret	nz
F2C2: 2A0DF3  		ld	hl,(callmj+1)
F2C5: 22CEF2  		ld	(callbd+4),hl
F2C8: 3E02    		ld	a,2
              		
              		
              	; Small stub to jump to the currently selected block device
              	; Also records hl as argument
F2CA: 21      	callbd:	defb	0x21
F2CB: 0000    		defw	0
F2CD: C3      		defb	0xC3
F2CE: 0000    		defw	0
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	;
              	; uses: all
F2D0: 3E03    	settrk:	ld	a,3
F2D2: 18F6    		jr	callbd
              		
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	;
              	; uses: all
F2D4: 3E04    	setsec:	ld	a,4
F2D6: 18F2    		jr	callbd
              	
              	; Sets the DMA address of the selected block device
              	; bc = DMA address
              	;
              	; uses: all
F2D8: 60      	setdma:	ld	h,b
F2D9: 69      		ld	l,c
F2DA: 220FF3  		ld	(biodma),hl
F2DD: C9      		ret
              		
              	; Reads the configured block from the selected block device
              	;
              	; uses: all
F2DE: 3E05    	read:	ld	a,5
F2E0: 18E8    		jr	callbd
              	
              	; Writes the configured block to the selected block device
              	; c = Deferred mode
              	;
              	; uses: all
F2E2: 3E06    	write:	ld	a,6
F2E4: 18E4    		jr	callbd
              		
              	; TOOD Implement
F2E6: 3E00    	prstat:	ld	a,0
F2E8: C9      		ret
              		
              	; Provides sector translation
              	; Returns no translation for all devices
F2E9: 60      	sectrn:	ld	h,b
F2EA: 69      		ld	l,c
F2EB: C9      		ret
              		
              	; Character device switch indirection
              	; Sets hl to cdevsw and jumps to swindir
F2EC: 2171F3  	cdindir:ld	hl,cdevsw
              		
              	; Switch indirect helper function
              	; a = Device
              	; hl = Start of switch
              	;
              	; returns d=255 if device found, hl as argument
              	; uses: af, de, hl
F2EF: 110400  	swindir:ld	de,4
F2F2: B7      		or	a
F2F3: 2804    	swindi0:jr	z,swindi1
F2F5: 19      		add	hl,de
F2F6: 3D      		dec	a
F2F7: 18FA    		jr	swindi0
F2F9: 7E      	swindi1:ld	a,(hl)
F2FA: 320DF3  		ld	(callmj+1),a
F2FD: 23      		inc	hl
F2FE: BE      		cp	(hl)
F2FF: C8      		ret	z
F300: 7E      		ld	a,(hl)
F301: 320EF3  		ld	(callmj+2),a
F304: 23      		inc	hl
F305: 7E      		ld	a,(hl)
F306: 23      		inc	hl
F307: 66      		ld	h,(hl)
F308: 6F      		ld	l,a
F309: 16FF    		ld	d,255
F30B: C9      	nulldev:ret		; Just points to a return
              	
              	; Small stub to jump to the memory jump register
F30C: C3      	callmj: defb	0xC3
F30D: 0000    		defw	0
              	
              	
              	
              	; Variables
F30F: 0000    	biodma:	defw	0	; Block device DMA address
              	#include "config.asm"
              	;
              	;**************************************************************
              	;*
              	;*          I S H K U R   S Y S T E M   C O N F I G
              	;*
              	;*      This file contains points that should be modifed
              	;*      if new devices are to be added to IshkurCP/M. At
              	;*      a mimumum, they need to be included at the bottom
              	;*      of the file, and added to their appropriate dev
              	;*      switch. Some devices may need additional config
              	;*      directly in their source files
              	;*       
              	;*
              	;**************************************************************
              	;
              	;
              	;   Set memory base here. 
              	;
0037:         	mem	equ	55		; CP/M image starts at mem*1024
              	
DC07:         	inbulen	equ	0xDC07	; Address in inbuff length byte
              	
              	;
              	;**************************************************************
              	;*
              	;*              D E V I C E   B S S   B A S E S
              	;*
              	;*        Many devices need a section of uninitialized
              	;*        memory space to hold buffers. This will not
              	;*        be included in the system image to reduce space
              	;*        so their location must be defined here.
              	;*       
              	;*        This memory is usually found above the system image.
              	;*        All memory that is in this area will be automatically
              	;*        zeroed on a warm boot.
              	;*
              	;**************************************************************
              	;
              	
FA00:         	dircbuf	equ	0xFA00	; 128 bytes
FA80:         	tm_bss	equ	0xFA80	; 48 bytes
FAC0:         	nf_bss	equ	0xFAC0	; 90 bytes
FC00:         	nf_cach equ	0xFC00
              	
              	;
              	;**************************************************************
              	;*
              	;*        W A R M   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function is called at the end of a warm boot
              	;*    to set up hardware-specific stuff. 
              	;*
              	;**************************************************************
              	;
              	
F311: 3E01    	cfinit:	ld	a,0x01		; Bank out ROM
F313: D300    		out	(0x00),a
              		
F315: 3EC3    		ld	a,0xC3		; Set up IRQ handler
F317: 323800  		ld	(0x38),a	
F31A: 2128F3  		ld	hl,cfirq
F31D: 223900  		ld	(0x39),hl
              		
F320: 3E0E    		ld	a,0x0E		; Enable clock
              		;out	(0x41),a
F322: 3E10    		ld	a,0x10
              		;out	(0x40),a
              		
              		
F324: ED56    		im	1		; Start interrupts
F326: F3      		di
F327: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*            I N T E R R U P T   H A N D L I N G
              	;*
              	;*     This function will be called in order to handle an
              	;*     interrupt if the need arises. Hooking drivers up to
              	;*     this code may be a little bit more involved.
              	;*
              	;**************************************************************
              	;
              	
F328: FB      	cfirq:	ei
F329: ED4D    		reti
              	
              	;**************************************************************
              	;*
              	;*           B L O C K   D E V I C E   S W I T C H
              	;*
              	;*       IshkurCP/M can support up to 16 logical disks
              	;*       A single driver can be mapped to a number of
              	;*       these disks. Each logical disk is defined by a
              	;*       4-byte record. The first 2 bytes are a pointer
              	;*       to the device entry, and the last 2 are passed
              	;*       as an argument to the device. Usually this 
              	;*       takes the form of a minor number for indexing
              	;*       sub-disks on the same driver
              	;*
              	;*
              	;**************************************************************
              	;
              		
              	; One of the block devices needs to have the responsibiliy
              	; of loading the CCP into memory. Define the jump vector here
F32B: C3B8F7  	resccp:	jp	nf_ccp
              	
              	; Additionally, if Ishkur is using a graphical device, that
              	; device may temporarily need to access the Graphical Resource
              	; Block (GRB) to load in fonts and such. This is up to 2k in
              	; size, and goes in the location that the CCP resides
F32E: C3B1F7  	resgrb:	jp	nf_grb
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
F331: 1FF60000	bdevsw:	defw	nfddev,	0	; 'A'
F335: 1FF60100		defw	nfddev,	1	; 'B'
F339: 00000000		defw	0,	0	; 'C'
F33D: 00000000		defw	0,	0	; 'D'
F341: 00000000		defw	0,	0	; 'E'
F345: 00000000		defw	0,	0	; 'F'
F349: 00000000		defw	0,	0	; 'G'
F34D: 00000000		defw	0,	0	; 'H'
F351: 00000000		defw	0,	0	; 'I'
F355: 00000000		defw	0,	0	; 'J'
F359: 00000000		defw	0,	0	; 'K'
F35D: 00000000		defw	0,	0	; 'L'
F361: 00000000		defw	0,	0	; 'M'
F365: 00000000		defw	0,	0	; 'N'
F369: 00000000		defw	0,	0	; 'O'
F36D: 00000000		defw	0,	0	; 'P'
              	
              	;
              	; Character device switch MUST come directly after in memory!
              	;
              	;**************************************************************
              	;*
              	;*        C H A R A C T E R   D E V I C E   S W I T C H
              	;*
              	;*      Currently, 4 character devices are supported. These
              	;*      devices are the console, the printer, and two "punches"
              	;*      (can be thought of as an auxillary serial device).
              	;*      All character devices use the same interface, which
              	;*      allows for easy indireciton. 
              	;*
              	;*	Device switch logic works about the same of the block
              	;*	devices.
              	;*
              	;**************************************************************
              	;
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
F371: 81F30000	cdevsw:	defw	tmsdev,	0	; Console device
F375: 00000000		defw	0,	0	; Printer device
F379: 00000000		defw	0,	0	; Aux I/O device #1
F37D: 00000000		defw	0,	0	; Aux I/O device #2
              	
              	;
              	;**************************************************************
              	;*
              	;*        D E V I C E   D R I V E R   I N C L U D E S
              	;*
              	;**************************************************************
              	;
              	#include "tms9918.asm"
              	;
              	;**************************************************************
              	;*
              	;*      T M S 9 9 1 8   C H A R A C T E R   D E V I C E
              	;*
              	;*      This device emulated a VT52 terminal using the
              	;*      TMS9918A graphics chip. The 2kb font record is
              	;*      not resident is memory, and must be provided by
              	;*      a compatable block I/O device.
              	;*
              	;*      Device requires 48 bytes of bss space (tm_bss)
              	;* 
              	;**************************************************************
              	;
              	
              	; TMS9918 Configuration
00A0:         	tm_data	equ	0xA0	; TMS9918 data register (mode=0)
00A1:         	tm_latc	equ	0xA1	; TMS9917 latch register (mode=1)
              	
0090:         	tm_keyd	equ	0x90	; Keyboard data register
0091:         	tm_keys	equ	0x91	; Keyboard status register
              	
              	; Driver jump table
F381: B7      	tmsdev:	or	a
F382: 281C    		jr	z,tm_init
F384: 3D      		dec	a
F385: 2807    		jr	z,tm_stat
F387: 3D      		dec	a
F388: CAE7F3  		jp	z,tm_read
F38B: C339F4  		jp	tm_writ
              	
              	
              	; Gets the status of the keyboard
              	;
              	; Returns a=0xFF if there is a key to read 
              	; uses: af, bc, de, hl
F38E: 3A82FA  	tm_stat:ld	a,(tm_outc)
F391: 3C      		inc	a
F392: 3EFF    		ld	a,0xFF
F394: C0      		ret	nz
F395: CD2BF5  		call	tm_getc
F398: 3282FA  		ld	(tm_outc),a
F39B: 3C      		inc	a
F39C: C8      		ret	z
F39D: 3EFF    		ld	a,0xFF
F39F: C9      		ret
              	
              	; TMS9918 init
              	; Load font record, set up terminal
F3A0: CD2EF3  	tm_init:call	resgrb
              	
              		; Set TMS to text mode
F3A3: DBA1    		in	a,(tm_latc)
F3A5: 3E00    		ld	a,0x00
F3A7: D3A1    		out	(tm_latc),a
F3A9: 3E80    		ld	a,0x80
F3AB: D3A1    		out	(tm_latc),a
F3AD: DBA1    		in	a,(tm_latc)
F3AF: 3EF0    		ld	a,0xF0
F3B1: D3A1    		out	(tm_latc),a
F3B3: 3E81    		ld	a,0x81
F3B5: D3A1    		out	(tm_latc),a
              		
              		; Set TMS name table to 0x0800
F3B7: DBA1    		in	a,(tm_latc)
F3B9: 3E02    		ld	a,0x02
F3BB: D3A1    		out	(tm_latc),a
F3BD: 3E82    		ld	a,0x82
F3BF: D3A1    		out	(tm_latc),a
              		
              		; Set TMS pattern generator block to 0
F3C1: DBA1    		in	a,(tm_latc)
F3C3: AF      		xor	a
F3C4: D3A1    		out	(tm_latc),a
F3C6: 3E84    		ld	a,0x84
F3C8: D3A1    		out	(tm_latc),a
              		
              		; Write the GRB
F3CA: 010040  		ld	bc,0x4000
F3CD: CDE5F5  		call	tm_addr
F3D0: 2100DC  		ld	hl,cbase
F3D3: 0EA0    		ld	c,tm_data
F3D5: 3E08    		ld	a,8	; Transfer 8*256 = 2048
F3D7: 0600    	tm_ini0:ld	b,0
F3D9: EDB3    		otir
F3DB: 3D      		dec	a
F3DC: 20F9    		jr	nz,tm_ini0
              		
              		; Clear the terminal
F3DE: CDD2F5  		call	tm_cls
              		
              		; Fall to tm_cloc
              		
              	; Clear the output character
              	;
              	; uses: af
F3E1: 3EFF    	tm_cloc:ld	a,0xFF
F3E3: 3282FA  		ld	(tm_outc),a
              	
F3E6: C9      		ret
              	
              	; Waits for the user to press a key, and returns it
              	;
              	; Returns ASCII key in A
              	; uses: af, bc, de, hl
F3E7: 3A80FA  	tm_read:ld	a,(tm_curx)
F3EA: 4F      		ld	c,a
F3EB: 3A81FA  		ld	a,(tm_cury)
F3EE: 57      		ld	d,a
F3EF: 21000C  		ld	hl,0x0C00
F3F2: 3E50    		ld	a,80
F3F4: CD8DF5  		call	tm_chat
F3F7: DBA0    		in	a,(tm_data)	; char is in A
F3F9: 57      		ld	d,a		; char key
F3FA: 5F      		ld	e,a		; blinking char
F3FB: 0601    		ld	b,1
              		
F3FD: D5      	tm_rea0:push	de
F3FE: CD8EF3  		call	tm_stat
F401: D1      		pop	de
F402: 3C      		inc	a
F403: 200D    		jr	nz,tm_rea1
F405: 5A      		ld	e,d
F406: CD22F4  		call	tm_rea2
F409: 3A82FA  		ld	a,(tm_outc)
F40C: 47      		ld	b,a
F40D: CDE1F3  		call	tm_cloc
F410: 78      		ld	a,b
F411: C9      		ret
              		
F412: CD30F4  	tm_rea1:call	tm_stal
F415: 10E6    		djnz	tm_rea0
F417: 3E80    		ld	a,0x80
F419: AB      		xor	e
F41A: 5F      		ld	e,a
F41B: CD22F4  		call	tm_rea2
F41E: 06BE    		ld	b,190
F420: 18DB    		jr	tm_rea0
              	
              	
F422: D5      	tm_rea2:push	de
F423: 3A80FA  		ld	a,(tm_curx)
F426: 4F      		ld	c,a
F427: 3A81FA  		ld	a,(tm_cury)
F42A: 57      		ld	d,a
F42B: CD77F5  		call	tm_putf
F42E: D1      		pop	de
F42F: C9      		ret
              	
              	; Stalls out for a little bit
              	;
              	; uses: none
F430: C5      	tm_stal:push	bc
F431: 06FF    		ld	b,255
F433: C5      	tm_sta1:push	bc
F434: C1      		pop	bc
F435: 10FC    		djnz	tm_sta1
F437: C1      		pop	bc
F438: C9      		ret
              	
              	
              	; Writes a character to the screen
              	; c = Character to write
              	;
              	; Returns c,b as next position 
              	; uses: af, bc, de, hl
F439: 59      	tm_writ:ld	e,c
F43A: 3A80FA  		ld	a,(tm_curx)
F43D: 4F      		ld	c,a
F43E: 3A81FA  		ld	a,(tm_cury)
F441: 57      		ld	d,a
F442: CD4EF4  		call	tm_wri0
F445: 78      		ld	a,b
F446: 3281FA  		ld	(tm_cury),a
F449: 79      		ld	a,c
F44A: 3280FA  		ld	(tm_curx),a
F44D: C9      		ret
              		
              	; Write helper routine
              	; c = X position
              	; d = Y position
              	; e = Character
              	;
              	; Returns c,b as next position
F44E: 42      	tm_wri0:ld	b,d		; c = X, b = Y
F44F: 3A84FA  		ld	a,(tm_escs)
F452: B7      		or	a		; Process escape code
F453: C2BBF4  		jp	nz,tm_esc
F456: 3E1F    		ld	a,0x1F
F458: BB      		cp	e
F459: D28DF4  		jp	nc,tm_wri1	; Process control code
F45C: C5      		push	bc
F45D: CD69F5  		call	tm_putc		; Write character
F460: C1      		pop	bc
              		
              		; Increment character
F461: 0C      	tm_ri	inc	c
F462: 3E50    		ld	a,80
F464: B9      		cp	c
F465: C0      		ret	nz
F466: AF      		xor	a
F467: 4F      		ld	c,a
F468: 04      	tm_lf:  inc	b	; Line feed
F469: 3E18    		ld	a,24
F46B: B8      		cp	b
F46C: C0      		ret	nz
F46D: C5      		push	bc
F46E: CD05F5  		call	tm_dsco
F471: C1      		pop	bc
F472: 05      		dec	b
F473: C9      		ret
F474: AF      	tm_cr:	xor	a	; Carriage return
F475: 4F      		ld	c,a
F476: C9      		ret
F477: 0D      	tm_bs:	dec	c	; Backspace 
F478: F0      		ret	p
F479: 0E4F    		ld	c,79
F47B: 05      		dec	b
F47C: F0      		ret	p
F47D: AF      		xor	a
F47E: 47      		ld	b,a
F47F: 4F      		ld	c,a
F480: C9      		ret
F481: AF      	tm_up:	xor	a	; Move up
F482: B8      		cp	b
F483: C8      		ret	z
F484: 05      		dec	b
F485: C9      		ret
F486: CDD2F5  	tm_cshm:call	tm_cls
F489: AF      	tm_home:xor	a
F48A: 47      		ld	b,a
F48B: 4F      		ld	c,a
F48C: C9      		ret
              	
F48D: 7B      	tm_wri1:ld	a,e
F48E: FE08    		cp	0x08	; '\b' (Cursor left)
F490: 28E5    		jr	z,tm_bs
F492: FE12    		cp	0x12	; Cursor right
F494: 28CB    		jr	z,tm_ri
F496: FE0A    		cp	0x0A	; '\n' (Cursor down)
F498: 28CE    		jr	z,tm_lf
F49A: FE0B    		cp	0x0B	; Cursor up
F49C: 28E3    		jr	z,tm_up
F49E: FE0D    		cp	0x0D	; '\r' 
F4A0: 28D2    		jr	z,tm_cr
F4A2: FE17    		cp	0x17	; Clear end of screen
F4A4: 2844    		jr	z,tm_cles
F4A6: FE18    		cp	0x18	; Clear end of line
F4A8: 2842    		jr	z,tm_clea
F4AA: FE1A    		cp	0x1A	; Clear screen, home cursor
F4AC: 28D8    		jr	z,tm_cshm
F4AE: FE1E    		cp	0x1E	; Home cursor
F4B0: 28D7    		jr	z,tm_home
F4B2: FE1B    		cp	0x1B	; Escape
F4B4: C0      		ret	nz
F4B5: 3E01    		ld	a,1
F4B7: 3284FA  		ld	(tm_escs),a
F4BA: C9      		ret
              		
              		; Handle escape sequence
F4BB: 3D      	tm_esc:	dec	a
F4BC: 280B    		jr	z,tm_esc0
F4BE: 3D      		dec	a
F4BF: 2813    		jr	z,tm_esc1
F4C1: 3D      		dec	a
F4C2: 281B    		jr	z,tm_esc2
F4C4: AF      	tm_escd:xor	a	; Escape done
F4C5: 3284FA  	tm_escr:ld	(tm_escs),a
F4C8: C9      		ret
F4C9: 3E3D    	tm_esc0:ld	a,0x3D	; '='
F4CB: BB      		cp	e
F4CC: 20F6    		jr	nz,tm_escd
F4CE: 3A84FA  	tm_esci:ld	a,(tm_escs)
F4D1: 3C      		inc	a
F4D2: 18F1    		jr	tm_escr
F4D4: 7B      	tm_esc1:ld	a,e
F4D5: 1E20    		ld	e,0x20
F4D7: 93      		sub	e
F4D8: FE18    		cp	24
F4DA: 30E8    		jr	nc,tm_escd
F4DC: 47      		ld	b,a
F4DD: 18EF    		jr	tm_esci
F4DF: 7B      	tm_esc2:ld	a,e
F4E0: 1E20    		ld	e,0x20
F4E2: 93      		sub	e
F4E3: FE50    		cp	80
F4E5: 30DD    		jr	nc,tm_escd
F4E7: 4F      		ld	c,a
F4E8: 18DA    		jr	tm_escd
              		
              		; Clear segment
              		; B = ending line
F4EA: 0617    	tm_cles:ld	b,23
F4EC: 04      	tm_clea:inc	b
F4ED: 1E00    		ld	e,0
F4EF: C5      	tm_cle0:push	bc
F4F0: D5      		push	de
F4F1: CD69F5  		call	tm_putc
F4F4: D1      		pop	de
F4F5: C1      		pop	bc
F4F6: 0C      		inc	c
F4F7: 3E50    		ld	a,80
F4F9: B9      		cp	c
F4FA: 20F3    		jr	nz,tm_cle0
F4FC: 14      		inc	d
F4FD: AF      		xor	a
F4FE: 4F      		ld	c,a
F4FF: 7A      		ld	a,d
F500: B8      		cp	b
F501: 20EC    		jr	nz,tm_cle0
F503: D1      		pop	de	; Do not update character
F504: C9      		ret
              		
              		
              	; Scroll both frame buffers down one
              	;
              	; uses: af, bc, de, hl
F505: 212808  	tm_dsco:ld	hl,0x0800+40
F508: 110048  		ld	de,0x4800
F50B: 0618    		ld	b,24
F50D: CD18F5  		call	tm_dsc0
F510: 21500C  		ld	hl,0x0C00+80
F513: 11004C  		ld	de,0x4C00
F516: 0630    		ld	b,48
F518: C5      	tm_dsc0:push	bc
F519: D5      		push	de
F51A: E5      		push	hl
F51B: CD99F5  		call	tm_vcpy
F51E: E1      		pop	hl
F51F: D1      		pop	de
F520: 012800  		ld	bc,40
F523: 09      		add	hl,bc
F524: EB      		ex	de,hl
F525: 09      		add	hl,bc
F526: EB      		ex	de,hl
F527: C1      		pop	bc
F528: 10EE    		djnz	tm_dsc0
F52A: C9      		ret
              		
              	
              	; Grabs the latest key pressed by the keyboard
              	; Discard keyboard errors
              	; Returns key in A, or 0xFF if none
              	;
              	; uses: af, bc, de, hl
F52B: DB91    	tm_getc:in	a,(tm_keys)
F52D: E602    		and	2
F52F: 3D      		dec	a
F530: F8      		ret	m
              		
              		; Check for scrolling
F531: DB90    		in	a,(tm_keyd)
F533: FEE4    		cp	0xE4
F535: 2815    		jr	z,tm_scri
F537: FEE5    		cp	0xE5
F539: 2824    		jr	z,tm_sclf
              		
F53B: CD40F5  		call	tm_map
F53E: 79      		ld	a,c
F53F: C9      		ret
              		
              	; Maps keyboard input to ASCII
              	; a = Key to map
              	;
              	; Returns mapped key in c
              	; uses: af, c
F540: 0E08    	tm_map:	ld	c,0x08	; DEL -> BS
F542: FE7F    		cp	0x7F
F544: C8      		ret	z
              		
F545: 4F      		ld	c,a	; Filter non-ASCII
F546: E680    		and	0x80	
F548: C8      		ret	z
F549: 0EFF    		ld	c,0xFF
F54B: C9      		ret
              		
              	; Scroll left / scroll right
              	;
              	; uses: af, bc, de, hl
F54C: 3A83FA  	tm_scri:ld	a,(tm_scro)
F54F: B7      		or	a
F550: FE28    		cp	40
F552: 2808    		jr	z,tm_scr1
F554: C60A    		add	a,10
F556: 3283FA  	tm_scr0:ld	(tm_scro),a
F559: CDAFF5  		call	tm_usco
F55C: 3EFF    	tm_scr1:ld	a,0xFF
F55E: C9      		ret
F55F: 3A83FA  	tm_sclf:ld	a,(tm_scro)
F562: B7      		or	a
F563: 28F7    		jr	z,tm_scr1
F565: D60A    		sub	10
F567: 18ED    		jr	tm_scr0
              	
              	; Puts a character on the screen
              	; c = X position
              	; d = Y position
              	; e = Character to put
              	;
              	; uses: af, bc, de, hl
F569: 21004C  	tm_putc:ld	hl,0x4C00
F56C: 3E50    		ld	a,80
F56E: C5      		push	bc
F56F: D5      		push	de
F570: CD8DF5  		call	tm_chat	; Place it in the 80 col buffer
F573: ED59    		out	(c),e
F575: D1      		pop	de
F576: C1      		pop	bc
F577: 3A83FA  	tm_putf:ld	a,(tm_scro)	; Place into frame buffer
F57A: 47      		ld	b,a
F57B: 79      		ld	a,c
F57C: 90      		sub	b	; If character is less than scroll...
F57D: 4F      		ld	c,a
F57E: F8      		ret	m
F57F: FE28    		cp	40	; If desired position is 40 or more
F581: D0      		ret	nc
F582: 210048  		ld	hl,0x4800
F585: 3E28    		ld	a,40
F587: CD8DF5  		call	tm_chat	; Place it in the 40 col screen buffer
F58A: ED59    		out	(c),e
F58C: C9      		ret
              	
              	; Sets the TMS address to a character at x,y
              	; a = Line width
              	; c = X position
              	; d = Y position
              	;
              	; uses: af, bc, d, hl
F58D: 0600    	tm_chat:ld	b,0
F58F: 09      		add	hl,bc
F590: 4F      		ld	c,a
F591: AF      		xor	a
F592: BA      		cp	d
F593: 284E    	tm_cha0:jr	z,tm_addh
F595: 09      		add	hl,bc
F596: 15      		dec	d
F597: 18FA    		jr	tm_cha0
              	
              	; Copies VRAM from one location to another
              	; Transfers occur in blocks of 40 bytes
              	; de = destination address
              	; hl = source location
              	;
              	; b = 0 on return
              	; uses: af, bc, de, hl
F599: CDE3F5  	tm_vcpy:call	tm_addh
F59C: 0628    		ld	b,40
F59E: 2185FA  		ld	hl,tm_cbuf
F5A1: EDB2    		inir
F5A3: EB      		ex	de,hl
F5A4: CDE3F5  		call	tm_addh
F5A7: 0628    		ld	b,40
F5A9: 2185FA  		ld	hl,tm_cbuf
F5AC: EDB3    		otir
F5AE: C9      		ret
              		
              	; Updates the frame buffer based on the scroll position
              	;
              	; uses: af, bc, de, hl
F5AF: 21000C  	tm_usco:ld	hl,0x0C00
F5B2: 110048  		ld	de,0x4800
F5B5: 3A83FA  		ld	a,(tm_scro)
F5B8: 0600    		ld	b,0
F5BA: 4F      		ld	c,a
F5BB: 09      		add	hl,bc
F5BC: 0618    		ld	b,24
F5BE: C5      	tm_usc0:push	bc
F5BF: D5      		push	de
F5C0: E5      		push	hl
F5C1: CD99F5  		call	tm_vcpy
F5C4: E1      		pop	hl
F5C5: D1      		pop	de
F5C6: 0E50    		ld	c,80
F5C8: 09      		add	hl,bc
F5C9: EB      		ex	de,hl
F5CA: 0E28    		ld	c,40
F5CC: 09      		add	hl,bc
F5CD: EB      		ex	de,hl
F5CE: C1      		pop	bc
F5CF: 10ED    		djnz	tm_usc0
F5D1: C9      		ret
              		
              	
              	; Clears out screen buffer and offscreen buffer
              	; Also includes clear limited function
              	;
              	; uses: af, bc, de
F5D2: 010048  	tm_cls:	ld	bc,0x4800
F5D5: 11000C  		ld	de,0x0C00
F5D8: CDE5F5  		call	tm_addr
F5DB: ED71    	tm_cls0:out	(c),0
F5DD: 1B      		dec	de
F5DE: 7A      		ld	a,d
F5DF: B3      		or	e
F5E0: 20F9    		jr	nz,tm_cls0
F5E2: C9      		ret
              	
              	; Sets the TMS address for either reading or writing
              	; bc = Address 
              	;
              	; uses: af, bc
F5E3: 44      	tm_addh:ld	b,h		; Does HL instead of BC
F5E4: 4D      		ld	c,l
F5E5: DBA1    	tm_addr:in	a,(tm_latc)
F5E7: 79      		ld	a,c
F5E8: D3A1    		out	(tm_latc),a
F5EA: 78      		ld	a,b
F5EB: D3A1    		out	(tm_latc),a
F5ED: 0EA0    		ld	c,tm_data
F5EF: C9      		ret
              		
              	; Variables
FA80:         	tm_curx:equ	tm_bss		; Cursor X
FA81:         	tm_cury:equ	tm_bss+1	; Cursor Y
FA82:         	tm_outc:equ	tm_bss+2	; Output character
FA83:         	tm_scro:equ	tm_bss+3	; Scroll width
FA84:         	tm_escs:equ	tm_bss+4	; Escape state
              	
              	; 40 byte character buffer
FA85:         	tm_cbuf:equ	tm_bss+5
              	#include "nabu1797.asm"
              	;
              	;**************************************************************
              	;*
              	;*      N A B U   F D 1 7 9 7   F L O P P Y   D R I V E R
              	;*
              	;*      This driver interfaces the NABU FDC for use as a
              	;*      CP/M file system, graphical source, and boot device.
              	;*      The driver only supports double-density disks of 
              	;*      Osborne 1 format at the time, but this could be
              	;*      updated if it is needed. The directory table starts
              	;*      on track 2, the system sectors are as follows:
              	;*
              	;*      Track 0 Sector 1:	Boot Sector
              	;*      Track 0 Sector 2-3:	Graphical Resource Block
              	;*	Track 0 Sector 4-5:	CCP
              	;*	Track 1 Sector 1-5:	BDOS + BIOS Image
              	;*
              	;*	Device requires 90 bytes of bss space (nf_bss)
              	;*	Device requires 1024 byte buffer space (nf_cach)
              	;* 
              	;**************************************************************
              	;
              	
0002:         	nf_rdsk	equ	2	; Defines which drives contains system
              				; resources (2 = A, 4 = B)
              	
              	;
              	;**************************************************************
              	;*
              	;*         D I S K   D R I V E   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Disk A DPH
F5F0:         	nf_dpha:
F5F0: 00000000		defw	0,0,0,0
F5F4: 00000000	
F5F8: 00FA    		defw	dircbuf	; DIRBUF
F5FA: 10F6    		defw	nf_dpb	; DPB
F5FC: F9FA    		defw	nf_csva	; CSV
F5FE: C7FA    		defw	nf_asva	; ALV
              	
              	; Disk B DPH
F600:         	nf_dphb:
F600: 00000000		defw	0,0,0,0
F604: 00000000	
F608: 00FA    		defw	dircbuf	; DIRBUF
F60A: 10F6    		defw	nf_dpb	; DPB
F60C: 09FB    		defw	nf_csvb	; CSV
F60E: E0FA    		defw	nf_asvb	; ALV
              	
              	; Osborne 1 format
F610:         	nf_dpb:
F610: 2800    		defw	40	; # sectors per track
F612: 03      		defb	3	; BSH
F613: 07      		defb	7	; BLM
F614: 00      		defb	0	; EXM
F615: B800    		defw	184	; DSM
F617: 3F00    		defw	63	; DRM
F619: C0      		defb	0xC0	; AL0
F61A: 00      		defb	0	; AL1
F61B: 1000    		defw	16	; Size of directory check vector
F61D: 0300    		defw	3	; Number of reserved tracks at the beginning of disk
              	
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
F61F: B7      	nfddev:	or	a
F620: 2815    		jr	z,nf_init
F622: 3D      		dec	a
F623: 283D    		jr	z,nf_home
F625: 3D      		dec	a
F626: 2852    		jr	z,nf_sel
F628: 3D      		dec	a
F629: CAC8F6  		jp	z,nf_strk
F62C: 3D      		dec	a
F62D: CAFEF6  		jp	z,nf_ssec
F630: 3D      		dec	a
F631: CA4FF7  		jp	z,nf_read
F634: C357F7  		jp	nf_writ
              		
              	; Initialize device
              	; Sets the current track to 0
F637: AF      	nf_init:xor	a
F638: 32C0FA  		ld	(nf_io),a
              	
              		; Look for the FDC
F63B: 0ECF    		ld	c,0xCF
F63D: ED78    	nf_ini1:in	a,(c)
F63F: FE10    		cp	0x10
F641: 2808    		jr	z,nf_ini2
F643: 0C      		inc	c
F644: C8      		ret	z	; Should not be possible!
F645: 3E0F    		ld	a,0x0F
F647: 81      		add	a,c
F648: 4F      		ld	c,a
F649: 18F2    		jr	nf_ini1
              		
              		; Get command register
F64B: 79      	nf_ini2:ld	a,c
F64C: D60F    		sub	15
F64E: 4F      		ld	c,a
F64F: 32C0FA  		ld	(nf_io),a
              		
              		; Select drive defined by hl
F652: CB25    		sla	l
F654: 3E02    		ld	a,2
F656: 85      		add	l
F657: 32C2FA  		ld	(nf_curd),a
              		
              		; Force FDC interrupt
F65A: 3ED0    		ld	a,0xD0
F65C: ED79    		out	(c),a
              		
              		; Re-home drive
F65E: CD62F6  		call	nf_home
              		
              		; De-select drive
              		
F661: C9      		ret
              	
              	; Sends the drive to track 0, and syncs the drive
              	;
              	; uses : af, c
F662: CD6FF7  	nf_home:call	nf_wdef
F665: CD16F8  		call	nf_dvsc
              	
F668: 3AC0FA  		ld	a,(nf_io)
F66B: 4F      		ld	c,a
              		
              		; Restore to track 0
F66C: 3E09    		ld	a,0x09
F66E: ED79    		out	(c),a 
F670: CD2DF8  		call	nf_busy
              		
              		; Reset sync flag
F673: AF      		xor	a
F674: 32C4FA  		ld	(nf_sync),a
              		
              		; De-select drive
F677: C31BF8  		jp	nf_udsl
              		
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses; all
F67A: 7D      	nf_sel:	ld	a,l
F67B: 0602    		ld	b,2
F67D: B7      		or	a
F67E: 2809    		jr	z,nf_sel0
F680: 3D      		dec	a
F681: 0604    		ld	b,4
F683: 2804    		jr	z,nf_sel0
F685: 210000  		ld	hl,0
F688: C9      		ret
F689: 3AC2FA  	nf_sel0:ld	a,(nf_curd)	
F68C: B8      		cp	b		; Compare to current drive
F68D: C8      		ret	z
              	
              		; Move control of drive buffers
F68E: CD6FF7  		call	nf_wdef		; Write back if needed
F691: 3EFF    		ld	a,0xFF
F693: 32C4FA  		ld	(nf_sync),a	; Set sync flag
F696: 78      		ld	a,b
F697: 32C2FA  		ld	(nf_curd),a	; Set current drive
F69A: 5F      		ld	e,a
              		
              		; Check to make sure there is a disk
F69B: 16FF    		ld	d,255
F69D: CD16F8  		call	nf_dvsc
F6A0: 3AC0FA  		ld	a,(nf_io)
F6A3: 4F      		ld	c,a
F6A4: 3ED0    		ld	a,0xD0
F6A6: ED79    		out	(c),a		; Force FDC interrupt
F6A8: CD33F8  	nf_sel1:call	nf_stal
F6AB: ED78    		in	a,(c)
F6AD: E602    		and	0x02
F6AF: 2009    		jr	nz,nf_sel2
F6B1: 15      		dec	d
F6B2: 20F4    		jr	nz,nf_sel1
              		
              		; No disk!
F6B4: 210000  		ld	hl,0
F6B7: C31BF8  		jp	nf_udsl
              		
              		
              		; Output DPH
F6BA: CD1BF8  	nf_sel2:call	nf_udsl
F6BD: 21F0F5  		ld	hl,nf_dpha
F6C0: 3E02    		ld	a,2
F6C2: BB      		cp	e
F6C3: C8      		ret	z
F6C4: 2100F6  		ld	hl,nf_dphb
F6C7: C9      		ret
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F6C8: 51      	nf_strk:ld	d,c		; Track = d
F6C9: 3AC0FA  		ld	a,(nf_io)
F6CC: 4F      		ld	c,a
F6CD: 3AC4FA  		ld	a,(nf_sync)
F6D0: B7      		or	a
F6D1: 280E    		jr	z,nf_str0	; Check if disk direct
              		
F6D3: CD16F8  		call	nf_dvsc
              		
              		; Restore to track 0
F6D6: 3E09    		ld	a,0x09
F6D8: ED79    		out	(c),a 
F6DA: CD2DF8  		call	nf_busy
              		
              		; Reset sync flag
F6DD: AF      		xor	a
F6DE: 32C4FA  		ld	(nf_sync),a
              		
              		; Check to see if tracks match
F6E1: 59      	nf_str0:ld	e,c
F6E2: 0C      		inc	c
F6E3: ED78    		in	a,(c)
F6E5: BA      		cp	d
F6E6: CA1BF8  		jp	z,nf_udsl	; They match, do nothing
              	
              		; Write a deferred block
F6E9: CD6FF7  		call	nf_wdef
              	
              		; Seek to track
F6EC: CD16F8  		call	nf_dvsc
F6EF: 0C      		inc	c
F6F0: 0C      		inc	c
F6F1: ED51    		out	(c),d
F6F3: 3E19    		ld	a,0x19
F6F5: 4B      		ld	c,e
F6F6: ED79    		out	(c),a 
F6F8: CD2DF8  		call	nf_busy	
              		
F6FB: C31BF8  		jp	nf_udsl
              	
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F6FE: 79      	nf_ssec:ld	a,c
F6FF: E607    		and	0x07
F701: 32C3FA  		ld	(nf_subs),a
F704: 79      		ld	a,c
              		
              		; Compute physical sector
F705: CB3F    		srl	a
F707: CB3F    		srl	a
F709: CB3F    		srl	a
F70B: 3C      		inc	a
F70C: 47      		ld	b,a	; b = Physical sector
F70D: 3AC0FA  		ld	a,(nf_io)
F710: 3C      		inc	a
F711: 3C      		inc	a
F712: 4F      		ld	c,a
F713: ED78    		in	a,(c)
F715: B8      		cp	b
F716: C8      		ret	z	; Return if the same
              		
              		; Set FDC sector, after writing back if needed
F717: CD6FF7  		call	nf_wdef
F71A: ED41    		out	(c),b
F71C: C9      		ret
              		
              	; Ensure sector is in core, and set up for DMA transfer
              	;
              	; uses: all
F71D: 3AC5FA  	nf_rdwr:ld	a,(nf_inco)
F720: B7      		or	a
F721: 2019    		jr	nz,nf_rdw0
              		
              		; Read in to cache
F723: CD16F8  		call	nf_dvsc
F726: 3AC0FA  		ld	a,(nf_io)
F729: 4F      		ld	c,a
F72A: 2100FC  		ld	hl,nf_cach
F72D: CDFAF7  		call	nf_rphy
F730: 47      		ld	b,a
F731: CD1BF8  		call	nf_udsl
F734: 78      		ld	a,b
              		
              		; Error checking
F735: B7      		or	a
F736: 3E01    		ld	a,1
F738: C0      		ret	nz
F739: 32C5FA  		ld	(nf_inco),a
              		
              		; DMA subsector
F73C: 2A0FF3  	nf_rdw0:ld	hl,(biodma)
F73F: EB      		ex	de,hl
              	
F740: 3AC3FA  		ld	a,(nf_subs)
F743: 2180FB  		ld	hl,nf_cach-128
F746: 018000  		ld	bc,128
F749: 3C      		inc	a
F74A: 09      	nf_rdw1:add	hl,bc
F74B: 3D      		dec	a
F74C: 20FC    		jr	nz,nf_rdw1
F74E: C9      		ret
              	
              	; Reads a sector and DMA transfers it to memory
F74F: CD1DF7  	nf_read:call	nf_rdwr
F752: B7      		or	a
F753: C0      		ret	nz
F754: EDB0    		ldir
F756: C9      		ret
              	
              	
              	; Write a sector from DMA, and defer it if possible
F757: C5      	nf_writ:push	bc
F758: CD1DF7  		call	nf_rdwr
F75B: B7      		or	a
F75C: C1      		pop	bc
F75D: C0      		ret	nz
F75E: 3E01    		ld	a,1
F760: 32C6FA  		ld	(nf_dirt),a
F763: 79      		ld	a,c
F764: 018000  		ld	bc,128
F767: EB      		ex	de,hl
F768: EDB0    		ldir
F76A: FE01    		cp	1
F76C: 3E00    		ld	a,0
F76E: C0      		ret	nz
              		
              		; Drop down to defer read
              	
              	
              	; Checks to see if the cache needs to be written back
              	; after a deferred write.
              	;
              	; uses, af
F76F: 3AC6FA  	nf_wdef:ld	a,(nf_dirt)
F772: B7      		or	a
F773: 2837    		jr	z,nf_wde4
              	
F775: C5      		push	bc
F776: D5      		push	de
F777: E5      		push	hl
              		
              		; Write physical sector
F778: CD16F8  		call	nf_dvsc
F77B: 3AC0FA  		ld	a,(nf_io)
F77E: 4F      		ld	c,a
F77F: C603    		add	a,3
F781: 57      		ld	d,a
F782: 59      		ld	e,c
F783: 3EA8    		ld	a,0xA8		; Write command
F785: ED79    		out	(c),a
F787: 2100FC  		ld	hl,nf_cach
F78A: ED78    	nf_wde1:in	a,(c)
F78C: 1F      		rra	
F78D: 3009    		jr	nc,nf_wde2
F78F: 1F      		rra
F790: 30F8    		jr	nc,nf_wde1
F792: 4A      		ld	c,d
F793: EDA3    		outi 
F795: 4B      		ld	c,e
F796: 18F2    		jr	nf_wde1
F798: ED78    	nf_wde2:in	a,(c)
              		
              		; Deselect drive
F79A: 47      		ld	b,a
F79B: CD1BF8  		call	nf_udsl
F79E: 78      		ld	a,b
              		
F79F: E1      		pop	hl
F7A0: D1      		pop	de
F7A1: C1      		pop	bc
              		
              		; Error checking
F7A2: E6FC    		and	0xFC
F7A4: 2803    		jr	z,nf_wde3
              		
F7A6: 3E01    		ld	a,1
F7A8: C9      		ret
              		
              		; Cache is no longer dirty
F7A9: 32C6FA  	nf_wde3:ld	(nf_dirt),a
              		
              		; Data no longer in core
F7AC: AF      	nf_wde4:xor	a
F7AD: 32C5FA  		ld	(nf_inco),a
              		
F7B0: C9      		ret
              		
              	; Loads the GRB into memory from sector 2-3
F7B1: 3E02    	nf_grb:	ld	a,2
F7B3: 32C1FA  		ld	(nf_r2ks),a
F7B6: 1805    		jr	nf_r2k
              		
              	; Loads the CCP into memory from sectors 4-5
F7B8: 3E04    	nf_ccp:	ld	a,4
F7BA: 32C1FA  		ld	(nf_r2ks),a
              	
              	; Reads in a 2K bytes, starting at track 0, sector (nf_r2ks)
              	; This is placed into the cbase
F7BD: 3E02    	nf_r2k: ld	a,nf_rdsk
F7BF: CD1CF8  		call	nf_dvsl
              		
              		; Restore to track 0
F7C2: 3AC0FA  		ld	a,(nf_io)
F7C5: 4F      		ld	c,a
F7C6: 3E09    		ld	a,0x09
F7C8: ED79    		out	(c),a 
F7CA: CD2DF8  		call	nf_busy
              		
              		; Set sector # to 4
F7CD: 3AC1FA  		ld	a,(nf_r2ks)
F7D0: 0C      		inc	c
F7D1: 0C      		inc	c
F7D2: ED79    		out	(c),a
F7D4: C5      		push	bc
F7D5: 0D      		dec	c
F7D6: 0D      		dec	c
              		
              		; Read into memory
F7D7: 2100DC  		ld	hl,cbase
F7DA: CDFAF7  		call	nf_rphy
F7DD: C1      		pop	bc
F7DE: B7      		or	a
F7DF: 2805    		jr	z,nf_r2k0
F7E1: CD37F6  		call	nf_init		; Error!
F7E4: 18D7    		jr	nf_r2k
              		
              		; Increment sector
F7E6: ED78    	nf_r2k0:in	a,(c)
F7E8: 3C      		inc	a
F7E9: ED79    		out	(c),a
F7EB: 0D      		dec	c
F7EC: 0D      		dec	c
              		
              		; Read into memory again
F7ED: CDFAF7  		call	nf_rphy
F7F0: B7      		or	a
F7F1: C8      		ret	z
F7F2: CD37F6  		call	nf_init		; Error!
F7F5: 18C6    		jr	nf_r2k
              		
              		; De-select drive
F7F7: C31BF8  		jp	nf_udsl
              	
              	; Reads a physical sector
              	; Track and sector should be set up
              	; c = FDC command address
              	; hl = memory location of result
              	;
              	; Returns a=0 if successful
              	; uses: af, bc, de, hl
F7FA: 51      	nf_rphy:ld	d,c
F7FB: 59      		ld	e,c
F7FC: 14      		inc	d
F7FD: 14      		inc	d
F7FE: 14      		inc	d
              		
              		; Read command
F7FF: 3E88    		ld	a,0x88
F801: ED79    		out	(c),a
F803: ED78    	nf_rph1:in	a,(c)
F805: 1F      		rra	
F806: 3009    		jr	nc,nf_rph2
F808: 1F      		rra
F809: 30F8    		jr	nc,nf_rph1
F80B: 4A      		ld	c,d
F80C: EDA2    		ini
F80E: 4B      		ld	c,e
F80F: 18F2    		jr	nf_rph1
F811: ED78    	nf_rph2:in	a,(c)
F813: E6FC    		and	0xFC
F815: C9      		ret
              	
              	; Selects or deselects a drive
              	; a = Drive density / selection
              	;
              	; uses: af
F816: 3AC2FA  	nf_dvsc:ld	a,(nf_curd)	; Select current drive
F819: 1801    		jr	nf_dvsl
F81B: AF      	nf_udsl:xor	a		; Unselects a drive
F81C: C5      	nf_dvsl:push	bc
F81D: 47      		ld	b,a
F81E: 3AC0FA  		ld	a,(nf_io)
F821: C60F    		add	a,0x0F
F823: 4F      		ld	c,a
F824: ED41    		out	(c),b
F826: 06FF    		ld	b,0xFF
F828: CD33F8  		call	nf_stal
F82B: C1      		pop	bc
F82C: C9      		ret
              		
              	
              	; Waits until FDC is not busy
              	; c = FDC command address
              	;
              	; uses: af
F82D: ED78    	nf_busy:in	a,(c)
F82F: 1F      		rra
F830: 38FB    		jr	c,nf_busy
F832: C9      		ret
              		
              	; Waits a little bit
              	;
              	; uses: b
F833: C5      	nf_stal:push	bc
F834: C1      		pop	bc
F835: 10FC    		djnz	nf_stal
F837: C9      		ret
              	
              	
              	; Variables
FAC0:         	nf_io:	equ	nf_bss	; FDC address
FAC1:         	nf_r2ks:equ	nf_bss+1; Temp storaged used in nf_r2k
              	
FAC2:         	nf_curd:equ	nf_bss+2; Currently selected disk
FAC3:         	nf_subs:equ	nf_bss+3; Current subsector
FAC4:         	nf_sync:equ	nf_bss+4; Set if disk needs to be rehomed
FAC5:         	nf_inco:equ	nf_bss+5; Set if sector is in core already
FAC6:         	nf_dirt:equ	nf_bss+6; Set if cache is dirty
              	
              	; Misc CP/M buffer
FAC7:         	nf_asva:equ	nf_bss+7
FAE0:         	nf_asvb:equ	nf_bss+32
FAF9:         	nf_csva:equ	nf_bss+57
FB09:         	nf_csvb:equ	nf_bss+73
              	
              	; Image top, no more code after this
F838:         	imgtop:
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	


; +++ segments +++

#CODE          = $DC00 = 56320,  size = $1C38 =  7224

; +++ global symbols +++

_end     = $F838 = 63544          cpm22.asm:40 (unused)
_size    = $1C38 =  7224          cpm22.asm:40 (unused)
active   = $E745 = 59205          cpm22.asm:1698
adda2hl  = $E967 = 59751          cpm22.asm:2127
addhl    = $DE59 = 56921          cpm22.asm:429
alloc0   = $F1CD = 61901          cpm22.asm:3675
alloc1   = $F1CF = 61903          cpm22.asm:3676
alocvect = $F1C2 = 61890          cpm22.asm:3665
auto     = $F1E1 = 61921          cpm22.asm:3690
autoflag = $F1E3 = 61923          cpm22.asm:3692
autosel  = $F054 = 61524          cpm22.asm:3405
autosl1  = $F078 = 61560          cpm22.asm:3421
backup   = $E5A7 = 58791          cpm22.asm:1458
backup1  = $E5AF = 58799          cpm22.asm:1461
badload  = $E37A = 58234          cpm22.asm:1188
badsctr  = $E40C = 58380          cpm22.asm:1242
badsec   = $E4CD = 58573          cpm22.asm:1313
badsel   = $E4D8 = 58584          cpm22.asm:1314
badslct  = $E40E = 58382          cpm22.asm:1243
batch    = $E3AB = 58283          cpm22.asm:1211
batchfcb = $E3AC = 58284          cpm22.asm:1212
bdevsw   = $F331 = 62257          config.asm:119
bdosdrv  = $E4C9 = 58569          cpm22.asm:1312
bdoserr  = $E4BD = 58557          cpm22.asm:1311
bigdisk  = $F1E0 = 61920          cpm22.asm:3689
biodma   = $F30F = 62223          bios.asm:266
bitmap   = $EAA6 = 60070          cpm22.asm:2420
bitmap1  = $EAB4 = 60084          cpm22.asm:2435
bitmap2  = $EAD5 = 60117          cpm22.asm:2456
bitmap3  = $EAF9 = 60153          cpm22.asm:2473
blkmask  = $F1C7 = 61895          cpm22.asm:3671
blknmbr  = $F1E8 = 61928          cpm22.asm:3696
blkshft  = $F1C6 = 61894          cpm22.asm:3670
boot     = $F233 = 62003          bios.asm:41
bs       = $0008 =     8          cpm22.asm:25
callbd   = $F2CA = 62154          bios.asm:177
callmj   = $F30C = 62220          bios.asm:260
cbase    = $DC00 = 56320          cpm22.asm:42
ccpstack = $E3AB = 58283          cpm22.asm:1207
cdevsw   = $F371 = 62321          config.asm:158
cdindir  = $F2EC = 62188          bios.asm:230
cdrive   = $E3EF = 58351          cpm22.asm:1218
cfinit   = $F311 = 62225          config.asm:56
cfirq    = $F328 = 62248          config.asm:86
charbuf  = $E711 = 59153          cpm22.asm:1687
check    = $DE30 = 56880          cpm22.asm:395
checkdir = $E9A1 = 59809          cpm22.asm:2200
checksum = $E8FA = 59642          cpm22.asm:2039
chgdrv   = $E3F0 = 58352          cpm22.asm:1219
chgnam1  = $EC2A = 60458          cpm22.asm:2712
chgnames = $EC19 = 60441          cpm22.asm:2704
chkblk   = $E887 = 59527          cpm22.asm:1946
chkchar  = $E517 = 58647          cpm22.asm:1355
chkcon   = $DDC2 = 56770          cpm22.asm:320
chkdir1  = $E9C7 = 59847          cpm22.asm:2220
chknmbr  = $E98F = 59791          cpm22.asm:2173
chkrofl  = $E947 = 59719          cpm22.asm:2103
chksum1  = $E900 = 59648          cpm22.asm:2042
chkvect  = $F1C0 = 61888          cpm22.asm:3664
chkwprt  = $E957 = 59735          cpm22.asm:2114
ckbitmap = $EA38 = 59960          cpm22.asm:2314
ckbmap1  = $EA59 = 59993          cpm22.asm:2349
ckcon1   = $E545 = 58693          cpm22.asm:1385
ckcon2   = $E548 = 58696          cpm22.asm:1386
ckconsol = $E526 = 58662          cpm22.asm:1371
ckfilpos = $E9F8 = 59896          cpm22.asm:2263
ckrof1   = $E94A = 59722          cpm22.asm:2104
cksumtbl = $F1EF = 61935          cpm22.asm:3704
clearbuf = $DF58 = 57176          cpm22.asm:595
clears2  = $E975 = 59765          cpm22.asm:2144
close    = $DCDA = 56538          cpm22.asm:135
closefil = $F0A8 = 61608          cpm22.asm:3452
closeflg = $F1D5 = 61909          cpm22.asm:3681
closeit  = $ECA5 = 60581          cpm22.asm:2798
closeit1 = $ECD0 = 60624          cpm22.asm:2818
closeit2 = $ECDE = 60638          cpm22.asm:2826
closeit3 = $ECE4 = 60644          cpm22.asm:2830
closeit4 = $ECEB = 60651          cpm22.asm:2833
closeit5 = $ED00 = 60672          cpm22.asm:2846
closeit6 = $ED1A = 60698          cpm22.asm:2864
closeit7 = $ED22 = 60706          cpm22.asm:2867
cmdadr   = $DFC1 = 57281          cpm22.asm:667
cmdtbl   = $DF10 = 57104          cpm22.asm:549
cmmnd1   = $DF82 = 57218          cpm22.asm:628
cmmnd2   = $DF98 = 57240          cpm22.asm:639
cntrlc   = $0003 =     3          cpm22.asm:23
cntrle   = $0005 =     5          cpm22.asm:24
cntrlp   = $0010 =    16          cpm22.asm:30
cntrlr   = $0012 =    18          cpm22.asm:31
cntrls   = $0013 =    19          cpm22.asm:32
cntrlu   = $0015 =    21          cpm22.asm:33
cntrlx   = $0018 =    24          cpm22.asm:34
cntrlz   = $001A =    26          cpm22.asm:35
comblk   = $E87A = 59514          cpm22.asm:1937
comfile  = $E383 = 58243          cpm22.asm:1189
command  = $DF5C = 57180          cpm22.asm:605
comprand = $EFA8 = 61352          cpm22.asm:3271
conin    = $F292 = 62098          bios.asm:121
conout   = $F29D = 62109          bios.asm:133
const    = $F288 = 62088          bios.asm:109
convert  = $DE60 = 56928          cpm22.asm:443
convfst  = $DE5E = 56926          cpm22.asm:437
convrt1  = $DE89 = 56969          cpm22.asm:466
convrt2  = $DE90 = 56976          cpm22.asm:469
convrt3  = $DE96 = 56982          cpm22.asm:476
convrt4  = $DE98 = 56984          cpm22.asm:477
convrt5  = $DEA9 = 57001          cpm22.asm:484
convrt6  = $DEAB = 57003          cpm22.asm:486
convrt7  = $DEAF = 57007          cpm22.asm:488
convrt8  = $DEB9 = 57017          cpm22.asm:492
counter  = $F1DB = 61915          cpm22.asm:3687
cpmlow   = $F280 = 62080          bios.asm:98
cr       = $000D =    13          cpm22.asm:29
create   = $DD09 = 56585          cpm22.asm:185
crlf     = $DC98 = 56472          cpm22.asm:77
curpos   = $E70F = 59151          cpm22.asm:1685
de2hl    = $E752 = 59218          cpm22.asm:1716
de2hl1   = $E753 = 59219          cpm22.asm:1717
decode   = $DFF8 = 57336          cpm22.asm:694
decode1  = $E008 = 57352          cpm22.asm:700
decode2  = $E02A = 57386          cpm22.asm:720 (unused)
decode3  = $E033 = 57395          cpm22.asm:725
decode4  = $E03A = 57402          cpm22.asm:729 (unused)
defdma   = $E9DD = 59869          cpm22.asm:2238
del      = $007F =   127          cpm22.asm:36
delbatch = $DDDD = 56797          cpm22.asm:345
delete   = $DCEF = 56559          cpm22.asm:156
delfile  = $F0DA = 61658          cpm22.asm:3483
dirbuf   = $F1BC = 61884          cpm22.asm:3662
dirc1    = $E6E3 = 59107          cpm22.asm:1643
dircbuf  = $FA00 = 64000          config.asm:40
dircio   = $E6D7 = 59095          cpm22.asm:1637
dirdma   = $E9E3 = 59875          cpm22.asm:2243
dirdma1  = $E9E6 = 59878          cpm22.asm:2248
direct   = $E077 = 57463          cpm22.asm:791
direct1  = $E088 = 57480          cpm22.asm:798
direct2  = $E08F = 57487          cpm22.asm:802
direct3  = $E098 = 57496          cpm22.asm:806
direct4  = $E0CC = 57548          cpm22.asm:833
direct5  = $E0D4 = 57556          cpm22.asm:836
direct6  = $E0D9 = 57561          cpm22.asm:838
direct7  = $E10E = 57614          cpm22.asm:862
direct8  = $E10F = 57615          cpm22.asm:863
direct9  = $E11B = 57627          cpm22.asm:867
dirread  = $E9D7 = 59863          cpm22.asm:2233
dirsize  = $F1CB = 61899          cpm22.asm:3674
dirwrite = $E9C9 = 59849          cpm22.asm:2225
diskpb   = $F1BE = 61886          cpm22.asm:3663
diskro   = $E4E4 = 58596          cpm22.asm:1316
dmaset   = $DDD8 = 56792          cpm22.asm:340
doread   = $E7B5 = 59317          cpm22.asm:1787
dowrite  = $E7BB = 59323          cpm22.asm:1792
drect63  = $E0F7 = 57591          cpm22.asm:852
drect65  = $E0F9 = 57593          cpm22.asm:853
dselect  = $E054 = 57428          cpm22.asm:761
dsksel   = $DCBD = 56509          cpm22.asm:109
dsksize  = $F1C9 = 61897          cpm22.asm:3673
emptyfcb = $F1AF = 61871          cpm22.asm:3649
entry    = $0005 =     5          cpm22.asm:16
entry1   = $DCC3 = 56515          cpm22.asm:116
entry2   = $DCF4 = 56564          cpm22.asm:162
eparam   = $F1D9 = 61913          cpm22.asm:3685
erafil1  = $EBA7 = 60327          cpm22.asm:2590
erafile  = $EB9F = 60319          cpm22.asm:2587
erase    = $E11F = 57631          cpm22.asm:876
erase1   = $E142 = 57666          cpm22.asm:891
error1   = $E49C = 58524          cpm22.asm:1294
error2   = $E4A8 = 58536          cpm22.asm:1300
error3   = $E4AE = 58542          cpm22.asm:1303
error4   = $E4B4 = 58548          cpm22.asm:1306
error5   = $E4B7 = 58551          cpm22.asm:1308
exists   = $E282 = 57986          cpm22.asm:1053
extblk   = $E861 = 59489          cpm22.asm:1918
extblk1  = $E874 = 59508          cpm22.asm:1928
extmask  = $F1C8 = 61896          cpm22.asm:3672
extract  = $E04B = 57419          cpm22.asm:751
fbase    = $E406 = 58374          cpm22.asm:1237
fbase1   = $E414 = 58388          cpm22.asm:1250
fcb      = $E3CD = 58317          cpm22.asm:1216
fcb2hl   = $E961 = 59745          cpm22.asm:2122
fcbpos   = $F1EC = 61932          cpm22.asm:3698
fcbset   = $EC00 = 60416          cpm22.asm:2682
fcreate  = $F0EF = 61679          cpm22.asm:3500
ff       = $000C =    12          cpm22.asm:28 (unused)
filepos  = $F1ED = 61933          cpm22.asm:3699
filero   = $E4DF = 58591          cpm22.asm:1315
filesize = $F150 = 61776          cpm22.asm:3574
findfst  = $EB1B = 60187          cpm22.asm:2507
findnxt  = $EB30 = 60208          cpm22.asm:2520
fndnxt1  = $EB4D = 60237          cpm22.asm:2533
fndnxt2  = $EB56 = 60246          cpm22.asm:2537
fndnxt3  = $EB76 = 60278          cpm22.asm:2553
fndnxt4  = $EB7F = 60287          cpm22.asm:2562
fndnxt5  = $EB86 = 60294          cpm22.asm:2567
fndnxt6  = $EB97 = 60311          cpm22.asm:2580
fndspa1  = $EBC3 = 60355          cpm22.asm:2620
fndspa2  = $EBD4 = 60372          cpm22.asm:2643
fndspa3  = $EBEF = 60399          cpm22.asm:2664
fndspa4  = $EBF7 = 60407          cpm22.asm:2674
fndspace = $EBC1 = 60353          cpm22.asm:2614
fndstat  = $F1D7 = 61911          cpm22.asm:3683
functns  = $E44A = 58442          cpm22.asm:1285
getaloc  = $F114 = 61716          cpm22.asm:3528
getback  = $E386 = 58246          cpm22.asm:1195
getback1 = $E389 = 58249          cpm22.asm:1196
getblk1  = $E848 = 59464          cpm22.asm:1896
getblk2  = $E856 = 59478          cpm22.asm:1905
getblk3  = $E85F = 59487          cpm22.asm:1910
getblock = $E841 = 59457          cpm22.asm:1893
getchar  = $E4FE = 58622          cpm22.asm:1333
getcon   = $E6CB = 59083          cpm22.asm:1625
getcrnt  = $F107 = 61703          cpm22.asm:3517
getcsts  = $E701 = 59137          cpm22.asm:1670
getdsk   = $DDD0 = 56784          cpm22.asm:331
getecho  = $E509 = 58633          cpm22.asm:1342
getempty = $ED27 = 60711          cpm22.asm:2874
getext   = $DEC0 = 57024          cpm22.asm:499
getext1  = $DEC8 = 57032          cpm22.asm:503
getext2  = $DED9 = 57049          cpm22.asm:510
getext3  = $DEDB = 57051          cpm22.asm:512
getext4  = $DEDF = 57055          cpm22.asm:514
getext5  = $DEE9 = 57065          cpm22.asm:518
getext6  = $DEF0 = 57072          cpm22.asm:522
getext7  = $DEF2 = 57074          cpm22.asm:523
getext8  = $DF01 = 57089          cpm22.asm:535
getext9  = $DF09 = 57097          cpm22.asm:540
getfst   = $F0AE = 61614          cpm22.asm:3459
getfst1  = $F0C5 = 61637          cpm22.asm:3470
getinp   = $DD39 = 56633          cpm22.asm:236
getinp1  = $DD96 = 56726          cpm22.asm:292
getinp2  = $DDA7 = 56743          cpm22.asm:301
getinp3  = $DDAB = 56747          cpm22.asm:303
getinp4  = $DDBA = 56762          cpm22.asm:312
getiob   = $E6F0 = 59120          cpm22.asm:1651
getlog   = $F101 = 61697          cpm22.asm:3512
getmt1   = $ED49 = 60745          cpm22.asm:2890
getnext  = $ED5D = 60765          cpm22.asm:2904
getnxt   = $F0CB = 61643          cpm22.asm:3475
getparm  = $F129 = 61737          cpm22.asm:3545
getprm1  = $F12C = 61740          cpm22.asm:3546
getrdr   = $E6D1 = 59089          cpm22.asm:1630
getrov   = $F11A = 61722          cpm22.asm:3533
gets2    = $E96C = 59756          cpm22.asm:2136
getsetuc = $DD15 = 56597          cpm22.asm:201
getuser  = $F130 = 61744          cpm22.asm:3553
getusr   = $DD13 = 56595          cpm22.asm:196
getver   = $F081 = 61569          cpm22.asm:3429
getwprt  = $E921 = 59681          cpm22.asm:2076
goback   = $F177 = 61815          cpm22.asm:3609
goback1  = $F194 = 61844          cpm22.asm:3621
gtnext1  = $ED86 = 60806          cpm22.asm:2924
gtnext2  = $ED91 = 60817          cpm22.asm:2933
gtnext3  = $EDAF = 60847          cpm22.asm:2944
gtnext4  = $EDB2 = 60850          cpm22.asm:2945
gtnext5  = $EDB9 = 60857          cpm22.asm:2952
halt     = $DFCF = 57295          cpm22.asm:672
hl2de    = $E042 = 57410          cpm22.asm:741
home     = $F2AD = 62125          bios.asm:153
homedrv  = $E7A4 = 59300          cpm22.asm:1773
imgtop   = $F838 = 63544          config.asm:174
inbuff   = $DC06 = 56326          cpm22.asm:49
inbulen  = $DC07 = 56327          config.asm:21
inpoint  = $DC88 = 56456          cpm22.asm:57
iobyte   = $0003 =     3          cpm22.asm:14
ioerr1   = $E708 = 59144          cpm22.asm:1680
ioret    = $E7BE = 59326          cpm22.asm:1793
jumphl   = $E74D = 59213          cpm22.asm:1708
lf       = $000A =    10          cpm22.asm:27
list     = $F2A8 = 62120          bios.asm:141
logical  = $E88D = 59533          cpm22.asm:1957
logicl1  = $E893 = 59539          cpm22.asm:1959
login    = $F1B2 = 61874          cpm22.asm:3651
logindrv = $F024 = 61476          cpm22.asm:3373
logoff   = $F156 = 61782          cpm22.asm:3583
logsect  = $F1EA = 61930          cpm22.asm:3697
mem      = $0037 =    55          config.asm:19
mode     = $F1D8 = 61912          cpm22.asm:3684
morefls  = $E982 = 59778          cpm22.asm:2160
move3    = $E040 = 57408          cpm22.asm:737
movecd   = $DD29 = 56617          cpm22.asm:218
movedir  = $E9EC = 59884          cpm22.asm:2255
moveword = $EC97 = 60567          cpm22.asm:2781
namepnt  = $DC8A = 56458          cpm22.asm:58
nbytes   = $E3F1 = 58353          cpm22.asm:1220
newline  = $E5B4 = 58804          cpm22.asm:1467
newln1   = $E5BC = 58812          cpm22.asm:1470
nf_asva  = $FAC7 = 64199          nabu1797.asm:526
nf_asvb  = $FAE0 = 64224          nabu1797.asm:527
nf_bss   = $FAC0 = 64192          config.asm:42
nf_busy  = $F82D = 63533          nabu1797.asm:501
nf_cach  = $FC00 = 64512          config.asm:43
nf_ccp   = $F7B8 = 63416          nabu1797.asm:399
nf_csva  = $FAF9 = 64249          nabu1797.asm:528
nf_csvb  = $FB09 = 64265          nabu1797.asm:529
nf_curd  = $FAC2 = 64194          nabu1797.asm:519
nf_dirt  = $FAC6 = 64198          nabu1797.asm:523
nf_dpb   = $F610 = 62992          nabu1797.asm:52
nf_dpha  = $F5F0 = 62960          nabu1797.asm:36
nf_dphb  = $F600 = 62976          nabu1797.asm:44
nf_dvsc  = $F816 = 63510          nabu1797.asm:482
nf_dvsl  = $F81C = 63516          nabu1797.asm:485
nf_grb   = $F7B1 = 63409          nabu1797.asm:394
nf_home  = $F662 = 63074          nabu1797.asm:126
nf_inco  = $FAC5 = 64197          nabu1797.asm:522
nf_ini1  = $F63D = 63037          nabu1797.asm:90
nf_ini2  = $F64B = 63051          nabu1797.asm:101
nf_init  = $F637 = 63031          nabu1797.asm:85
nf_io    = $FAC0 = 64192          nabu1797.asm:516
nf_r2k   = $F7BD = 63421          nabu1797.asm:404
nf_r2k0  = $F7E6 = 63462          nabu1797.asm:433
nf_r2ks  = $FAC1 = 64193          nabu1797.asm:517
nf_rdsk  = $0002 =     2          nabu1797.asm:24
nf_rdw0  = $F73C = 63292          nabu1797.asm:296
nf_rdw1  = $F74A = 63306          nabu1797.asm:303
nf_rdwr  = $F71D = 63261          nabu1797.asm:275
nf_read  = $F74F = 63311          nabu1797.asm:309
nf_rph1  = $F803 = 63491          nabu1797.asm:465
nf_rph2  = $F811 = 63505          nabu1797.asm:474
nf_rphy  = $F7FA = 63482          nabu1797.asm:456
nf_sel   = $F67A = 63098          nabu1797.asm:149
nf_sel0  = $F689 = 63113          nabu1797.asm:158
nf_sel1  = $F6A8 = 63144          nabu1797.asm:177
nf_sel2  = $F6BA = 63162          nabu1797.asm:190
nf_ssec  = $F6FE = 63230          nabu1797.asm:248
nf_stal  = $F833 = 63539          nabu1797.asm:509
nf_str0  = $F6E1 = 63201          nabu1797.asm:222
nf_strk  = $F6C8 = 63176          nabu1797.asm:203
nf_subs  = $FAC3 = 64195          nabu1797.asm:520
nf_sync  = $FAC4 = 64196          nabu1797.asm:521
nf_udsl  = $F81B = 63515          nabu1797.asm:484
nf_wde1  = $F78A = 63370          nabu1797.asm:357
nf_wde2  = $F798 = 63384          nabu1797.asm:366
nf_wde3  = $F7A9 = 63401          nabu1797.asm:385
nf_wde4  = $F7AC = 63404          nabu1797.asm:388
nf_wdef  = $F76F = 63343          nabu1797.asm:339
nf_writ  = $F757 = 63319          nabu1797.asm:317
nfddev   = $F61F = 63007          nabu1797.asm:69
nfuncts  = $0029 =    41          cpm22.asm:1283
nofile   = $DFF0 = 57328          cpm22.asm:687
nonblank = $DE4F = 56911          cpm22.asm:419
none     = $DFEA = 57322          cpm22.asm:685
nospace  = $E207 = 57863          cpm22.asm:995
nulldev  = $F30B = 62219          bios.asm:257 (unused)
numcmds  = $0006 =     6          cpm22.asm:548
nxent1   = $EA1C = 59932          cpm22.asm:2293
nxent2   = $EA23 = 59939          cpm22.asm:2296
nxentry  = $EA08 = 59912          cpm22.asm:2285
offset   = $F1D1 = 61905          cpm22.asm:3677
olddrv   = $F1E2 = 61922          cpm22.asm:3691
open     = $DCCB = 56523          cpm22.asm:123
openfcb  = $DCD0 = 56528          cpm22.asm:128
openfil  = $F09F = 61599          cpm22.asm:3446
openit   = $EC54 = 60500          cpm22.asm:2738
openit1  = $EC5D = 60509          cpm22.asm:2742
openit2  = $EC8E = 60558          cpm22.asm:2770
outchar  = $E54B = 58699          cpm22.asm:1393
outchr1  = $E565 = 58725          cpm22.asm:1407
outchr2  = $E57C = 58748          cpm22.asm:1423
outcon   = $E593 = 58771          cpm22.asm:1444
outcon1  = $E599 = 58777          cpm22.asm:1447
outcrlf  = $E5CC = 58828          cpm22.asm:1480
outflag  = $E70D = 59149          cpm22.asm:1683
params   = $E746 = 59206          cpm22.asm:1699
pattrn1  = $DF28 = 57128          cpm22.asm:559
pattrn2  = $E400 = 58368          cpm22.asm:1229
pline    = $DCA7 = 56487          cpm22.asm:90
pline2   = $DCAC = 56492          cpm22.asm:93
position = $EF06 = 61190          cpm22.asm:3148
positn1  = $EF0A = 61194          cpm22.asm:3153
positn2  = $EF4A = 61258          cpm22.asm:3199
positn3  = $EF82 = 61314          cpm22.asm:3231
positn4  = $EF87 = 61319          cpm22.asm:3237
positn5  = $EF8E = 61326          cpm22.asm:3244
print    = $DC8C = 56460          cpm22.asm:63
printb   = $DC92 = 56466          cpm22.asm:69
prstat   = $F2E6 = 62182          bios.asm:219
prterr   = $E4E8 = 58600          cpm22.asm:1320
prtflag  = $E710 = 59152          cpm22.asm:1686
prtmesg  = $E5D6 = 58838          cpm22.asm:1487
prtstr   = $E6FB = 59131          cpm22.asm:1663
punch    = $F2A9 = 62121          bios.asm:144
putdma   = $F10D = 61709          cpm22.asm:3522
ransiz1  = $EFE7 = 61415          cpm22.asm:3327
ransiz2  = $F009 = 61449          cpm22.asm:3349
ransiz3  = $F00F = 61455          cpm22.asm:3351
ransize  = $EFD5 = 61397          cpm22.asm:3316
rdbuf1   = $E5F2 = 58866          cpm22.asm:1506
rdbuf10  = $E673 = 58995          cpm22.asm:1568
rdbuf11  = $E67B = 59003          cpm22.asm:1574
rdbuf12  = $E68D = 59021          cpm22.asm:1586
rdbuf13  = $E69C = 59036          cpm22.asm:1593
rdbuf14  = $E6A9 = 59049          cpm22.asm:1601
rdbuf15  = $E6AC = 59052          cpm22.asm:1604
rdbuf16  = $E6C0 = 59072          cpm22.asm:1616
rdbuf17  = $E6C4 = 59076          cpm22.asm:1618
rdbuf2   = $E5F4 = 58868          cpm22.asm:1508
rdbuf3   = $E619 = 58905          cpm22.asm:1525
rdbuf4   = $E629 = 58921          cpm22.asm:1534
rdbuf5   = $E63A = 58938          cpm22.asm:1542
rdbuf6   = $E64B = 58955          cpm22.asm:1551
rdbuf7   = $E651 = 58961          cpm22.asm:1554
rdbuf8   = $E662 = 58978          cpm22.asm:1561
rdbuf9   = $E66E = 58990          cpm22.asm:1566
rdbuff   = $E5E4 = 58852          cpm22.asm:1499
rderr    = $DFDF = 57311          cpm22.asm:681
rderror  = $DFD9 = 57305          cpm22.asm:679
rdrandom = $F144 = 61764          cpm22.asm:3564
rdrec    = $DCF9 = 56569          cpm22.asm:169
rdseq    = $EDBF = 60863          cpm22.asm:2957
rdseq1   = $EDC4 = 60868          cpm22.asm:2959
rdseq2   = $EDE9 = 60905          cpm22.asm:2974
rdseq3   = $EDFE = 60926          cpm22.asm:2984
rdwrtflg = $F1D6 = 61910          cpm22.asm:3682
read     = $F2DE = 62174          bios.asm:208
reader   = $F2AA = 62122          bios.asm:147
readfcb  = $DCFE = 56574          cpm22.asm:174
readran  = $EF96 = 61334          cpm22.asm:3251
readseq  = $F0E3 = 61667          cpm22.asm:3490
relblock = $F1DA = 61914          cpm22.asm:3686
renam    = $DD0E = 56590          cpm22.asm:191
rename   = $E210 = 57872          cpm22.asm:1003
rename1  = $E23F = 57919          cpm22.asm:1021
rename2  = $E259 = 57945          cpm22.asm:1035
rename3  = $E25E = 57950          cpm22.asm:1038 (unused)
rename4  = $E26D = 57965          cpm22.asm:1046
rename5  = $E273 = 57971          cpm22.asm:1048
rename6  = $E279 = 57977          cpm22.asm:1050
renfile  = $F0F8 = 61688          cpm22.asm:3506
resccp   = $F32B = 62251          config.asm:108
resdsk   = $DCB8 = 56504          cpm22.asm:104
resetdr  = $E066 = 57446          cpm22.asm:775
resgrb   = $F32E = 62254          config.asm:114
rodisk   = $E410 = 58384          cpm22.asm:1244
rofile   = $E412 = 58386          cpm22.asm:1245
rstdsk   = $F086 = 61574          cpm22.asm:3434
rtn      = $E707 = 59143          cpm22.asm:1676
rtncode  = $E3EE = 58350          cpm22.asm:1217
samext   = $EB0A = 60170          cpm22.asm:2488
savatr1  = $EC43 = 60483          cpm22.asm:2728
save     = $E1AD = 57773          cpm22.asm:948
save1    = $E1D4 = 57812          cpm22.asm:966
save2    = $E1F1 = 57841          cpm22.asm:984
save3    = $E1FB = 57851          cpm22.asm:991
save4    = $E201 = 57857          cpm22.asm:993
saveattr = $EC3E = 60478          cpm22.asm:2726
savefcb  = $F1DC = 61916          cpm22.asm:3688
savext   = $F1E5 = 61925          cpm22.asm:3694
savnrec  = $F1E6 = 61926          cpm22.asm:3695
savnxt   = $F1E4 = 61924          cpm22.asm:3693
scratch1 = $F1B6 = 61878          cpm22.asm:3656
scratch2 = $F1B8 = 61880          cpm22.asm:3657
scratch3 = $F1BA = 61882          cpm22.asm:3658
search   = $DF2E = 57134          cpm22.asm:567
search1  = $DF33 = 57139          cpm22.asm:569
search2  = $DF3C = 57148          cpm22.asm:574
search3  = $DF4F = 57167          cpm22.asm:586
search4  = $DF54 = 57172          cpm22.asm:589
sectors  = $F1C4 = 61892          cpm22.asm:3669
sectrn   = $F2E9 = 62185          bios.asm:224
seldsk   = $F2B2 = 62130          bios.asm:162
select   = $E75C = 59228          cpm22.asm:1727
select1  = $E7A0 = 59296          cpm22.asm:1767
setattr  = $F120 = 61728          cpm22.asm:3538
setbit   = $E90E = 59662          cpm22.asm:2059
setcdrv  = $DD1A = 56602          cpm22.asm:206
setdir   = $E99F = 59807          cpm22.asm:2193
setdma   = $F2D8 = 62168          bios.asm:200
setdsk   = $F048 = 61512          cpm22.asm:3394
setext   = $E8A9 = 59561          cpm22.asm:1974
setfile  = $EA6E = 60014          cpm22.asm:2378
setfl1   = $EA78 = 60024          cpm22.asm:2383
setfl2   = $EA8B = 60043          cpm22.asm:2395
setfl3   = $EA91 = 60049          cpm22.asm:2401
setfl4   = $EAA0 = 60064          cpm22.asm:2410
sethlde  = $E8B1 = 59569          cpm22.asm:1982
setiob   = $E6F6 = 59126          cpm22.asm:1656
setnrec  = $E8D5 = 59605          cpm22.asm:2008
setran   = $F011 = 61457          cpm22.asm:3357
sets2b7  = $E97B = 59771          cpm22.asm:2150
setsec   = $F2D4 = 62164          bios.asm:193
setstat  = $E704 = 59140          cpm22.asm:1675
settrk   = $F2D0 = 62160          bios.asm:186
setuser  = $F13E = 61758          cpm22.asm:3558
shiftl   = $E907 = 59655          cpm22.asm:2050
shiftl1  = $E908 = 59656          cpm22.asm:2051
shiftr   = $E8ED = 59629          cpm22.asm:2024
shiftr1  = $E8EE = 59630          cpm22.asm:2025
showit   = $E582 = 58754          cpm22.asm:1431
slcterr  = $E74A = 59210          cpm22.asm:1704
space    = $DCA2 = 56482          cpm22.asm:84
srchfcb  = $DCE9 = 56553          cpm22.asm:151
srchfst  = $DCDF = 56543          cpm22.asm:141
srchnxt  = $DCE4 = 56548          cpm22.asm:146
starting = $E70E = 59150          cpm22.asm:1684
status   = $E748 = 59208          cpm22.asm:1700
stbitmap = $EA5F = 59999          cpm22.asm:2358
stbmap1  = $EA67 = 60007          cpm22.asm:2369
stddma   = $DDD5 = 56789          cpm22.asm:336
stfilpos = $EA01 = 59905          cpm22.asm:2273
stkarea  = $E744 = 59204          cpm22.asm:1695
stnrec1  = $E8E1 = 59617          cpm22.asm:2013
strdata  = $E8BE = 59582          cpm22.asm:1992
ststatus = $EB04 = 60164          cpm22.asm:2480
subhl    = $E998 = 59800          cpm22.asm:2183
swindi0  = $F2F3 = 62195          bios.asm:240
swindi1  = $F2F9 = 62201          bios.asm:244
swindir  = $F2EF = 62191          bios.asm:238
synerr   = $DE09 = 56841          cpm22.asm:374
synerr1  = $DE0F = 56847          cpm22.asm:376
synerr2  = $DE22 = 56866          cpm22.asm:386
tab      = $0009 =     9          cpm22.asm:26
tbase    = $0100 =   256          cpm22.asm:19
tbuff    = $0080 =   128          cpm22.asm:18
tdrive   = $0004 =     4          cpm22.asm:15
tfcb     = $005C =    92          cpm22.asm:17
tm_addh  = $F5E3 = 62947          tms9918.asm:502
tm_addr  = $F5E5 = 62949          tms9918.asm:504
tm_bs    = $F477 = 62583          tms9918.asm:215
tm_bss   = $FA80 = 64128          config.asm:41
tm_cbuf  = $FA85 = 64133          tms9918.asm:520
tm_cha0  = $F593 = 62867          tms9918.asm:434
tm_chat  = $F58D = 62861          tms9918.asm:429
tm_cle0  = $F4EF = 62703          tms9918.asm:296
tm_clea  = $F4EC = 62700          tms9918.asm:294
tm_cles  = $F4EA = 62698          tms9918.asm:293
tm_cloc  = $F3E1 = 62433          tms9918.asm:97
tm_cls   = $F5D2 = 62930          tms9918.asm:488
tm_cls0  = $F5DB = 62939          tms9918.asm:491
tm_cr    = $F474 = 62580          tms9918.asm:212
tm_cshm  = $F486 = 62598          tms9918.asm:229
tm_curx  = $FA80 = 64128          tms9918.asm:513
tm_cury  = $FA81 = 64129          tms9918.asm:514
tm_data  = $00A0 =   160          tms9918.asm:17
tm_dsc0  = $F518 = 62744          tms9918.asm:325
tm_dsco  = $F505 = 62725          tms9918.asm:318
tm_esc   = $F4BB = 62651          tms9918.asm:261
tm_esc0  = $F4C9 = 62665          tms9918.asm:270
tm_esc1  = $F4D4 = 62676          tms9918.asm:276
tm_esc2  = $F4DF = 62687          tms9918.asm:283
tm_escd  = $F4C4 = 62660          tms9918.asm:267
tm_esci  = $F4CE = 62670          tms9918.asm:273
tm_escr  = $F4C5 = 62661          tms9918.asm:268
tm_escs  = $FA84 = 64132          tms9918.asm:517
tm_getc  = $F52B = 62763          tms9918.asm:346
tm_home  = $F489 = 62601          tms9918.asm:230
tm_ini0  = $F3D7 = 62423          tms9918.asm:84
tm_init  = $F3A0 = 62368          tms9918.asm:50
tm_keyd  = $0090 =   144          tms9918.asm:20
tm_keys  = $0091 =   145          tms9918.asm:21
tm_latc  = $00A1 =   161          tms9918.asm:18
tm_lf    = $F468 = 62568          tms9918.asm:203
tm_map   = $F540 = 62784          tms9918.asm:367
tm_outc  = $FA82 = 64130          tms9918.asm:515
tm_putc  = $F569 = 62825          tms9918.asm:401
tm_putf  = $F577 = 62839          tms9918.asm:409
tm_rea0  = $F3FD = 62461          tms9918.asm:118
tm_rea1  = $F412 = 62482          tms9918.asm:131
tm_rea2  = $F422 = 62498          tms9918.asm:141
tm_read  = $F3E7 = 62439          tms9918.asm:106
tm_ri    = $F461 = 62561          tms9918.asm:197
tm_sclf  = $F55F = 62815          tms9918.asm:389
tm_scr0  = $F556 = 62806          tms9918.asm:385
tm_scr1  = $F55C = 62812          tms9918.asm:387
tm_scri  = $F54C = 62796          tms9918.asm:380
tm_scro  = $FA83 = 64131          tms9918.asm:516
tm_sta1  = $F433 = 62515          tms9918.asm:155
tm_stal  = $F430 = 62512          tms9918.asm:153
tm_stat  = $F38E = 62350          tms9918.asm:37
tm_up    = $F481 = 62593          tms9918.asm:224
tm_usc0  = $F5BE = 62910          tms9918.asm:467
tm_usco  = $F5AF = 62895          tms9918.asm:460
tm_vcpy  = $F599 = 62873          tms9918.asm:446
tm_wri0  = $F44E = 62542          tms9918.asm:185
tm_wri1  = $F48D = 62605          tms9918.asm:235
tm_writ  = $F439 = 62521          tms9918.asm:167
tmsdev   = $F381 = 62337          tms9918.asm:24
trksec   = $E7C6 = 59334          cpm22.asm:1801
trksec1  = $E7D4 = 59348          cpm22.asm:1810
trksec2  = $E7E7 = 59367          cpm22.asm:1823
trksec3  = $E7FD = 59389          cpm22.asm:1839
trksec4  = $E812 = 59410          cpm22.asm:1856
type     = $E15D = 57693          cpm22.asm:905
type1    = $E174 = 57716          cpm22.asm:913
type2    = $E177 = 57719          cpm22.asm:914 (unused)
type3    = $E187 = 57735          cpm22.asm:923
type4    = $E1A0 = 57760          cpm22.asm:936
type5    = $E1A7 = 57767          cpm22.asm:939
unknown  = $E2A5 = 58021          cpm22.asm:1077
unkwn0   = $E371 = 58225          cpm22.asm:1185
unkwn1   = $E2C4 = 58052          cpm22.asm:1092
unkwn2   = $E2CD = 58061          cpm22.asm:1096 (unused)
unkwn3   = $E2E1 = 58081          cpm22.asm:1107
unkwn4   = $E301 = 58113          cpm22.asm:1126
unkwn5   = $E330 = 58160          cpm22.asm:1147
unkwn6   = $E33E = 58174          cpm22.asm:1157
unkwn7   = $E343 = 58179          cpm22.asm:1159
unkwn8   = $E34F = 58191          cpm22.asm:1167
unkwn9   = $E36B = 58219          cpm22.asm:1183
update   = $EC04 = 60420          cpm22.asm:2689
update1  = $EC13 = 60435          cpm22.asm:2697
upper    = $DD30 = 56624          cpm22.asm:225
user     = $E28E = 57998          cpm22.asm:1061
userdma  = $F1B4 = 61876          cpm22.asm:3652
userno   = $E744 = 59204          cpm22.asm:1697
usrstack = $E712 = 59154          cpm22.asm:1691
verify   = $DDF5 = 56821          cpm22.asm:360
verify1  = $DDFD = 56829          cpm22.asm:363
wboot    = $F241 = 62017          bios.asm:48
wboot0   = $F25A = 62042          bios.asm:67
wbootin  = $F203 = 61955          bios.asm:22
wbootr   = $F24A = 62026          bios.asm:55
write    = $F2E2 = 62178          bios.asm:215
writeran = $EF9F = 61343          cpm22.asm:3258
wrtprt   = $F1B0 = 61872          cpm22.asm:3650
wrtprtd  = $E92F = 59695          cpm22.asm:2086
wrtrec   = $DD04 = 56580          cpm22.asm:180
wrtseq   = $F0E9 = 61673          cpm22.asm:3495
wtrandom = $F14A = 61770          cpm22.asm:3569
wtseq    = $EE01 = 60929          cpm22.asm:2988
wtseq1   = $EE06 = 60934          cpm22.asm:2990
wtseq10  = $EED5 = 61141          cpm22.asm:3105
wtseq11  = $EF01 = 61185          cpm22.asm:3129
wtseq12  = $EF03 = 61187          cpm22.asm:3130
wtseq2   = $EE3E = 60990          cpm22.asm:3013
wtseq3   = $EE4B = 61003          cpm22.asm:3019
wtseq4   = $EE67 = 61031          cpm22.asm:3031
wtseq5   = $EE6F = 61039          cpm22.asm:3038
wtseq6   = $EE71 = 61041          cpm22.asm:3039
wtseq7   = $EE8F = 61071          cpm22.asm:3062
wtseq8   = $EE9D = 61085          cpm22.asm:3069
wtseq9   = $EEBE = 61118          cpm22.asm:3089
wtseq99  = $EEE2 = 61154          cpm22.asm:3116 (unused)
wtspecl  = $F19E = 61854          cpm22.asm:3635
xlate    = $F1D3 = 61907          cpm22.asm:3678
yesno    = $E152 = 57682          cpm22.asm:897


total time: 0.0406 sec.
no errors
